{
  "hash": "d6c454919f4ddd64f188261040dd32f2",
  "result": {
    "markdown": "---\ntitle: \"Basic Network Statistics for Directed Graphs\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nAs we saw in the lecture notes on [basic network statistics](basic.qmd), the **degree distribution** and the **degree correlation** are two basic things we want to have a sense of when characterizing a network, and we showed examples for the undirected graph case. However, when you have a network measuring a tie with some meaningful \"from\" \"to\" directionality (represented as a **directed graph**) the number of things you have to compute in terms of degrees \"doubles.\" \n\nFor instance, instead of a single degree set and sequence, now we have two: An **outdegree** and an **indegree** set and sequence. The same thing applies to the degree distribution and the degree correlation.\n\nLet's see how this works. First, we load a network of directed relations that is represented using a **directed graph**. This is a network composed of advice relations between members of a low firm studied by [-@lazega01]. In the `networkdata` package it is called `law_advice`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(networkdata)\n    library(igraph)\n    g <- law_advice\n```\n:::\n\n\nThe nodes in this graph don't have names, so we just assign them numbers as labels, using the `graph` node attribute function `V()`, which takes the graph object as input, followed by a `$` sign and the name of the node attribute we are setting (in this case the `name` attribute):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   V(g)$name <- paste(\"Lyr\", 1:vcount(g), sep = \"_\")\n```\n:::\n\n\nHere we set the `name` attribute to a vector of labels composed of \"Lyr\" (for lawyer) followed by a number between one and the order the graph. \n\n## Graph Density\n\nIn the directed case, the formula for the density is just:\n\n$$\n d(G) = \\frac{m}{n(n-1)}\n$$ {#eq-dens}\n\nNote that the main difference with the formula for undirected graphs is that we don't double the numerator (number of edges).\n\nSo in `R` we would just do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    m <- ecount(g)\n    n <- vcount(g)\n    m/(n*(n-1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1794769\n```\n:::\n:::\n\n\nWhich is the same answer we get with the `igraph` function `edge_density`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    edge_density(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1794769\n```\n:::\n:::\n\n\n## Graph Reciprocity\n\nOne quantity that is only defined for directed graphs is the **graph reciprocity** ($r(G)$). This is a measure of the extent to which directed links are mutually directed among actors in the network (e.g., they go both ways). \n\nWe can express the graph reciprocity in terms of the entries of the adjacency matrix $\\mathbf{A}$ as:\n\n$$\nr(G) = \\sum_{i, j = 1}^N\\frac{a_{ij}a_{ji}}{|E|}\n$$ {#eq-rep}\n\nWhere $|E|$ refers to the number of edges in the graph. Note that the numerator of the @eq-rep counts the number of reciprocal links since the product term $a_{ij}a_{ji}$ only when $a_{ij}=1$ *and* $a_{ji}=1$ in the adjacency matrix.\n\nThe graph reciprocity can also be expressed in \"matrix\" form as:\n\n\n$$\nr(G) = \\frac{tr(\\mathbf{A}^2)}{|E|}\n$$ {#eq-repm}\n\nWhere $tr$ refers to the trace matrix operation which yields the sum of the matrix diagonal entries as a result, and the square refers to the (second) **powers of the matrix** (the adjacency matrix multiplied by itself), .\n\nSo in `R` we can compute the reciprocity of a directed graph as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    A <- as.matrix(as_adjacency_matrix(g))\n    r <- sum(diag((A %*% A)))/ecount(g)\n    round(r, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.392\n```\n:::\n:::\n\n\nWhere we use the `diag` function, which extracts the diagonal entries of a matrix (in this case the square of the adjacency matrix) as a vector to compute the matrix trace (the sum of the entries of the diagonal vector).\n\nThe graph reciprocity is a number between zero and one, with zero indicating that none of the connected dyads are mutual, and one indicating that all are. Of course real networks will fall in between. As we can see, in the law advice network, about 39.2% of the observed connected dyads are composed of mutual advice relations.\n\nOf course, there's an `igraph` function to compute the graph reciprocity called (you guessed it) `reciprocity`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    r <- reciprocity(g)\n    round(r, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.392\n```\n:::\n:::\n\n\n## Indegrees and Outdegrees\n\nFor the degree, now we have two different flavors: We can count the number of nodes that point to another node (called that node's **in-neighbors**) or we can count the number of nodes that a given node points to (called that node's **out-neighbors**).\n\nThat means that we have two different degree vectors. The **indegree vector** and the **outdegree vector**. In `igraph` we obtain those by specifying the `mode` argument to either `in` or `out` in the `degree` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.i <- degree(g, mode = \"in\") #indegrees\n   d.i.sort <- sort(d.i, decreasing = TRUE) #indegree sequence\n   d.i.sort\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLyr_26 Lyr_13 Lyr_17 Lyr_24 Lyr_34 Lyr_40  Lyr_2 Lyr_22  Lyr_1 Lyr_20 Lyr_21 \n    37     34     26     26     25     25     23     23     22     22     22 \nLyr_28 Lyr_41  Lyr_6 Lyr_12 Lyr_15 Lyr_16 Lyr_30  Lyr_4 Lyr_11 Lyr_32  Lyr_5 \n    22     22     21     20     20     20     20     19     19     19     17 \nLyr_29 Lyr_38 Lyr_39 Lyr_14 Lyr_31  Lyr_9  Lyr_8 Lyr_35 Lyr_52 Lyr_10 Lyr_18 \n    17     17     17     16     15     14     13     13     13     12     11 \nLyr_19 Lyr_50 Lyr_57 Lyr_25 Lyr_36 Lyr_43 Lyr_56 Lyr_64 Lyr_27 Lyr_46 Lyr_49 \n    11     11     11     10     10     10     10     10      9      9      9 \nLyr_54  Lyr_3 Lyr_23 Lyr_45 Lyr_55 Lyr_33 Lyr_60 Lyr_65  Lyr_7 Lyr_68 Lyr_70 \n     9      8      8      8      8      7      7      7      6      5      5 \nLyr_37 Lyr_42 Lyr_48 Lyr_53 Lyr_58 Lyr_62 Lyr_67 Lyr_69 Lyr_51 Lyr_59 Lyr_63 \n     4      4      4      4      4      4      3      3      2      2      2 \nLyr_66 Lyr_71 Lyr_47 Lyr_61 Lyr_44 \n     2      2      1      1      0 \n```\n:::\n:::\n\nWe can see that Lawyers 26, 13, and 17 are the most popular kids in terms of being sought after for advice. \n\nAnd now for the outdegree:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.o <- degree(g, mode = \"out\") #outdegrees\n   d.o.sort <- sort(d.o, decreasing = TRUE) #outdegree sequence\n   d.o.sort\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLyr_19 Lyr_16 Lyr_28 Lyr_66 Lyr_42 Lyr_65 Lyr_26 Lyr_51 Lyr_24 Lyr_55 Lyr_17 \n    30     27     27     26     25     25     24     23     22     22     21 \nLyr_27 Lyr_41 Lyr_12 Lyr_56 Lyr_31 Lyr_35  Lyr_4 Lyr_30 Lyr_33 Lyr_48 Lyr_13 \n    21     21     20     20     18     18     17     17     17     17     16 \nLyr_67 Lyr_14 Lyr_39 Lyr_43 Lyr_54 Lyr_29 Lyr_52 Lyr_71 Lyr_22 Lyr_57 Lyr_58 \n    16     14     14     14     14     13     13     13     12     12     12 \nLyr_60 Lyr_63 Lyr_69 Lyr_20 Lyr_21 Lyr_32 Lyr_15 Lyr_45 Lyr_50 Lyr_62 Lyr_68 \n    12     12     12     11     11     11     10     10     10     10     10 \nLyr_23 Lyr_49 Lyr_59 Lyr_25 Lyr_40 Lyr_64  Lyr_2  Lyr_3 Lyr_10 Lyr_36 Lyr_46 \n     9      9      9      8      8      8      7      7      7      7      7 \nLyr_70 Lyr_34 Lyr_38 Lyr_44 Lyr_11 Lyr_18 Lyr_47  Lyr_5  Lyr_7 Lyr_53  Lyr_1 \n     7      6      6      6      5      5      5      4      4      4      3 \n Lyr_9 Lyr_37 Lyr_61  Lyr_8  Lyr_6 \n     3      3      3      2      0 \n```\n:::\n:::\n\n\nWe can see that lawyers 19, 16, and 28 are the most active advice seekers. \n\nJust like before, we can compute various degree quantities, except we must do it twice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum(d.i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 892\n```\n:::\n\n```{.r .cell-code}\n   sum(d.o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 892\n```\n:::\n\n```{.r .cell-code}\n   max(d.i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 37\n```\n:::\n\n```{.r .cell-code}\n   max(d.o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30\n```\n:::\n\n```{.r .cell-code}\n   min(d.i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n   min(d.o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n   mean(d.i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12.56338\n```\n:::\n\n```{.r .cell-code}\n   mean(d.o)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12.56338\n```\n:::\n:::\n\n\nNote that for both `sum` and the `mean` we actually *don't* have to do it twice. The sum of the indegrees in a directed graph is always equal to the sum of the indegrees, which means that the mean indegree is always equal to the mean outdegree (as that is the sum divided by the same number $N$).\n\nWe can also express the in ($\\mathbf{d}_i$) and out ($\\mathbf{d}_o$) degrees in matrix form:\n\n$$\n\\mathbf{d}_i = \\mathbf{A}^T\\mathbf{e}\n$$\n\n$$\n\\mathbf{d}_o = \\mathbf{A}\\mathbf{e}\n$$\n\nWhich in `R` can be obtained as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as.matrix(as_adjacency_matrix(g))\n   e <- matrix(1, nrow(A), 1)\n   d.i <- t(A) %*% e\n   d.o <- A %*% e\n   d.i[1:10, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Lyr_1  Lyr_2  Lyr_3  Lyr_4  Lyr_5  Lyr_6  Lyr_7  Lyr_8  Lyr_9 Lyr_10 \n    22     23      8     19     17     21      6     13     14     12 \n```\n:::\n\n```{.r .cell-code}\n   d.o[1:10, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Lyr_1  Lyr_2  Lyr_3  Lyr_4  Lyr_5  Lyr_6  Lyr_7  Lyr_8  Lyr_9 Lyr_10 \n     3      7      7     17      4      0      4      2      3      7 \n```\n:::\n:::\n\n\n### The Indegree and Outdegree Distributions\n\nIn the case of the degree distribution, now we have *two distributions*: An **outdegree distribution** and an **indegree distribution**. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n   i.prop <- degree_distribution(g, mode = \"in\")\n   o.prop <- degree_distribution(g, mode = \"out\")\n```\n:::\n\n\nSo the main complication is that now, just like with degree, we have to specify a value for the `mode` argument; `in` for the indegree distribution and `out` for the outdegree distribution. \n\nThat also means that when plotting, we have to create two data frames and present two plots.\n\nFirst the data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   i.d.vals <- c(0:max(d.i))\n   o.d.vals <- c(0:max(d.o))\n   i.deg.dist <- data.frame(i.d.vals, i.prop)\n   o.deg.dist <- data.frame(o.d.vals, o.prop)\n   head(i.deg.dist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  i.d.vals     i.prop\n1        0 0.01408451\n2        1 0.02816901\n3        2 0.07042254\n4        3 0.02816901\n5        4 0.08450704\n6        5 0.02816901\n```\n:::\n\n```{.r .cell-code}\n   head(o.deg.dist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  o.d.vals     o.prop\n1        0 0.01408451\n2        1 0.00000000\n3        2 0.01408451\n4        3 0.05633803\n5        4 0.04225352\n6        5 0.04225352\n```\n:::\n:::\n\n\nNow, to plotting. To be effective, the resulting plot has to show the outdegree and indegree distribution side by side so as to allow the reader to compare. To do that, we first generate each plot separately:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(ggplot2)\n   p <- ggplot(data = o.deg.dist, aes(x = o.d.vals, y = o.prop))\n   p <- p + geom_bar(stat = \"identity\", fill = \"red\", color = \"red\")\n   p <- p + theme_minimal()\n   p <- p + labs(x = \"\", y = \"Proportion\", \n                 title = \"Outdegree Distribution in Law Advice Network\") \n   p <- p + geom_vline(xintercept = mean(d.o), \n                       linetype = 2, linewidth = 0.75, color = \"blue\")\n   p1 <- p + scale_x_continuous(breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40)) + xlim(0, 40)\n\n   p <- ggplot(data = i.deg.dist, aes(x = i.d.vals, y = i.prop))\n   p <- p + geom_bar(stat = \"identity\", fill = \"red\", color = \"red\")\n   p <- p + theme_minimal()\n   p <- p + labs(x = \"\", y = \"Proportion\", \n                 title = \"Indegree Distribution in Law Advice Network\") \n   p <- p + geom_vline(xintercept = mean(d.i), \n                       linetype = 2, linewidth = 0.75, color = \"blue\")\n   p2 <- p + scale_x_continuous(breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40)) + xlim(0, 40)\n```\n:::\n\n\nThen we use the magical package `patchwork` to combine the plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   # install.packages(\"patchwork\")\n   library(patchwork)\n   p <- p1 / p2\n   p\n```\n\n::: {.cell-output-display}\n![](basic-dir_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe data clearly shows that while both distributions are skewed, the indegree distribution is more heterogeneous, with a larger proportion of nodes in the high end of *receiving* advice as compared to giving advice. \n\nNote also that since the mean degree is the same regardless of whether we use the out or indegree distribution, then the blue line pointing to the mean degree falls in the same spot on the x-axis for both plots. \n\n### The Four Different Flavors of Degree Correlations in the Directed Case\n\nThe same doubling (really quadrupling) happens to degree correlations in directed graphs. While in an undirected graph, there is a single degree correlation, in the directed case we have *four* quantities to compute: The out-out degree correlation, the in-in degree correlation, the out-in degree correlation, and the in-out degree correlation (see [here](https://barabasi.com/f/620.pdf), p. 38). \n\nTo proceed, we need to create an edge list data set with six columns: The node id of the \"from\" node, the node id of the \"to\" node, the indegree of the \"from\" node, the outdegree of the \"from\" node, the indegree of the \"to\" node, and the outdegree of the \"to\" node. \n\nWe can adapt the code we used for the [undirected case](basic.qmd) for this purpose. First, we create an edge list data frame using the `igraph` function `as_long_data_frame`, specifying that we only want the columns that have the names of the respective nodes incident to the edge:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(dplyr)\n    g.el <- as_long_data_frame(g)[, c(\"from_name\", \"to_name\")] |> \n    rename(fr = from_name, to = to_name)\n    head(g.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     fr     to\n1 Lyr_1  Lyr_2\n2 Lyr_1 Lyr_17\n3 Lyr_1 Lyr_20\n4 Lyr_2  Lyr_1\n5 Lyr_2  Lyr_6\n6 Lyr_2 Lyr_17\n```\n:::\n:::\n\n\nSecond, we create data frames containing the in and outdegrees of each node in the network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    deg.dat.fr <- data.frame(fr = V(g)$name, d.o, d.i)\n    deg.dat.to <- data.frame(to = V(g)$name, d.o, d.i)\n```\n:::\n\n\nThird, we merge this info into the edge list data frame to get the in and outdegrees of the from and to nodes in the directed edge:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.el <- g.el %>% \n      left_join(deg.dat.fr) %>% \n      rename(d.o.fr = d.o, d.i.fr = d.i) %>% \n      left_join(deg.dat.to, by = \"to\") %>% \n      rename(d.o.to = d.o, d.i.to = d.i) \n   head(d.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     fr     to d.o.fr d.i.fr d.o.to d.i.to\n1 Lyr_1  Lyr_2      3     22      7     23\n2 Lyr_1 Lyr_17      3     22     21     26\n3 Lyr_1 Lyr_20      3     22     11     22\n4 Lyr_2  Lyr_1      7     23      3     22\n5 Lyr_2  Lyr_6      7     23      0     21\n6 Lyr_2 Lyr_17      7     23     21     26\n```\n:::\n:::\n\n\nNow we can compute the four different flavors of the degree correlation for directed graphs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   round(cor(d.el$d.o.fr, d.el$d.o.to), 4) #out-out correlation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.0054\n```\n:::\n\n```{.r .cell-code}\n   round(cor(d.el$d.i.fr, d.el$d.i.to), 4) #in-in correlation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.187\n```\n:::\n\n```{.r .cell-code}\n   round(cor(d.el$d.i.fr, d.el$d.o.to), 4) #in-out correlation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.0283\n```\n:::\n\n```{.r .cell-code}\n   round(cor(d.el$d.o.fr, d.el$d.i.to), 4) #out-in correlation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.0843\n```\n:::\n:::\n\n\nThese results tell us that there is not much degree assortativity going on in the law advice network, *except* for a slight tendency of people who receive advice from lots of others to give advice to people who also receive advice from a lot of other people (the \"in-in\" correlation)\n\nNote that by default, the `assortativity_degree` function in `igraph` only returns the *out-in* correlation for directed graphs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   round(assortativity_degree(g, directed = TRUE), 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.0843\n```\n:::\n:::\n\n\nThat is, `assortativity_degree` checks if more active senders are more likely to send ties to people who are popular receivers of ties. \n\n",
    "supporting": [
      "basic-dir_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}