{
  "hash": "6fc8a6f58424c963b1ed1906cd92e2b2",
  "result": {
    "markdown": "---\ntitle: \"Extracting the Backbone of Bipartite Projections Using Graph Ensembles\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\n## The Problem with Bipartite Projections\n\nRecall from our lecture on [two-mode networks](two-mode.qmd) that a common approach to analyzing them is what @everett_borgatti13 call the \"dual projection\" approach. This involves computing the row and column object projections from the original affiliation matrix due to @breiger74. Nevertheless, one issue with this approach is that the result is a weighted network, which can be hard to analyze using our usual tools. \n\nMoreover, because just sharing a single membership (member) will create a connection between any two persons (groups) in the row (column) projection, the resulting weighted graphs are dense and usually lack meaningful or interesting structure. Thus, a common task is to try to prune and binarize bipartite projections. Zak @neal14 refers to as extracting the **backbone** of the bipartite projection. \n\nSo let's load up our trusty *Southern Women* data set and compute the bipartite projections:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(igraph)\n   library(networkdata)\n   g <- southern_women\n   Proj <- bipartite_projection(g)\n   G.p <- Proj[[1]]\n   G.g <- Proj[[2]]\n   A <- as.matrix(as_biadjacency_matrix(g))\n   P <- as.matrix(as_adjacency_matrix(G.p, attr = \"weight\"))\n   G <- as.matrix(as_adjacency_matrix(G.g, attr = \"weight\"))\n```\n:::\n\n\nRecall that $\\mathbf{A}$ is the rectangular **affiliation matrix** recording adjacency relations between persons and groups, $\\mathbf{P}$ is the weighted row projection between people, where the weight between pairs of people is the number of common memberships they share, and $\\mathbf{G}$ is the weighted column projection between groups, where the weight between pairs of groups is the number of common members they share.\n\nThe $\\mathbf{P}$ matrix looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         0     6       7      6         3       4       3     3    3\nLAURA          6     0       6      6         3       4       4     2    3\nTHERESA        7     6       0      6         4       4       4     3    4\nBRENDA         6     6       6      0         4       4       4     2    3\nCHARLOTTE      3     3       4      4         0       2       2     0    2\nFRANCES        4     4       4      4         2       0       3     2    2\nELEANOR        3     4       4      4         2       3       0     2    3\nPEARL          3     2       3      2         0       2       2     0    2\nRUTH           3     3       4      3         2       2       3     2    0\nVERNE          2     2       3      2         1       1       2     2    3\nMYRNA          2     1       2      1         0       1       1     2    2\nKATHERINE      2     1       2      1         0       1       1     2    2\nSYLVIA         2     2       3      2         1       1       2     2    3\nNORA           2     2       3      2         1       1       2     2    2\nHELEN          1     2       2      2         1       1       2     1    2\nDOROTHY        2     1       2      1         0       1       1     2    2\nOLIVIA         1     0       1      0         0       0       0     1    1\nFLORA          1     0       1      0         0       0       0     1    1\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        2     2         2      2    2     1       2      1     1\nLAURA         2     1         1      2    2     2       1      0     0\nTHERESA       3     2         2      3    3     2       2      1     1\nBRENDA        2     1         1      2    2     2       1      0     0\nCHARLOTTE     1     0         0      1    1     1       0      0     0\nFRANCES       1     1         1      1    1     1       1      0     0\nELEANOR       2     1         1      2    2     2       1      0     0\nPEARL         2     2         2      2    2     1       2      1     1\nRUTH          3     2         2      3    2     2       2      1     1\nVERNE         0     3         3      4    3     3       2      1     1\nMYRNA         3     0         4      4    3     3       2      1     1\nKATHERINE     3     4         0      6    5     3       2      1     1\nSYLVIA        4     4         6      0    6     4       2      1     1\nNORA          3     3         5      6    0     4       1      2     2\nHELEN         3     3         3      4    4     0       1      1     1\nDOROTHY       2     2         2      2    1     1       0      1     1\nOLIVIA        1     1         1      1    2     1       1      0     2\nFLORA         1     1         1      1    2     1       1      2     0\n```\n:::\n:::\n\n\nAnd the $\\mathbf{G}$ matrix looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   G\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     0   2    3    2    3    3    2    3   1    0    0   0     0   0\n3/2      2   0    3    2    3    3    2    3   2    0    0   0     0   0\n4/12     3   3    0    4    6    5    4    5   2    0    0   0     0   0\n9/26     2   2    4    0    4    3    3    3   2    0    0   0     0   0\n2/25     3   3    6    4    0    6    6    7   3    0    0   0     0   0\n5/19     3   3    5    3    6    0    5    7   4    1    1   1     1   1\n3/15     2   2    4    3    6    5    0    8   5    3    2   4     2   2\n9/16     3   3    5    3    7    7    8    0   9    4    1   5     2   2\n4/8      1   2    2    2    3    4    5    9   0    4    3   5     3   3\n6/10     0   0    0    0    0    1    3    4   4    0    2   5     3   3\n2/23     0   0    0    0    0    1    2    1   3    2    0   2     1   1\n4/7      0   0    0    0    0    1    4    5   5    5    2   0     3   3\n11/21    0   0    0    0    0    1    2    2   3    3    1   3     0   3\n8/3      0   0    0    0    0    1    2    2   3    3    1   3     3   0\n```\n:::\n:::\n\n\nNow, our job is to binarize these matrices by retaining adjacency relations between nodes whose weights is significantly larger than we would expect given a suitable null model. This is a situation perfectly tailored for graph ensembles!\n\n## The Stochastic Degree Sequence Model\n\n@neal14 proposes one such approach called the **Stochastic Degree Sequence Model** (SDSM). This approach compares the observed weights in each bipartite projection against those from a bipartite graph ensemble where the graphs in the ensemble are generated from a model that preserves the expected (average) degrees of the nodes in the two-mode network. \n\nWe proceed as follows. First, we estimate a generalized linear model for binary outcomes (e.g., logit or probit, or your favorite other), where we predict the probability of observing an edge in the bipartite graph from the degrees of each node incident to each edge (and their statistical interaction). In `R` we can do this as follows. First, we create a dataset with the affiliation matrix as a response variable and the degrees of each node as coviarates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   edges <- as.numeric(A) #vectorized affiliation matrix\n   p.degrees <- c(rep(rowSums(A), ncol(A))) #person degree vector\n   g.degrees <- c(rep(colSums(A), each = nrow(A))) #group degree vector\n   dat <- data.frame(y = edges, d1 = p.degrees, d2 = g.degrees) #data frame\n   dat[1:25, ] #first 25 rows of data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   y d1 d2\n1  1  8  3\n2  1  7  3\n3  0  8  3\n4  1  7  3\n5  0  4  3\n6  0  4  3\n7  0  4  3\n8  0  3  3\n9  0  4  3\n10 0  4  3\n11 0  4  3\n12 0  6  3\n13 0  7  3\n14 0  8  3\n15 0  5  3\n16 0  2  3\n17 0  2  3\n18 0  2  3\n19 1  8  3\n20 1  7  3\n21 1  8  3\n22 0  7  3\n23 0  4  3\n24 0  4  3\n25 0  4  3\n```\n:::\n:::\n\n\nThen we estimate a logit regression:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   mylogit <- glm(y ~ d1*d2, data = dat, family = \"binomial\")\n   summary(mylogit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = y ~ d1 * d2, family = \"binomial\", data = dat)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -5.84765    1.09104  -5.360 8.34e-08 ***\nd1           0.63010    0.17902   3.520 0.000432 ***\nd2           0.45908    0.12876   3.565 0.000363 ***\nd1:d2       -0.03279    0.02286  -1.434 0.151482    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 327.29  on 251  degrees of freedom\nResidual deviance: 254.55  on 248  degrees of freedom\nAIC: 262.55\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n:::\n\n\nThen we compute the predicted probabilities for each case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   mypreds <- predict(mylogit, type = \"response\")\n   round(mypreds[1:25], 2) #first 25 predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n0.45 0.32 0.45 0.32 0.09 0.09 0.09 0.05 0.09 0.09 0.09 0.22 0.32 0.45 0.14 0.03 \n  17   18   19   20   21   22   23   24   25 \n0.03 0.03 0.45 0.32 0.45 0.32 0.09 0.09 0.09 \n```\n:::\n:::\n\n\nNow, we use these predicted probabilities to generate an ensemble of graphs, where each edges int he graph is a Bernoulli draw from the predicted probability response vector. We can do this using the following function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   bipart.ensemble <- function(x, r, c) {\n      A <- as.numeric(x > runif(length(x)))\n      A <- matrix(A, nrow = r, ncol = c, byrow = TRUE)\n      return(A)\n      }\n```\n:::\n\n\nLet's see how this works:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   set.seed(123)\n   A1 <- bipart.ensemble(mypreds, r = nrow(A), c = ncol(A))\n   rownames(A1) <- rownames(A)\n   colnames(A1) <- colnames(A)\n   A1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\nEVELYN       1   0    1    0    0    1    0    0   0    0    0   0     0   0\nLAURA        1   0    0    0    1    0    0    0   0    0    0   0     0   0\nTHERESA      0   1    0    0    0    0    1    0   0    1    1   1     1   0\nBRENDA       0   0    1    1    0    0    1    0   1    0    0   0     0   1\nCHARLOTTE    1   0    0    0    0    0    0    0   0    0    0   0     0   0\nFRANCES      0   0    0    1    1    1    0    0   0    1    1   0     0   0\nELEANOR      1   1    0    0    0    1    1    0   1    0    1   1     0   1\nPEARL        0   0    0    1    1    0    0    0   0    0    1   1     0   1\nRUTH         1   0    0    1    0    0    0    1   1    1    1   1     0   0\nVERNE        1   1    1    1    1    0    1    1   1    1    0   1     0   1\nMYRNA        1   1    1    1    0    1    1    1   1    0    0   1     1   1\nKATHERINE    1   1    1    1    1    1    1    1   0    1    1   0     0   0\nSYLVIA       0   0    0    0    0    0    0    0   0    0    0   0     0   1\nNORA         0   1    0    0    0    0    0    0   0    0    0   0     0   0\nHELEN        0   0    1    0    1    0    0    0   0    0    0   0     1   1\nDOROTHY      1   1    1    0    1    0    1    0   0    0    0   0     0   0\nOLIVIA       1   0    0    0    0    0    0    0   0    0    1   0     1   0\nFLORA        0   0    0    0    0    0    0    0   0    0    0   0     0   0\n```\n:::\n:::\n\n\nWhich generates an affiliation matrix realization from the predicted probabilities we calculated before, with the probability of each edge being a function of the degrees of each node in the original affiliation matrix. Now all we need to do is produce a bunch of these:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   set.seed(456)\n   B <- replicate(100, bipart.ensemble(mypreds, r = nrow(A), c = ncol(A)), simplify = FALSE)\n```\n:::\n\n\nWe can then create a bunch of person projections from these matrices using `lapply`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P.list <- lapply(B, function(x) {x %*% t(x)}) #ensemble of row projections\n```\n:::\n\n\nAnd a bunch of group projections:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   G.list <- lapply(B, function(x) {t(x) %*% x}) #ensemble of column projections\n```\n:::\n\n\nNow we generate a list of binary projections where two nodes are tied when the observed projections are larger than the generated projections:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P.bin <- lapply(P.list, function(x) {(P > x) * 1})\n   G.bin <- lapply(G.list, function(x) {(G > x) * 1})\n```\n:::\n\n\nWe now add all of the matrices in each list to count the number of times the observed value is larger than the expected value. We use the trusty `R` function `Reduce` with the `\"+\"` operator to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P.exp <- Reduce(\"+\", P.bin)\n   G.exp <- Reduce(\"+\", G.bin)\n```\n:::\n\n\nThe \"p-value\" here is just one minus the cells of this matrix divided by the number of graphs in the ensemble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P.sig <- 1 - P.exp/100\n   G.sig <- 1 - G.exp/100\n   P.sig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN      1.00  0.00    0.00   0.00      0.05    0.04    0.09  0.17 0.13\nLAURA       0.00  1.00    0.00   0.00      0.00    0.00    0.00  0.36 0.16\nTHERESA     0.00  0.00    1.00   0.00      0.00    0.05    0.04  0.29 0.09\nBRENDA      0.00  0.00    0.00   1.00      0.00    0.06    0.06  0.64 0.37\nCHARLOTTE   0.05  0.00    0.00   0.00      1.00    0.20    0.38  1.00 0.46\nFRANCES     0.04  0.00    0.05   0.06      0.20    1.00    0.30  0.83 0.83\nELEANOR     0.09  0.00    0.04   0.06      0.38    0.30    1.00  0.65 0.68\nPEARL       0.17  0.36    0.29   0.64      1.00    0.83    0.65  1.00 0.84\nRUTH        0.13  0.16    0.09   0.37      0.46    0.83    0.68  0.84 1.00\nVERNE       0.75  0.61    0.64   0.92      0.89    1.00    1.00  1.00 0.98\nMYRNA       0.64  0.88    0.79   0.97      1.00    0.99    1.00  1.00 1.00\nKATHERINE   0.57  0.76    0.63   0.83      1.00    0.97    0.99  0.84 0.95\nSYLVIA      0.23  0.13    0.03   0.40      0.39    0.76    0.37  0.52 0.19\nNORA        0.18  0.02    0.06   0.15      0.67    0.72    0.47  0.48 0.51\nHELEN       0.63  0.15    0.28   0.24      0.40    0.91    0.40  0.94 0.56\nDOROTHY     0.17  0.43    0.19   0.67      1.00    0.77    0.92  0.27 0.54\nOLIVIA      0.47  1.00    0.60   1.00      1.00    1.00    1.00  0.87 0.75\nFLORA       0.21  1.00    0.48   1.00      1.00    1.00    1.00  0.43 0.73\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN     0.75  0.64      0.57   0.23 0.18  0.63    0.17   0.47  0.21\nLAURA      0.61  0.88      0.76   0.13 0.02  0.15    0.43   1.00  1.00\nTHERESA    0.64  0.79      0.63   0.03 0.06  0.28    0.19   0.60  0.48\nBRENDA     0.92  0.97      0.83   0.40 0.15  0.24    0.67   1.00  1.00\nCHARLOTTE  0.89  1.00      1.00   0.39 0.67  0.40    1.00   1.00  1.00\nFRANCES    1.00  0.99      0.97   0.76 0.72  0.91    0.77   1.00  1.00\nELEANOR    1.00  1.00      0.99   0.37 0.47  0.40    0.92   1.00  1.00\nPEARL      1.00  1.00      0.84   0.52 0.48  0.94    0.27   0.87  0.43\nRUTH       0.98  1.00      0.95   0.19 0.51  0.56    0.54   0.75  0.73\nVERNE      1.00  1.00      0.99   0.23 0.53  0.69    0.86   0.95  0.80\nMYRNA      1.00  1.00      0.86   0.14 0.43  0.51    0.76   0.90  0.67\nKATHERINE  0.99  0.86      1.00   0.01 0.01  0.34    0.75   0.81  0.62\nSYLVIA     0.23  0.14      0.01   1.00 0.00  0.00    0.17   0.51  0.30\nNORA       0.53  0.43      0.01   0.00 1.00  0.00    0.68   0.18  0.06\nHELEN      0.69  0.51      0.34   0.00 0.00  1.00    0.55   0.64  0.35\nDOROTHY    0.86  0.76      0.75   0.17 0.68  0.55    1.00   0.30  0.39\nOLIVIA     0.95  0.90      0.81   0.51 0.18  0.64    0.30   1.00  0.03\nFLORA      0.80  0.67      0.62   0.30 0.06  0.35    0.39   0.03  1.00\n```\n:::\n\n```{.r .cell-code}\n   G.sig\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27  3/2 4/12 9/26 2/25 5/19 3/15 9/16  4/8 6/10 2/23  4/7 11/21  8/3\n6/27  1.00 0.94 0.70 0.88 0.56 0.54 0.91 0.68 0.98 1.00 1.00 1.00  1.00 1.00\n3/2   0.94 1.00 0.60 0.86 0.54 0.45 0.88 0.62 0.88 1.00 1.00 1.00  1.00 1.00\n4/12  0.70 0.60 1.00 0.41 0.02 0.11 0.36 0.13 0.89 1.00 1.00 1.00  1.00 1.00\n9/26  0.88 0.86 0.41 1.00 0.50 0.74 0.56 0.60 0.88 1.00 1.00 1.00  1.00 1.00\n2/25  0.56 0.54 0.02 0.50 1.00 0.11 0.01 0.01 0.56 1.00 1.00 1.00  1.00 1.00\n5/19  0.54 0.45 0.11 0.74 0.11 1.00 0.17 0.02 0.34 0.96 1.00 0.99  0.98 0.99\n3/15  0.91 0.88 0.36 0.56 0.01 0.17 1.00 0.00 0.10 0.52 0.82 0.19  0.81 0.76\n9/16  0.68 0.62 0.13 0.60 0.01 0.02 0.00 1.00 0.00 0.28 0.99 0.05  0.90 0.72\n4/8   0.98 0.88 0.89 0.88 0.56 0.34 0.10 0.00 1.00 0.35 0.63 0.12  0.53 0.51\n6/10  1.00 1.00 1.00 1.00 1.00 0.96 0.52 0.28 0.35 1.00 0.74 0.10  0.38 0.34\n2/23  1.00 1.00 1.00 1.00 1.00 1.00 0.82 0.99 0.63 0.74 1.00 0.84  0.98 0.99\n4/7   1.00 1.00 1.00 1.00 1.00 0.99 0.19 0.05 0.12 0.10 0.84 1.00  0.61 0.51\n11/21 1.00 1.00 1.00 1.00 1.00 0.98 0.81 0.90 0.53 0.38 0.98 0.61  1.00 0.67\n8/3   1.00 1.00 1.00 1.00 1.00 0.99 0.76 0.72 0.51 0.34 0.99 0.51  0.67 1.00\n```\n:::\n:::\n\n\nWe then connect two nodes in the backbone, when this value is below some standard threshold (e.g., $p < 0.10$):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P.back <- (P.sig < 0.10) * 1\n   G.back <- (G.sig < 0.10) * 1\n   P.back\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         0     1       1      1         1       1       1     0    0\nLAURA          1     0       1      1         1       1       1     0    0\nTHERESA        1     1       0      1         1       1       1     0    1\nBRENDA         1     1       1      0         1       1       1     0    0\nCHARLOTTE      1     1       1      1         0       0       0     0    0\nFRANCES        1     1       1      1         0       0       0     0    0\nELEANOR        1     1       1      1         0       0       0     0    0\nPEARL          0     0       0      0         0       0       0     0    0\nRUTH           0     0       1      0         0       0       0     0    0\nVERNE          0     0       0      0         0       0       0     0    0\nMYRNA          0     0       0      0         0       0       0     0    0\nKATHERINE      0     0       0      0         0       0       0     0    0\nSYLVIA         0     0       1      0         0       0       0     0    0\nNORA           0     1       1      0         0       0       0     0    0\nHELEN          0     0       0      0         0       0       0     0    0\nDOROTHY        0     0       0      0         0       0       0     0    0\nOLIVIA         0     0       0      0         0       0       0     0    0\nFLORA          0     0       0      0         0       0       0     0    0\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        0     0         0      0    0     0       0      0     0\nLAURA         0     0         0      0    1     0       0      0     0\nTHERESA       0     0         0      1    1     0       0      0     0\nBRENDA        0     0         0      0    0     0       0      0     0\nCHARLOTTE     0     0         0      0    0     0       0      0     0\nFRANCES       0     0         0      0    0     0       0      0     0\nELEANOR       0     0         0      0    0     0       0      0     0\nPEARL         0     0         0      0    0     0       0      0     0\nRUTH          0     0         0      0    0     0       0      0     0\nVERNE         0     0         0      0    0     0       0      0     0\nMYRNA         0     0         0      0    0     0       0      0     0\nKATHERINE     0     0         0      1    1     0       0      0     0\nSYLVIA        0     0         1      0    1     1       0      0     0\nNORA          0     0         1      1    0     1       0      0     1\nHELEN         0     0         0      1    1     0       0      0     0\nDOROTHY       0     0         0      0    0     0       0      0     0\nOLIVIA        0     0         0      0    0     0       0      0     1\nFLORA         0     0         0      0    1     0       0      1     0\n```\n:::\n\n```{.r .cell-code}\n   G.back\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n3/2      0   0    0    0    0    0    0    0   0    0    0   0     0   0\n4/12     0   0    0    0    1    0    0    0   0    0    0   0     0   0\n9/26     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n2/25     0   0    1    0    0    0    1    1   0    0    0   0     0   0\n5/19     0   0    0    0    0    0    0    1   0    0    0   0     0   0\n3/15     0   0    0    0    1    0    0    1   1    0    0   0     0   0\n9/16     0   0    0    0    1    1    1    0   1    0    0   1     0   0\n4/8      0   0    0    0    0    0    1    1   0    0    0   0     0   0\n6/10     0   0    0    0    0    0    0    0   0    0    0   1     0   0\n2/23     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n4/7      0   0    0    0    0    0    0    1   0    1    0   0     0   0\n11/21    0   0    0    0    0    0    0    0   0    0    0   0     0   0\n8/3      0   0    0    0    0    0    0    0   0    0    0   0     0   0\n```\n:::\n:::\n\n\nAnd we can now plot the backbones:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   set.seed(123)\n   G.p <- graph_from_adjacency_matrix(P.back, mode = \"undirected\", diag = FALSE)\n   plot(G.p, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.25, edge.color = \"lightgray\")\n```\n\n::: {.cell-output-display}\n![One mode backbone of people using the SDSM.](backbone_files/figure-html/unnamed-chunk-16-1.png){width=1152}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n   set.seed(123)\n   G.g <- graph_from_adjacency_matrix(G.back, mode = \"undirected\", diag = FALSE)\n   plot(G.g, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.25, edge.color = \"lightgray\")\n```\n\n::: {.cell-output-display}\n![One mode backbone of groups using the SDSM.](backbone_files/figure-html/unnamed-chunk-17-1.png){width=1152}\n:::\n:::\n\n\nWe can put together all of the above steps into a handy dandy function called `sdsm.back` which takes the affiliation matrix $\\mathbf{A}$ as input and returns the two projection backbones as output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sdsm.back <- function(A, n = 100, p.val = 0.15, seed = 123) {\n      set.seed(seed)\n      r <- nrow(A)\n      c <- ncol(A)\n      P <- A %*% t(A) #row projection\n      G <- t(A) %*% A #column projection\n      y <- as.numeric(A) #vectorized affiliation matrix\n      d1 <- c(rep(rowSums(A), ncol(A))) #person degree vector\n      d2 <- c(rep(colSums(A), each = nrow(A))) #group degree vector\n      dat <- data.frame(y, d1, d2) #data frame\n      res <- glm(y ~ d1*d2, data = dat, family = \"binomial\")\n      pred <- predict(res, type = \"response\")\n      gen.aff <- function(w) {\n         return(matrix(as.numeric(w > runif(length(w))), \n                     nrow = r, ncol = c, byrow = TRUE))         \n      }\n      B <- replicate(n, gen.aff(pred), simplify = FALSE)\n      P.bin <- lapply(B, function(x) {(P > x %*% t(x)) * 1})\n      G.bin <- lapply(B, function(x) {(G > t(x) %*% x) * 1})\n      P.back <- ((1 - Reduce(\"+\", P.bin)/n) < p.val) * 1\n      G.back <- ((1 - Reduce(\"+\", G.bin)/n) < p.val) * 1\n   return(list(P.back = P.back, G.back = G.back))\n   }\n```\n:::\n\n\nAnd voila:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sdsm.back(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$P.back\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         1     1       1      1         1       1       0     0    0\nLAURA          1     1       1      1         1       1       1     0    1\nTHERESA        1     1       1      1         1       1       1     0    1\nBRENDA         1     1       1      1         1       1       1     0    0\nCHARLOTTE      1     1       1      1         0       0       0     0    0\nFRANCES        1     1       1      1         0       0       0     0    0\nELEANOR        0     1       1      1         0       0       0     0    0\nPEARL          0     0       0      0         0       0       0     0    0\nRUTH           0     1       1      0         0       0       0     0    0\nVERNE          0     0       0      0         0       0       0     0    0\nMYRNA          0     0       0      0         0       0       0     0    0\nKATHERINE      0     0       0      0         0       0       0     0    0\nSYLVIA         0     1       1      0         0       0       0     0    0\nNORA           0     1       1      1         0       0       0     0    0\nHELEN          0     1       0      0         0       0       0     0    0\nDOROTHY        0     0       0      0         0       0       0     0    0\nOLIVIA         0     0       0      0         0       0       0     0    0\nFLORA          0     0       0      0         0       0       0     0    0\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        0     0         0      0    0     0       0      0     0\nLAURA         0     0         0      1    1     1       0      0     0\nTHERESA       0     0         0      1    1     0       0      0     0\nBRENDA        0     0         0      0    1     0       0      0     0\nCHARLOTTE     0     0         0      0    0     0       0      0     0\nFRANCES       0     0         0      0    0     0       0      0     0\nELEANOR       0     0         0      0    0     0       0      0     0\nPEARL         0     0         0      0    0     0       0      0     0\nRUTH          0     0         0      0    0     0       0      0     0\nVERNE         0     0         0      0    0     0       0      0     0\nMYRNA         0     0         0      0    0     0       0      0     0\nKATHERINE     0     0         0      1    1     0       0      0     0\nSYLVIA        0     0         1      1    1     1       1      0     0\nNORA          0     0         1      1    1     1       0      1     1\nHELEN         0     0         0      1    1     0       0      0     0\nDOROTHY       0     0         0      1    0     0       0      0     0\nOLIVIA        0     0         0      0    1     0       0      0     1\nFLORA         0     0         0      0    1     0       0      1     0\n\n$G.back\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n3/2      0   0    0    0    0    0    0    0   0    0    0   0     0   0\n4/12     0   0    0    0    1    0    0    0   0    0    0   0     0   0\n9/26     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n2/25     0   0    1    0    0    1    1    1   0    0    0   0     0   0\n5/19     0   0    0    0    1    0    0    1   0    0    0   0     0   0\n3/15     0   0    0    0    1    0    1    1   1    0    0   0     0   0\n9/16     0   0    0    0    1    1    1    1   1    0    0   1     0   0\n4/8      0   0    0    0    0    0    1    1   1    0    0   1     0   0\n6/10     0   0    0    0    0    0    0    0   0    0    0   1     0   0\n2/23     0   0    0    0    0    0    0    0   0    0    0   0     0   0\n4/7      0   0    0    0    0    0    0    1   1    1    0   0     0   0\n11/21    0   0    0    0    0    0    0    0   0    0    0   0     0   0\n8/3      0   0    0    0    0    0    0    0   0    0    0   0     0   0\n```\n:::\n:::\n",
    "supporting": [
      "backbone_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}