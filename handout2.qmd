---
title: "Centrality"
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  message: false
format: 
   html:
      code-line-numbers: true
---

In this handout we will go through the basic centrality metrics. We beginn with the "big three" according to @freeman79, namely, **degree**, **closeness** (in two flavors) and **betweenness**. 

We first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:

```{r}
   library(networkdata)
   library(igraph)
   g <- movie_559
```

## Degree Cenntrality

Degree centrality is the simplest and most straightforward measure. In fact, we are already computed in [handout 1](https://olizardo.github.io/SOCIOL208/handout1.html) since it is the same as obtaining the graph's **degree sequence**. So the `igraph` function `degree` would do it as we already saw. 

Here we follow a different approach using the row (or column) sums of the graph's **adjacency matrix**:

```{r}
   A <- as_adjacency_matrix(g)
   A <- as.matrix(A)
   rowSums(A)
```

The `igraph` function `as_adjancency_matrix` doesn't quite return a regular `R` matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the `as.matrix` function in line 2. Then we can apply the native `rowSums` function to obtain each node's degree. Note that this is same output we got using the `degree` function before. 

## Indegree and Outdegree

The movie network is based on the relationship of co-appearance in a scene which by nature lacks any natural directionality (it's a symmetric relation) and can therefore be represented in an **undirected graph**. The concepts of in and outdegree, by contrast, are only applicable to directed relations. So to illustrate them, we need to switch to a different source of data.

We pick an **advice network** which is a classical directed kind of (asymmetric) relation. I can give advice to you, but that doesn't necessarily mean you can givigraphen advice to me. The `networkdata` package contains one such data set collected in the late 80s early 1990s in a New England law firm (see the description [here](https://rdrr.io/github/schochastics/networkdata/man/law_advice.html)), called `law_advice`:

```{r}
   d.g <- law_advice
   V(d.g)
   vertex_attr(d.g)
```

We can see that the graph has 71 vertices, and that there are various **attributes** associated with each vertex, like gender, age, seniority, status in the law firm, etc. We can query those attributes using the `igraph` function `vertex_attr`, which takes the graph object as input. 

### Subsetting the Graph According to a Node Attribute

To keep things manageable, we will restrict our analysis to partners. To do that we need to select the **subgraph** that only includes the vertices with value of 1 in the "status" vertex attribute. From the [data description](https://rdrr.io/github/schochastics/networkdata/man/law_advice.html), we know the first 36 nodes (with value of 1 in the status attribute) are the law firm's partners (the rest are associates). In `igraph` we can do this as using the `subgraph` function:

```{r}
   d.g <- subgraph(d.g, 1:36)
   V(d.g)
   V(d.g)$status
```

The first line just tells `igraph` to generate the subgraph containing the first 36 nodes (the partners). The `subgraph` function thus takes two main inputs: The graph object, and then a vector of node ids (or node labels) telling the function which nodes to select to create the **node-induced subgraph**.

Of course we already knew from the data description that the first 36 nodes where the partners. But let's say we have a large data set and we don't know *which* nodes are the partners. A smarter way of selecting a subgraph based on a node attribute is as follows:

```{r}
   partners <- which(V(law_advice)$status == 1)
   d.g <- subgraph(law_advice, partners)
   V(d.g)
```

The first line using the native `R` vector function `which` allowing us to subset a vector based on a logical condition. The function takes a vector followed by a logical condition as input, and returns the *position* of the vector elements that meet that condition. In this case, we took the vector of values for the attribute of status and selected the node ids where status is equal to 1. We then fed that vector to the `subgraph` function in line 2. 

We could do this with any other attribute:

```{r}
   older <- which(V(law_advice)$age > 50)
   older
   og <- subgraph(law_advice, older)
   V(og)
```

Here we selected the subgraph (called "og", get it, get it) formed by the subset of nodes over the age of 50 at the firm. The values of the vector older tell us which of the 71 members meet the relevant condition. 

### Computing in and outdegree

OK, going back to the partners subgraph, we can now create our (asymmetric) adjacency matrix and compute the row and column sums:


```{r}
   d.A <- as_adjacency_matrix(d.g)
   d.A <- as.matrix(d.A)
   rowSums(d.A)
   colSums(d.A)
```

Note that in contrast to the undirected case the row and column sums give you two different sets of numbers. The row sums provide the directed graph's **outdegree set** (number of *outgoing* links incident to each node), and the column sums provide the graph's **indegree set** (number of *incoming* links incident to each node). So if you are high in the first vector, you are an *advice giver* (perhaps indicating informal status or experience) and if you are high in the second you are advice taker.

Of course `igraph` has a dedicated function for this, which is just our old friend `degree` with an extra option `mode`, indicating whether you want the in or outdegrees:

```{r}
   d.o <- degree(d.g, mode = "out")
   d.i <- degree(d.g, mode = "in")
   d.o
   d.i
```

Note that the graph attributes are just vectors of values, and can be accessed from the graph object using the $ operator attached to the `V()` function as we did above. 

So if we wanted to figure our the correlation between some vertex attribute and in or out degree centrality, all we need to do is correlate the two vectors:

```{r}
   r <- cor(d.o, V(d.g)$age)
   round(r, 2)
```

Which tells us that at least in this case, younger partners are more sought after as sources of advice than older partners. 

## Closeness Centrality

Recall that the **closeness centrality** is defined as the inverse of the sum of shortest paths from each node to every other node. That means that to compute it, we first need to calculate the shortest path matrix. Then, we sum the rows (or columns) and then we obtain the inverse to get the closeness of each node:


```{r}
   S <- distances(g)
   d.sum <- rowSums(S)
   close1 <- round(1/d.sum, 4)
   close1
```

Of course, we could have just used the available function in igraph and computed the closeness centrality directly from the graph object using the function `closeness`:

```{r}
   close2 <- round(closeness(g), 4)
   close2
```

Once we have the closeness centrality values, we are interested in who are the top nodes. The following code creates a table with the top five:

```{r}
   library(kableExtra)
   close2 <- sort(close2, decreasing = TRUE)
   close2 <- data.frame(close2[1:5])
   kbl(close2, format = "pipe", align = c("l", "c"),
       col.names = c("Character", "Closeness"),
       caption = "Top Five Closeness Characters in Pulp Fiction Network.") %>% 
   kable_styling(bootstrap_options = c("hover", "condensed", "responsive"))
```

It makes sense that the three main characters are also the ones that are at closest distances from everyone else!

What about closeness centrality for a directed network? Let us see how this works using a **subgraph** of the advice network, this time selecting just women under the age of forty:

```{r}
   women <- which(V(law_advice)$gender == 2)
   wg <- subgraph(law_advice, women)
   young <- which(V(wg)$age < 40)
   wg <- subgraph(wg, young)
   V(wg)
```

This network is small enough that a plot could be informative about its structure. Let us plot it using the package `ggraph`, a visualization package that follows the same principles as the `ggplot` grammar of graphics but for network graphs (see [here](https://exts.ggplot2.tidyverse.org/ggraph.html)).

```{r}
#| fig-cap: "Women's advice network"
#| fig-cap-location: margin
   #install.packages("ggraph")
   library(ggraph)
    p <- ggraph(wg, layout = 'auto')
    p <- p + geom_edge_parallel(color = "steelblue", edge_width = 0.5,
                                arrow = arrow(length = unit(2.5, 'mm')),
                                end_cap = circle(4, 'mm'), 
                                sep = unit(3, 'mm'))
    p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = "tan2") 
    p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = "white")
    p <- p + theme_graph() 
    p
```

Now a question we might ask is who has the greatest closeness centrality in this advice network. We could proceed as usual and compute the geodesic distances between actors:

```{r}
   S <- distances(wg)
   S
```

Note that this is not quite right. In `igraph` the default settings of the distance function treats the graph as undirected. So it doesn't use the strict **directed paths**, but it just treats them all as **semi-paths** ignoring direction. That is why, for instance, it counts node 1 as being "adjacent" to node 4 even though there is only one incoming link from 4 to 1 and why the whole matrix is symmetric, when we know from just eyeballing the network that there is a lot of asymmetry in terms of who can reach who via directed paths. 

To get the actual directed distance matrix, we need to specify the "mode" option, asking whether we want in or out paths. Here, let's select outpaths:

```{r}
   S <- distances(wg, mode = "out")
   S
```

This is better but introduces a problem. The directed graph is not strongly connected, so it means that some nodes cannot reach other ones via a directed path of *any* length. That means that the **geodesic distances** from a node to an unreachable node is coded as "infinite" (Inf). The problem with infinity is that it gets in the way of calculatinng sums of distances, a requirement for the closeness centrality. 

```{r}
   S <- distances(wg, mode = "out")
   rowSums(S)
```

Adding infinity to a number just returns infinity so all the rows with at least one "Inf" in the distance matrix get an Inf for the row sum. In this case that's all of them. A bummer.

But dont' worry there's a [patch](https://olizardo.github.io/networks-textbook/lesson-sna-closeness.html#houston-we-have-a-problem). It is called the **harmonic centrality**, a kind of closeness centrality that works whether you are working with connected or disconnected graphs, and therefore regardless of whether the geodesic distance matrix contains Infs. The main difference is that instead of calculating the inverse of the sum of the distances for each node, we calculate the *sum of the inverses*:


```{r}
   S <- distances(wg, mode = "out")
   S = round(1/S, 2)
   diag(S) <- 0
   S
```

Note that in this matrix of inverse distances, the closest (adjacent) nodes get the maximum score of one, and nodes farther apart when smaller scores (approaching zero). Unreachable directed pairs of nodes get the lowest score, corresponding to $1/infnty = 0$. Note that the reachability relation is asymmetric: So node 4 and reach one (there is a directed tie from 4 to 1), but node 1 cannot reach 4.

Once we have this matrix, then we can compute the harmonic centrality the same way as regular closeness:

```{r}
   d.harm <- rowSums(S)
   d.harm
```

We can see that the highest harmonic closeness centrality node is 5, followed by 12. Here's a plot of the network highlighting the highest centrality node. 

```{r}
#| fig-cap: "Women's advice network with highest closeness centrality node in red"
#| fig-cap-location: margin
   col <- rep("tan2", vcount(wg)) #creating node color vector
   col[which(d.clos == max(d.clos))] <- "red"
   p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = col)
   p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = "white")
   p
```

