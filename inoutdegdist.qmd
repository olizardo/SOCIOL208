---
title: "Graph Degree Metrics in Directed Networks"
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  message: false
format: 
   html:
      code-line-numbers: true
---

As we saw in the [Basic Network Statistics Handout](https://olizardo.github.io/SOCIOL208/handout1.html), the degree distribution and the degree correlation are two basic things we want to have a sense of when characterizing a network, and we showed examples for the undirected graph case. 

As we also saw on the Centrality handout, the number of things you have to compute in terms of degrees "doubles" in the directed graph case; for instance, instead of a single degree set and sequence, now we have two: An out and an indegree set and sequence. 

The same thing applies to the degree distribution and the degree correlation.

## In and Out Degree Distributions

In the case of the degree distribution, now we have *two distributions* an **outdegree distribution** and an **indegree distribution**. 

Let's see an example using the `law_advice` data. 

```{r}
   library(networkdata)
   library(igraph)
   g <- law_advice
   i.prop <- degree_distribution(g, mode = "in")
   o.prop <- degree_distribution(g, mode = "out")
```

So the main complication is that now we have to specify a value for the "mode" argument; "in" for indegree and "out" for outdegree. 

That also means that when plotting, we have to create two data frames and present two plots.

First the data frames:

```{r}
   i.d <- degree(g, mode = "in")
   o.d <- degree(g, mode = "out")
   i.d.vals <- c(0:max(i.d))
   o.d.vals <- c(0:max(o.d))
   i.deg.dist <- data.frame(i.d.vals, i.prop)
   o.deg.dist <- data.frame(o.d.vals, o.prop)
   head(i.deg.dist)
   head(o.deg.dist)
```

Now, to plotting. To be effective, the resulting plot has to show the outdegree and indegree distribution side by side so as to allow the reader to compare. To do that, we first generate each plot separately:

```{r}
   library(ggplot2)
   p <- ggplot(data = o.deg.dist, aes(x = o.d.vals, y = o.prop))
   p <- p + geom_bar(stat = "identity", fill = "red", color = "red")
   p <- p + theme_minimal()
   p <- p + labs(x = "", y = "Proportion", 
                 title = "Outdegree Distribution in Law Advice Network") 
   p <- p + geom_vline(xintercept = mean(o.d), 
                       linetype = 2, linewidth = 0.75, color = "blue")
   p1 <- p + scale_x_continuous(breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40)) + xlim(0, 40)

   p <- ggplot(data = i.deg.dist, aes(x = i.d.vals, y = i.prop))
   p <- p + geom_bar(stat = "identity", fill = "red", color = "red")
   p <- p + theme_minimal()
   p <- p + labs(x = "", y = "Proportion", 
                 title = "Indegree Distribution in Law Advice Network") 
   p <- p + geom_vline(xintercept = mean(i.d), 
                       linetype = 2, linewidth = 0.75, color = "blue")
   p2 <- p + scale_x_continuous(breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40)) + xlim(0, 40)
```

Then we use the magical package `patchwork` to combine the plots:

```{r}
   # install.packages("patchwork")
   library(patchwork)
   p <- p1 / p2
   p
```

The data clearly shows that while both distributions are skewed, the indegree distribution is more heterogeneous with a larger proportion of nodes in the high end of *receiving* advice, as compared to giving advice. 

## In and Out Degree Correlations

The same doubling (really tripling) happens to degree correlations in directed graphs. While in an undirected graph, there is a single degree correlation, in the directed case we have three quantities to compute: The out-out degree correlation, the in-in degree correlation, and the in-out degree correlation. 

To proceed, need to create an edge list data set with six columns: The node id of the first node, the node id of the second, the indegree of the first node, the outdegree of the first node, the indegree of the second node, and the outdegree of the second node. 

We can adapt the code we used for the directed case for this purpose. First, we create and edge list:

```{r}
   library(dplyr)
   g.el <- as_edgelist(g) #transforming graph to edgelist
   head(g.el)
```

Second, we create data frames containing the in and outdegrees of each node:

```{r}
    i.deg.dat <- data.frame(name1 = 1:vcount(g), 
                            name2 = 1:vcount(g),
                            i.d)
    o.deg.dat <- data.frame(name1 = 1:vcount(g), 
                            name2 = 1:vcount(g),
                            o.d)
```

Third, we merge this info into the edge list:

```{r}
   el.temp <- data.frame(name2 = g.el[, 2]) %>% 
      left_join(o.deg.dat, by = "name2") %>% 
      left_join(i.deg.dat, by = "name2") %>% 
      dplyr::select(c("name2", "i.d", "o.d")) %>% 
      rename(i.d2 = i.d, o.d2 = o.d) 
   d.el <- data.frame(name1 = g.el[, 1]) %>% 
      left_join(o.deg.dat, by = "name1") %>% 
      left_join(i.deg.dat, by = "name1") %>%
      dplyr::select(c("name1", "i.d", "o.d")) %>% 
      rename(i.d1 = i.d, o.d1 = o.d) %>% 
      cbind(el.temp)
   head(d.el)
```

Now we can compute the three different flavors of the degree correlation for directed graphs:

```{r}
   round(cor(d.el$o.d1, d.el$o.d2), 2)
   round(cor(d.el$i.d1, d.el$i.d2), 2)
   round(cor(d.el$i.d1, d.el$o.d2), 2)
```


