{
  "hash": "bab6a89ba320587e61e4ded6d618c4fc",
  "result": {
    "markdown": "---\ntitle: \"Edge Centralities\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\n## Edge Degree\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(networkdata)\n    library(igraph)\n    library(stringr) #using stringr to change names from all caps to title case\n    g <- movie_559\n    V(g)$name <- str_to_title(V(g)$name)\n    V(g)$name[which(V(g)$name == \"Esmarelda\")] <- \"Esmeralda\" #fixing misspelled name\n    E(g)$weight <- 1 #setting edge weights to 1.0\n```\n:::\n\n\n## Edge Closeness\n\n@brohl_lehnertz22 define the closeness of an edge as a function of the closeness of the two nodes incident to it. An edge $e_{jk}$ linking vertex $v_j$ to $v_k$ has high closeness whenever vertices $v_j$ and $v_k$ also have high closeness. m\n\nMore specifically, the closeness centrality of an edge is proportional to the ratio of the product of the closeness of the two nodes incident to it divided by their sum:\n\n$$\nC(e_{jk}) = (E - 1)\\frac{C(v_j) \\times C(v_k)}{C(v_j)+C(v_k)}\n$$ {#eq-eclos}\n\nNote that the equation normalizes the ratio of the product to the sum of the vertex closeness centralities by the number of edges minus one.  \n\nTo compute edge closeness in a real network, we can use the same approach to data wrangling we used to [compute the degree correlation](basic.qmd). The goal is to create an edge list data frame containing five columns. The ids of the two nodes in the edge, the closeness centralities of the two nodes in the edge, and the closeness centrality of the edge calculated according to the above equation.\n\nIn the *Pulp Fiction* network this looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(dplyr)\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   c <- round(closeness(g), 3)  #closeness centrality vector\n   c.dat <- data.frame(name1 = names(c), name2 = names(c), c)\n   el.temp <- data.frame(name2 = g.el[, 2]) %>% \n      left_join(c.dat, by = \"name2\") %>% \n      dplyr::select(c(\"name2\", \"c\")) %>% \n      rename(c2 = c) \n   c.el <- data.frame(name1 = g.el[, 1]) %>% \n      left_join(c.dat, by = \"name1\") %>% \n      dplyr::select(c(\"name1\", \"c\")) %>% \n      rename(c1 = c) %>% \n      cbind(el.temp) %>% \n      mutate(e.clos = round((ecount(g)-1)*(c1*c2)/(c+c2), 3))\nhead(c.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name1    c1     name2    c2 e.clos\n1 Brett 0.014 Marsellus 0.014  0.707\n2 Brett 0.014    Marvin 0.014  0.792\n3 Brett 0.014     Roger 0.014  0.639\n4 Brett 0.014   Vincent 0.019  0.840\n5 Buddy 0.011       Mia 0.014  0.622\n6 Buddy 0.011   Vincent 0.019  0.660\n```\n:::\n:::\n\n\nTo create a table of the top five closeness centrality edges, we just order the data frame by the last column and table it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(kableExtra)\n   c.el <- c.el[order(c.el$e.clos, decreasing = TRUE), ] %>% \n      dplyr::select(c(\"name1\", \"name2\", \"e.clos\"))\n\n   kbl(c.el[1:5, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Clos.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Closeness in the Pulp Fiction Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Edges Sorted by Closeness in the Pulp Fiction Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> i </th>\n   <th style=\"text-align:left;\"> j </th>\n   <th style=\"text-align:center;\"> Edge Clos. </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Butch </td>\n   <td style=\"text-align:left;\"> Vincent </td>\n   <td style=\"text-align:center;\"> 1.165 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Jules </td>\n   <td style=\"text-align:left;\"> Marvin </td>\n   <td style=\"text-align:center;\"> 1.028 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Jules </td>\n   <td style=\"text-align:left;\"> Vincent </td>\n   <td style=\"text-align:center;\"> 1.023 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Butch </td>\n   <td style=\"text-align:left;\"> Mia </td>\n   <td style=\"text-align:center;\"> 1.002 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Jules </td>\n   <td style=\"text-align:left;\"> Patron </td>\n   <td style=\"text-align:center;\"> 1.000 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nInterestingly, the top closeness edges tend to bring somewhat strange bedfellows together, characters that themselves don't spend much time together in the film (e.g., the Butch/Vincent interaction is relatively brief and somewhat embarrassing for Vincent) but who themselves can reach other character clusters in the film via relatively short paths.\n\n## Edge Betweenness\n\nEdge betweenness is defined in similar fashion as node betweenness:\n\n$$\n\\sum_{i \\neq j} \\frac{\\sigma_{i(e)j}}{\\sigma_{ij}}\n$$\n\nWhere $\\sigma_{i(e)j}$ is a count of the number of shortest paths between *i* and *j* that feature edge *e* as an intermediary link. This tells us that the betweenness of an edge *e* is the sum of the ratios of the number of times that edge appears in the middle of a shortest path connecting every pair of nodes in the graph *i* and *j* divided by the total number of shortest paths linking each pair of nodes. \n\nLike before, the edge betweenness with respect to a specific pair of nodes in the graph is a probability: Namely, that if you send something--using a shortest path--from any node *i* to any other node *j* it has to go through edge *e*. The resulting edge betweenness scores is the sum of these probabilities across every possible pair of nodes for each edge in the graph. \n\nFor this example, we will work with a simplified version of the women lawyers advice network, in which we transform it into an **undirected** graph. We use the `igraph` function `as.undirected` for that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    g <- law_advice\n    women <- which(V(g)$gender == 2) #selecting women\n    wg <- subgraph(g, women)\n    young <- which(V(wg)$age < 40) #selecting women under forty\n    wg <- subgraph(wg, young)\n    V(wg)$name <- 1:vcount(wg) #naming nodes\n    wg <- as.undirected(wg, mode = \"collapse\")\n```\n:::\n\n\nThe \"collapse\" value in the \"mode\" argument tells `as.undirected` to link every connected dyad in the original directed graph using an undirected edge. It does that by removing the directional arrow of the single directed links and collapsing (hence the name) all the bi-directional links into a single undirected one.  \n\nThe resulting undirected graph looks like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](edgecent_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nLooking at this point and line plot of the women lawyers advice network, which edge do you think has the top betweenness? \n\nWell no need to figure that out via eyeballing! We can just use the `igraph` function `edge_betweenness`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   w.ebet <- edge_betweenness(wg)\n```\n:::\n\n\nThe `edge_betweenness` function takes the `igraph` graph object as input and produces a vector of edge betweenness values of the same length as the number of edges in the graph, which happens to be 20 in this case.\n\nUsing this information, we can then create a table of the top ten edges ordered by betweenness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   edges <- as_edgelist(wg) #creating an edgelist\n   etab <- data.frame(edges, bet = round(w.ebet, 2)) #adding bet. scores to edgelist\n   etab <- etab[order(etab$bet, decreasing = TRUE), ] #ordering by bet.\n   kbl(etab[1:10, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Bet.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Betweenness in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Edges Sorted by Betweenness in the Women Lawyers Advice Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> i </th>\n   <th style=\"text-align:left;\"> j </th>\n   <th style=\"text-align:center;\"> Edge Bet. </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 19.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:center;\"> 15.83 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:center;\"> 13.67 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 7 </td>\n   <td style=\"text-align:center;\"> 11.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 9.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 11 </td>\n   <td style=\"text-align:center;\"> 8.33 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 6 </td>\n   <td style=\"text-align:center;\"> 8.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 7.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:center;\"> 6.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:left;\"> 9 </td>\n   <td style=\"text-align:center;\"> 6.33 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nNot surprisingly, the top edges are the ones linking nodes 3 and 4 and nodes 5 and 8. \n\n### Disconnecting a Graph Via Bridge Removal\n\nHigh betweenness edges are likely to function as **bridges** being the only point of indirect connectivity between most nodes in the social structure. That means that an easy way to disconnect a connected graph is to remove the bridges [@girvan_newman02].\n\nIn `igraph` we can produce an **edge deleted subgraph** of an original graph using the \"minus\" operator, along with the `edge` function like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   del.g <- wg - edge(\"3|4\")\n   del.g <- del.g - edge(\"5|8\")\n```\n:::\n\n\nThe first line creates a new graph object (a subgraph) which equals the original graph minus the edge linking nodes 3 and 4. The second line takes this last subgraph and further deletes the edge linking nodes 5 and 8. \n\nThe resulting subgraph, minus the top two high-betweenness edges, looks like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](edgecent_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWhich is indeed disconnected!",
    "supporting": [
      "edgecent_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}