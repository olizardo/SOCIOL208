---
title: "Prestige in Multilayer Networks"
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  message: false
format: 
   html:
      code-line-numbers: true
---

It is possible to extend the prestige and status we considered in earlier lessons (e.g., Bonacich Eigenvector, PageRank, HITS and others) to the case of **multilayer networks**.^[Multilayer networks include **multiplex networks**, where multiple relations (e.g., friendship, advice, co-working) are measured over the same group of actors at one point in time, or **temporal networks** (which each relation being one of the layers), where the same relation (e.g., friendship) is measured over the same group of actors at multiple temporally ordered "snapshots" (which serve as the layers).]

## A "Supermatrix" Approach

How would this work? Here we follow the approach outlined by @taylor_etal21. The basic idea is to create a "supermatrix" that simultaneously encodes the pairwise relations of each node in each layer and the dependency relations between the same nodes across layers (e.g., in a temporal network the same nodes are only connected in immediately adjacent layers; in multiplex networks they are connected across all layers). 

The "supermatrix" $\mathbf{S}$ is defined as follows:

$$
\mathbf{S} = \mathbf{C} + \alpha(\tilde{\mathbf{A}} \otimes \mathbf{I})
$${#eq-super}

Where $\mathbf{C}$ is a **block-diagonal matrix** of dimensions $NL \times NL$ ($N$ being the number of nodes and $L$ being the number of layers) with each block in the diagonal containing the relevant $N \times N$ centrality matrix for the $l^{th}$ layer, and $\tilde{\mathbf{A}}$ is an $L \times L$ matrix containing the dependencies between each layer, $\mathbf{I}$ is the $N \times N$ **identity matrix** (containing ones along the diagonals and zero in every other cell); finally, $\alpha$ is a tunable parameter ($0 \geq \alpha \leq \infty$) specifying how much the interlayer dependencies matter in determining the prestige scores, the higher the parameter the more "strongly coupled" the layers are (e.g., scores in one layer affecting scores in the others). 

The $\otimes$ symbol in @eq-super refers to the **kroenbercker product** between the $\tilde{\mathbf{A}}$ and  $\mathbf{I}$ (e.g., the supermatrix in which each block is composed of $\mathbf{I}$ matrix multiplied by the value each cell of $\tilde{\mathbf{A}}$).^[[https://en.wikipedia.org/wiki/Kronecker_product](https://en.wikipedia.org/wiki/Kronecker_product)]

## Krackhardt Managers Multilayer Network Example

Let's see how this would work in real data. We first load the Krackchardt Manager's data from the `networkdata` package. Recall that this data records three types of ties between 21 high-tech managers: Friendship, Advice, and who reports to whom. We store each in a `list` object and transform each graph into an adjacency matrix using `lapply`:

```{r}
   library(networkdata)
   library(igraph)
   layers <- list(ht_friends, ht_advice, ht_reports)
   layers <- lapply(layers, function(x) {t(as.matrix(as_adjacency_matrix(x)))})
```

We then create the block diagonal matrix $\mathbf{C}$, using the function `bdiag` from the package `Matrix`

```{r}
    # install.packages("Matrix")
    library(Matrix)
    C <- as.matrix(bdiag(layers))
```

Note that by using the transpose of the original adjacency matrices to create the diagonal blocks of the $\mathbf{C}$ matrix, we are specifying that we want to compute the multilayer Eigenvector centrality.^[To compute the other prestige scores (e.g., PageRank or HITS) we would feed different matrices here (e.g., the row-normalized adjacency matrix or the common-neighbors matrix).]

We now need to create the interlayer dependency matrix $\tilde{\mathbf{A}}$. We use the simplest assumption, which is that all the layers mutually depend on one another equally, which means that $\tilde{\mathbf{A}}$ is the all ones matrix with diagonals set to zero:

```{r}
    A <- matrix(1, 3, 3)
    diag(A) <- 0
    rownames(A) <- c("f", "a", "r")
    colnames(A) <- c("f", "a", "r")
    A
```

Finally, we create $\mathbf{I}$:

```{r}
    n <- nrow(layers[[1]])
    I <- diag(1, n, n)
```

We are now ready to create the $\mathbf{S}$ matrix with $\alpha = 1.5$, using the base `R` function `kronecker` to compute the kronecker product between $\tilde{\mathbf{A}}$ and $\mathbf{I}$:

```{r}
    S <- C + (1.5 * kronecker(A, I))
```

And now, all we need to do is run our old status distribution game on the $\mathbf{S}$ matrix!

```{r}
   status1 <- function(w) {
      x <- rep(1, nrow(w)) #initial status vector set to all ones of length equal to the number of nodes
      d <- 1 #initial delta
      while (d > 1e-10) {
            o.x <- x #old status scores
            x <- w %*% o.x #new scores a function of old scores and adjacency matrix
            x <- x/norm(x, type = "E") #normalizing new status scores
            d <- abs(sum(abs(x) - abs(o.x))) #delta between new and old scores
         }  #end while loop
      return(as.vector(x))
      }
    ml.eig <- status1(S)
```

The result will be a vector of length $N \times L$ (in our case, $21 \times 3 = 63$) containing the prestige scores for each network layer. 

We can arrange the long vector into an $N \times L$ rectangular martrix $\mathbf{W}$ containing the *joint* status scores of each node at each layer:

```{r}
    W <- matrix(ml.eig, 21, 3)
    rownames(W) <- 1:21
    colnames(W) <- c("f", "a", "r")
    round(W, 3)
```

Each column of the matrix is a network layer (friendship, advice, and reports to) and each row is an individual. The entries in the matrix is the (unnormalized) status score of individual $i$ on layer $l$. 

The *marginal status* of each node is given by the sum of their scores across all layers:

```{r}
    ml.node <- rowSums(W)
    round(ml.node/max(ml.node), 3)
```

We can see that indeed, Manager 2 is the most central nodes across all three layers, followed by Manager 21. 

We can also do the same thing to figure out which *layer* is the most important, but this time we sum the columns and normalize:

```{r}
    ml.layer <- colSums(W)
    round(ml.layer/max(ml.layer), 3)
```

Which tell us that the advice layer is definitely the most important, and the "reports to" layer the least important in determining status across layers. 

The *conditional* status of each node in each layer can be obtained as follows:

```{r}
    cond.node <- t(t(W)/ml.layer)
    round(cond.node, 3)
```

Reinforcing the previous results showing node 2 to be the most important in all three layers. 

We can also calculate the node-specific importance of each layer:

```{r}
    cond.layer <- W/ml.node
    round(cond.layer, 3)
```

Which gives us the relative importance of each *layer* in determining each node's status. For instance, the friendship layer is pretty important for Manager 9, but relatively unimportant for manager 6. The reports to layer is relative unimportant for most managers, but it's definitely most important for manager 7. 

## Changing Interlayer Dependency Assumptions

As we noted before, the $\tilde{\mathbf{A}}$ matrix contains our hypotheses about interlayer dependencies. Suppose we have a theory that says that the advice layer does not affect the orders to layer. To encode this hypothesis into the status calculation we create a new $\mathbf{A}$ matrix:

```{r}
    A <- matrix(1, 3, 3)
    diag(A) <- 0
    rownames(A) <- c("f", "a", "r")
    colnames(A) <- c("f", "a", "r")
    A["a", "r"] <- 0
    A["f", "r"] <- 0
    A["r", "f"] <- 0
    A["a", "f"] <- 0
```

We now create a new $\mathbf{S}$ matrix and compute the status scores:

```{r}
    S <- C + (1.5 * kronecker(A, I))
    ml.eig <- status1(S)
    W <- matrix(ml.eig, 21, 3)
    rownames(W) <- 1:21
    colnames(W) <- c("f", "a", "r")
    ml.node <- rowSums(W)
    ml.layer <- colSums(W)
    cond.node <- t(t(W)/ml.layer)
    round(cond.node, 3)
```

Note that this new set of assumptions about interlayer dependencies change our results. Node 17 is now the highest status node in the friendship and reports to layers, while node remains the highest status node but only in the advice layer. 