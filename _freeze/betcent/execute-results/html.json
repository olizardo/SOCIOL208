{
  "hash": "ff63e819a4db2db8c77298f019feb79e",
  "result": {
    "markdown": "---\ntitle: \"Betwenness Centrality\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nRecall that, according to @freeman79, the key conceptual distinction between [closeness](closcent.qmd) and betweenness is between (pun intended) the capacity to reach others quickly (e.g., via the shortest paths) and the capacity to *intermediate* among those same paths. High betweenness nodes control the flow of information in the network between other nodes that flows via shortest.\n\nLet us begin by defining some basic concepts on which betweenness centrality measures are built.\n\n### Pairwise Dependency and Betweenness\n\nWe can define the **pair dependency** $\\delta_{i(k)j}$ [@brandes01, p. 166] of any two nodes in the graph $\\{i, j\\}$ on any third node $k$ as follows:\n\n$$\n\\delta_{i(k)j}= \\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n$$ {#eq-pair}\n\nWhere the denominator of the fraction ($\\sigma_{ij}$) is a count of the *total* number of shortest paths that start and end with nodes $i$ and $j$ and the numerator of the fraction ($\\sigma_{i(k)j}$) is the subset of those paths that include node $k$ as an **inner node**.^[As @brandes08 [p. 137] notes, when $i = j$, then $\\sigma_{ij} = 1$ and when $k \\in \\{i, j\\}$, then $\\sigma_{i(k)j} = 0$.]\n\nBecause @eq-pair is a ratio it can range from zero to one  with everything in between. As such the pair dependency of a pair of nodes relative to a third has an intuitive interpretation as a *probability*, namely the probability that if you send something starting from $i$ in order for it to get to $j$ it has to go *through* $k$. This probability is 1.0 if $k$ stands in *every* shortest path between $i$ and $j$ and zero if $k$ does not lie in *any* of the shortest paths linking $i$ and $j$.\n\nWe can also defined the **one-sided dependency** of any one node $i$ on any other node $k$ in the graph as the sum of the pairwise dependencies on $k$ that involve $i$ across every other node $j$:\n$$\n\\delta_{i|k} = \\sum_j \\delta_{i(k)j}\n$$ {#eq-one}\n\nThe **betweenness centrality** of a node $k$ is then defined as the *sum of the dependencies* that *every pair* of nodes in the graph has on that node:\n\n$$\nC^{BET}_k = \\sum_{i,j} \\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n$$ {#eq-bet1}\n\n## Betweenness, Geodesic Distance and Shortest Paths\n\nLet's see an example of how to calculate betweenness centrality using real data. We first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(networkdata)\n    library(igraph)\n    library(stringr) #using stringr to change names from all caps to title case\n    g <- movie_559\n    V(g)$name <- str_to_title(V(g)$name)\n    V(g)$name[which(V(g)$name == \"Esmarelda\")] <- \"Esmeralda\" #fixing misspelled name\n    E(g)$weight <- 1 #setting weights to 1.0 (relevant for betweenness calculation)\n    V(g)$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Brett\"           \"Buddy\"           \"Butch\"           \"Capt Koons\"     \n [5] \"Ed Sullivan\"     \"English Dave\"    \"Esmeralda\"       \"Fabienne\"       \n [9] \"Fourth Man\"      \"Gawker #2\"       \"Honey Bunny\"     \"Jimmie\"         \n[13] \"Jody\"            \"Jules\"           \"Lance\"           \"Manager\"        \n[17] \"Marsellus\"       \"Marvin\"          \"Maynard\"         \"Mia\"            \n[21] \"Mother\"          \"Patron\"          \"Pedestrian\"      \"Preacher\"       \n[25] \"Pumpkin\"         \"Raquel\"          \"Roger\"           \"Sportscaster #1\"\n[29] \"Sportscaster #2\" \"The Gimp\"        \"The Wolf\"        \"Vincent\"        \n[33] \"Waitress\"        \"Winston\"         \"Woman\"           \"Young Man\"      \n[37] \"Young Woman\"     \"Zed\"            \n```\n:::\n:::\n\n\nTo compute the components of the betweenness centrality defined earlier, we need two pieces of information. First we need to know the *length* of the shortest path between every pair of nodes. As we saw in our discussion of [closeness](closcent.qmd), this is stored in the **geodesic distance matrix** of the graph $\\mathbf{G}$. In `igraph` we can obtain that using the `distances` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    G <- distances(g)\n    G[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Brett Buddy Butch Capt Koons Ed Sullivan English Dave Esmeralda\nBrett            0     2     1          2           2            2         2\nBuddy            2     0     2          2           2            2         3\nButch            1     2     0          1           2            1         1\nCapt Koons       2     2     1          0           2            2         2\nEd Sullivan      2     2     2          2           0            2         3\nEnglish Dave     2     2     1          2           2            0         2\nEsmeralda        2     3     1          2           3            2         0\nFabienne         1     3     1          2           3            2         2\nFourth Man       2     2     2          2           2            2         3\nGawker #2        2     3     1          2           3            2         2\n             Fabienne Fourth Man Gawker #2\nBrett               1          2         2\nBuddy               3          2         3\nButch               1          2         1\nCapt Koons          2          2         2\nEd Sullivan         3          2         3\nEnglish Dave        2          2         2\nEsmeralda           2          3         2\nFabienne            0          2         2\nFourth Man          2          0         3\nGawker #2           2          3         0\n```\n:::\n:::\n\n\nNext we need to know the *number* of shortest paths linking every pair of nodes (as nodes can be linked by multiple distinct shortest paths). In `igraph` we can use the `all_shortest_paths` function to figure out this information. \n\nFor instance, let's say we wanted to find the number of shortest paths between the pair of nodes \"Young Man\" (at the diner) and \"The Pedestrian\" (who appears when Butch encounters Marsellus on the street). To do that we can just type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    ap <- all_shortest_paths(g, from = \"Pedestrian\", to = \"Young Man\")\n    ap$vpaths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian  Butch       Jules       Honey Bunny Young Man  \n\n[[2]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian  Marsellus   Jules       Honey Bunny Young Man  \n\n[[3]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian  Butch       Vincent     Honey Bunny Young Man  \n\n[[4]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian  Marsellus   Vincent     Honey Bunny Young Man  \n\n[[5]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian Butch      Jules      Pumpkin    Young Man \n\n[[6]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian Marsellus  Jules      Pumpkin    Young Man \n\n[[7]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian Butch      Vincent    Pumpkin    Young Man \n\n[[8]]\n+ 5/38 vertices, named, from 9e7cc7a:\n[1] Pedestrian Marsellus  Vincent    Pumpkin    Young Man \n```\n:::\n:::\n\n\nThe `all_shortest_paths` function has three arguments: The graph `g`, the `from` node (the starting node in the path count) and the `to` node (the end node in the path count).^[In an undirected graph you get the same result for a pair of nodes regardless of which one you put on the `from` or `to` slots.] \n\nThe function stores the results in a list object containing various sub-objects. The actual paths (containing the node ids) are in a list sub-object called `vpaths`, which is itself a list (with named vectors containing the indices of the nodes of each path as elements). The `length` of this list is the number of shortest paths between the young man at the diner and the pedestrian:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    length(ap$vpaths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nWe can see that the list is of length eight, indicating that there are eight total shortest paths between the pedestrian and the young man.\n\nIf we wanted to verify the *length of the shortest path* between these two nodes, we could just type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    G[\"Young Man\", \"Pedestrian\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nWhich provides us with the relevant entry in the geodesic distance matrix, telling us that the young man is four steps away from the pedestrian in the network. This also means that each path will involve five nodes (counting the young man and the pedestrian, with three intermediary nodes).\n\nNote that we could have gotten the same information using the `distances` function in `igraph` specifying the `v` and `to` nodes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    distances(g, v = \"Young Man\", to = \"Pedestrian\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Pedestrian\nYoung Man          4\n```\n:::\n:::\n\n\nNow, to create the **shortest paths matrix** for the graph $\\mathbf{S}$, we can just loop through each pair and record the length of the shortest paths for non-adjancent nodes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    n <- vcount(g)\n    A <- as.matrix(as_adjacency_matrix(g))\n    S <- matrix(1, n, n) #intializing shortest paths matrix\n    diag(S) <- 0 #setting diagonals to zero (Brandes, 2008, p. 137)\n    rownames(S) <- V(g)$name\n    colnames(S) <- V(g)$name\n    for (i in 1:n) {\n        for (j in i:n) { #looping through upper triangle\n            if (A[i,j] == 0) { #restrict to non-adjancent nodes \n                S[i,j] <- length(all_shortest_paths(g, from = i, to = j)$vpaths)\n                }\n            }\n        }\n    S[lower.tri(S)] <- t(S)[lower.tri(S)] #copying upper triangle into lower triangle\n    S[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Brett Buddy Butch Capt Koons Ed Sullivan English Dave Esmeralda\nBrett            1     1     1          2           1            3         1\nBuddy            1     1     2          2           2            2         2\nButch            1     2     1          1           2            1         1\nCapt Koons       2     2     1          1           2            3         1\nEd Sullivan      1     2     2          2           1            2         2\nEnglish Dave     3     2     1          3           2            1         1\nEsmeralda        1     2     1          1           2            1         1\nFabienne         1     4     1          1           4            1         1\nFourth Man       2     1     2          1           1            1         2\nGawker #2        2     4     1          1           4            2         1\n             Fabienne Fourth Man Gawker #2\nBrett               1          2         2\nBuddy               4          1         4\nButch               1          2         1\nCapt Koons          1          1         1\nEd Sullivan         4          1         4\nEnglish Dave        1          1         2\nEsmeralda           1          2         1\nFabienne            1          1         1\nFourth Man          1          1         4\nGawker #2           1          4         1\n```\n:::\n:::\n\n\nOnce we have this information, we have all we need to compute the various quantities defined earlier. \n\n## Computing Pairwise Dependencies\n\nFor instance, @brandes01 [p. 166] shows that we can take advantage of the fact that a node $k$ can only lie on a shortest path between $i$ and $j$ if the sum of the geodesic distances between $i$ and $k$ and between $k$ and $j$ is equal to the geodesic distance between $i$ and $j$:\n$$\ng_{ij} = g_{ik} + g_{kj}\n$$\n\nIf the above equality obtains, then the number of shortest paths between $i$ and $j$ (the numerator of @eq-pair) is simply $s_{ik} \\times s_{kj}$, namely the product of the number of shortest paths between $i$ and $k$ and between $k$ and $j$, meaning that the pair dependency of $i$ and $j$ on $k$ will be just:\n\n$$\n\\delta_{i(k)j}= \\frac{s_{ik} s_{kj}}{s_{ij}}\n$$\n\nThis also means that if the above equality does *not* obtain and $g_{ij} \\neq g_{ik} + g_{kj}$, then we know for sure that the pair dependency of $i$ and $j$ on $k$ is zero ($k$ does not lie on any shortest path between $i$ and $j$). \n\nUsing this approach, we can write a simple function to compute the pair dependency of any two nodes on a third node, using information stored in the $\\mathbf{G}$ and $\\mathbf{S}$ matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    pair.dep <- function(a, b, c) {\n        if (G[a, b] == G[a, c] + G[c, b]) {return((S[a, c] * S[c, b])/S[a, b])}\n        else {return(0)}\n        }\n```\n:::\n\n\nTesting it out to compute the pair dependency of the young man and the pedestrian on Vincent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    pair.dep(\"Pedestrian\", \"Young Man\", \"Vincent\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\nWhich says that Vicent lies on 50% of the paths between the The Young Man and The Pedestrian (four out of eight).\n\n## Computing One-Sided Dependencies\n\nAs noted in @eq-one, the *one-sided dependency* of a node $i$ on another node $k$ is just the sum of the pairwise dependencies involving $i$ as a source and $k$ as an intermediary across every destination node $j$. We can get these using a simple wrapper function over the `pair.dep` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    one.sided <- function(a, c) {\n        od <- 0\n        i <- which(V(g)$name == a)\n        k <- which(V(g)$name == c)\n        for (j in c(1:vcount(g))[-c(i, k)]) {od <- od + pair.dep(i, j, k)}\n        return(od)\n        }\n```\n:::\n\n\nSo the one-sided dependence of the young man on Vincent is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    one.sided(\"Young Man\", \"Vincent\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19\n```\n:::\n:::\n\n\nWhich is the sum of the pair dependencies that involve the young man as a starting node and Vincent as an inner node.\n\nNote that while the young man is highly dependent on Vincent to reach others, the reverse is not the case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    one.sided(\"Vincent\", \"Young Man\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nAs the young man stands on none of the paths that link Vincent to other nodes in the graph. \n\n## Computing Betweenness\n\nAs noted in @eq-bet1, Vincent's *betweenness* is just the sum of the dependencies of each pair of nodes in the graph on him. We could compute that (not very efficiently) using the following wrapper function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    bet.cent <- function(c) {\n        n <- vcount(g)\n        bc <- 0\n        k <- which(V(g)$name == c)\n        for (i in 1:n) {\n            for (j in i:n) {\n                if (i != k & j != k & A[i, j] == 0) {bc <- bc + pair.dep(i, j, k)}\n            }\n        }\n    return(bc)\n    }\n```\n:::\n\n\nAnd now to find Vicent's betweenness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    bet.cent(\"Vincent\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 301\n```\n:::\n:::\n\n\nWhich is the same result we would have gotten had we used the `betweenness` function in `igraph` specifying that we want the answer just for the Vincent node:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    betweenness(g, v = \"Vincent\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVincent \n    301 \n```\n:::\n:::\n\n\nWe can of course use the same `igraph` function to---efficiently, using Brandes's [-@brandes01] algorithm---compute the betweenness centrality of each node in the graph stored in a vector of length $N$:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    pulp.bet <- betweenness(g)\n```\n:::\n\n\nWe should expect a character to have high betweenness in this network to the extent that they appear in scenes with characters who themselves don't appear in any scenes together, thus inter-mediating between different parts of the story. Characters who only appear in one scene with some others (like The Wolf or The Gimp) are likely to be low in betweenness.\n\nUsing the information stored in the `pulp.bet` vector of betweenness centralities for each node, we can create a top ten table of betweenness for the *Pulp Fiction* network.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(kableExtra)\n    top.10.bet <- sort(pulp.bet, decreasing = TRUE)[1:10]\n    kbl(round(top.10.bet, 2), format = \"pipe\", align = c(\"l\", \"c\"),\n        col.names = c(\"Character\", \"Betweenness\"),\n        caption = \"Top Five Betweenness Characters in Pulp Fiction Network.\") |> \n    kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Top Five Betweenness Characters in Pulp Fiction Network.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Character </th>\n   <th style=\"text-align:left;\"> Betweenness </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Vincent </td>\n   <td style=\"text-align:left;\"> 301.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Butch </td>\n   <td style=\"text-align:left;\"> 248.33 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Jules </td>\n   <td style=\"text-align:left;\"> 114.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Maynard </td>\n   <td style=\"text-align:left;\"> 70.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Honey Bunny </td>\n   <td style=\"text-align:left;\"> 49.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Pumpkin </td>\n   <td style=\"text-align:left;\"> 49.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Sportscaster #1 </td>\n   <td style=\"text-align:left;\"> 36.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Mia </td>\n   <td style=\"text-align:left;\"> 33.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Marsellus </td>\n   <td style=\"text-align:left;\"> 26.67 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Brett </td>\n   <td style=\"text-align:left;\"> 2.67 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nUnsurprisingly, the three main characters in the story are also the highest in betweenness, with the already considered Vincent at the top of the list (that makes sense since Vincent intermediates between Butch and the rest of the story as he sadly found out in the [toilet](https://www.youtube.com/watch?v=fm9VPN1r4Hk)). Somewhat surprisingly, the main antagonist of the story (the pawn shop owner) is also up there. After that we see a big drop in the bottom five of the top ten. \n\n\n## Computing Normalized Betweenness\n\nThe `betweenness` function in `igraph` uses Freeman's [-@freeman79] normalization for the betweenness centrality, which is equal to:\n\n$$\nC^{NB}_k = = \\frac{2\\left[\\sum_{i,j} \\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\\right]}{(n-1)(n-2)}\n$$ {#eq-nbet}\n\nWhere the denominator of the fraction, $(n-1)(n-2)$, is equal to (two times) the betweenness a node would have if it was the center of a **star graph** of the same order as the observed network. \n\nSo for the *Pulp Fiction* network the normalized betweenness is equal to:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    n <- vcount(g)\n    pulp.nbet <- (2*pulp.bet)/((n-1)*(n-2))\n    top.10.nbet <- sort(pulp.nbet, decreasing = TRUE)[1:10]\n    round(top.10.nbet, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Vincent           Butch           Jules         Maynard     Honey Bunny \n         0.4520          0.3729          0.1714          0.1051          0.0743 \n        Pumpkin Sportscaster #1             Mia       Marsellus           Brett \n         0.0743          0.0541          0.0503          0.0400          0.0040 \n```\n:::\n:::\n\n\nWhich are the same scores we would obtain using the `igraph` function with the argument `normalized` set to `TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    pulp.nbet <- betweenness(g, normalized = TRUE)\n    top.10.nbet <- sort(pulp.nbet, decreasing = TRUE)[1:10]\n    round(top.10.nbet, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Vincent           Butch           Jules         Maynard     Honey Bunny \n         0.4520          0.3729          0.1714          0.1051          0.0743 \n        Pumpkin Sportscaster #1             Mia       Marsellus           Brett \n         0.0743          0.0541          0.0503          0.0400          0.0040 \n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}