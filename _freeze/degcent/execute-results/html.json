{
  "hash": "1d14019f36254c05a768c42a15c5df84",
  "result": {
    "markdown": "---\ntitle: \"Degree Centrality\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nIn these lecture notes we will go through the basic centrality metrics. Particularly, the \"big three\" according to @freeman79, namely, **degree**, **closeness** (in two flavors) and **betweenness**. \n\nWe first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(networkdata)\n   library(igraph)\n   g <- movie_559\n```\n:::\n\n\n## Degree Centrality\n\nDegree centrality is the simplest and most straightforward measure. In fact, we are already computed in the [lecture notes on basic network statistics](basic.qmd) since it is the same as obtaining the graph's **degree sequence**. So the `igraph` function `degree` would do it as we already saw. \n\nHere we follow a different approach using the row (or column) sums of the graph's **adjacency matrix**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as_adjacency_matrix(g)\n   A <- as.matrix(A)\n   rowSums(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n              7               2              17               5               2 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n              4               1               3               2               3 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n              8               3               4              16               4 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n              5              10               6               3              11 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n              5               5               3               3               8 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n              3               6               2               1               2 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n              3              25               4               3               5 \n      YOUNG MAN     YOUNG WOMAN             ZED \n              4               4               2 \n```\n:::\n:::\n\n\nThe `igraph` function `as_adjancency_matrix` doesn't quite return a regular `R` matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the `as.matrix` function in line 2. Then we can apply the native `rowSums` function to obtain each node's degree. Note that this is same output we got using the `degree` function before. \n\n## Indegree and Outdegree\n\nThe movie network is based on the relationship of co-appearance in a scene which by nature lacks any natural directionality (it's a symmetric relation) and can therefore be represented in an **undirected graph**. The concepts of in and outdegree, by contrast, are only applicable to directed relations. So to illustrate them, we need to switch to a different source of data.\n\nWe pick an **advice network** which is a classical directed kind of (asymmetric) relation. I can give advice to you, but that doesn't necessarily mean you can give advice to me. The `networkdata` package contains one such data set collected in the late 80s early 1990s in a New England law firm [@lazega01] called `law_advice`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- law_advice\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 71/71 vertices, from d1a9da7:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n[51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n```\n:::\n\n```{.r .cell-code}\n   vertex_attr(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$status\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n[39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n\n$gender\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 2 1 1 1 2\n[39] 2 1 1 1 2 2 1 2 1 2 1 1 2 1 1 1 1 1 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2\n\n$office\n [1] 1 1 2 1 2 2 2 1 1 1 1 1 1 2 3 1 1 2 1 1 1 1 1 1 2 1 1 2 1 2 2 2 2 1 2 1 3 1\n[39] 1 1 1 1 1 3 1 2 3 1 1 2 2 1 1 1 1 1 1 2 2 1 1 1 2 1 1 1 1 1 1 1 1\n\n$seniority\n [1] 31 32 13 31 31 29 29 28 25 25 23 24 22  1 21 20 23 18 19 19 17  9 16 15 15\n[26] 15 13 11 10  7  8  8  8  8  8  5  5  7  6  6  5  4  5  5  3  3  3  1  4  3\n[51]  4  4 10  3  3  3  3  3  2  2  2  2  2  2  2  1  1  1  1  1  1\n\n$age\n [1] 64 62 67 59 59 55 63 53 53 53 50 52 57 56 48 46 50 45 46 49 43 49 45 44 43\n[26] 41 47 38 38 39 34 33 37 36 33 43 44 53 37 34 31 31 47 53 38 42 38 35 36 31\n[51] 29 29 38 29 34 38 33 33 30 31 34 32 29 45 28 43 35 26 38 31 26\n\n$practice\n [1] 1 2 1 2 1 1 2 1 2 2 1 2 1 2 2 2 2 1 2 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2 2 1 2 1\n[39] 1 1 1 2 1 2 2 2 1 2 1 2 1 1 2 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 1\n\n$law_school\n [1] 1 1 1 3 2 1 3 3 1 3 1 2 2 1 3 1 1 2 1 1 2 3 2 2 2 3 1 2 3 3 2 3 3 2 3 3 3 2\n[39] 1 1 2 2 2 1 3 2 3 3 2 2 3 3 3 3 3 2 2 3 2 2 3 2 2 2 3 3 2 3 3 2 2\n```\n:::\n:::\n\n\nWe can see that the graph has 71 vertices, and that there are various **attributes** associated with each vertex, like gender, age, seniority, status in the law firm, etc. We can query those attributes using the `igraph` function `vertex_attr`, which takes the graph object as input. \n\nTo keep things manageable, we will restrict our analysis to partners. To do that we need to select the **subgraph** that only includes the vertices with value of 1 in the \"status\" vertex attribute. From the [data description](https://www.rdocumentation.org/packages/networkdata/versions/0.1.6/topics/law_advice), we know the first 36 nodes (with value of 1 in the status attribute) are the law firm's partners (the rest are associates). In `igraph` we can do this as using the `subgraph` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- subgraph(d.g, 1:36)\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 36/36 vertices, from 09c560b:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n```\n:::\n\n```{.r .cell-code}\n   V(d.g)$status\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n\nThe first line just tells `igraph` to generate the subgraph containing the first 36 nodes (the partners). The `subgraph` function thus takes two main inputs: The graph object, and then a vector of node ids (or node labels) telling the function which nodes to select to create the **node-induced subgraph**.\n\n### Computing in and outdegree\n\nOK, going back to the partners subgraph, we can now create our (asymmetric) adjacency matrix and compute the row and column sums:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.A <- as_adjacency_matrix(d.g)\n   d.A <- as.matrix(d.A)\n   rowSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   colSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that in contrast to the undirected case the row and column sums give you two different sets of numbers. The row sums provide the directed graph's **outdegree set** (number of *outgoing* links incident to each node), and the column sums provide the graph's **indegree set** (number of *incoming* links incident to each node). So if you are high in the first vector, you are an *advice giver* (perhaps indicating informal status or experience) and if you are high in the second you are advice taker.\n\nOf course `igraph` has a dedicated function for this, which is just our old friend `degree` with an extra option `mode`, indicating whether you want the in or outdegrees:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.o <- degree(d.g, mode = \"out\")\n   d.i <- degree(d.g, mode = \"in\")\n   d.o\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   d.i\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that the graph attributes are just vectors of values, and can be accessed from the graph object using the $ operator attached to the `V()` function as we did above. \n\nSo if we wanted to figure out the correlation between some vertex attribute and in or out degree centrality, all we need to do is correlate the two vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   r <- cor(d.o, V(d.g)$age)\n   round(r, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.43\n```\n:::\n:::\n\n\nWhich tells us that at least in this case, younger partners are more sought after as sources of advice than older partners. \n\n## Edge Closeness\n\n@brohl_lehnertz22 define the closeness of an edge as a function of the closeness of the two nodes incident to it. An edge $e_{jk}$ linking vertex $v_j$ to $v_k$ has high closeness whenever vertices $v_j$ and $v_k$ also have high closeness. \n\nMore specifically, the closeness centrality of an edge is proportional to the ratio of the product of the closeness of the two nodes incident to it divided by their sum:\n\n$$\nC(e_{jk}) = (E - 1)\\frac{C(v_j) \\times C(v_k)}{C(v_j)+C(v_k)}\n$$\n\nNote that the equation normalizes the ratio of the product to the sum of the vertex closeness centralities by the number of edges minus one.  \n\nTo compute edge closeness in a real network, we can use the same approach to data wrangling we used to [compute the degree correlation](basic.qmd). The goal is to create an edge list data frame containing five columns. The ids of the two nodes in the edge, the closeness centralities of the two nodes in the edge, and the closeness centrality of the edge calculated according to the above equation.\n\nIn the *Pulp Fiction* network this looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(dplyr)\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   c <- round(closeness(g), 3)  #closeness centrality vector\n   c.dat <- data.frame(name1 = names(c), name2 = names(c), c)\n   el.temp <- data.frame(name2 = g.el[, 2]) %>% \n      left_join(c.dat, by = \"name2\") %>% \n      dplyr::select(c(\"name2\", \"c\")) %>% \n      rename(c2 = c) \n   c.el <- data.frame(name1 = g.el[, 1]) %>% \n      left_join(c.dat, by = \"name1\") %>% \n      dplyr::select(c(\"name1\", \"c\")) %>% \n      rename(c1 = c) %>% \n      cbind(el.temp) %>% \n      mutate(e.clos = round((ecount(g)-1)*(c1*c2)/(c+c2), 3))\nhead(c.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name1    c1     name2    c2 e.clos\n1 BRETT 0.013 MARSELLUS 0.010  0.571\n2 BRETT 0.013    MARVIN 0.010  0.625\n3 BRETT 0.013     ROGER 0.013  0.632\n4 BRETT 0.013   VINCENT 0.014  0.681\n5 BUDDY 0.011       MIA 0.011  0.555\n6 BUDDY 0.011   VINCENT 0.014  0.622\n```\n:::\n:::\n\n\nTo create a table of the top five closeness centrality edges, we just order the data frame by the last column and table it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(kableExtra)\n   c.el <- c.el[order(c.el$e.clos, decreasing = TRUE), ] %>% \n      dplyr::select(c(\"name1\", \"name2\", \"e.clos\"))\n\n   kbl(c.el[1:5, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Clos.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Closeness in the Pulp Fiction Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Edges Sorted by Closeness in the Pulp Fiction Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> i </th>\n   <th style=\"text-align:left;\"> j </th>\n   <th style=\"text-align:center;\"> Edge Clos. </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:center;\"> 0.900 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BRETT </td>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:center;\"> 0.875 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MOTHER </td>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:center;\"> 0.875 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> MIA </td>\n   <td style=\"text-align:center;\"> 0.864 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JULES </td>\n   <td style=\"text-align:left;\"> PUMPKIN </td>\n   <td style=\"text-align:center;\"> 0.850 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nInterestingly, the top closeness edges tend to bring somewhat strange bedfellows together, characters that themselves don't spend much time together in the film (e.g., the Butch/Vincent interaction is relatively brief and somewhat embarrassing for Vincent) but who themselves can reach other character clusters in the film via relatively short paths.\n\n\n\n\n\n",
    "supporting": [
      "degcent_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}