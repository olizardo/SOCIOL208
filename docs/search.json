[
  {
    "objectID": "handout2.html",
    "href": "handout2.html",
    "title": "Centrality",
    "section": "",
    "text": "In this handout we will go through the basic centrality metrics. Particularly, the “big three” according to Freeman (1979), namely, degree, closeness (in two flavors) and betweenness.\nWe first load our trusty Pulp Fiction data set from the networkdata package, which is an undirected graph of character scene co-appearances in the film:"
  },
  {
    "objectID": "handout2.html#degree-cenntrality",
    "href": "handout2.html#degree-cenntrality",
    "title": "Centrality",
    "section": "Degree Cenntrality",
    "text": "Degree Cenntrality\nDegree centrality is the simplest and most straightforward measure. In fact, we are already computed in handout 1 since it is the same as obtaining the graph’s degree sequence. So the igraph function degree would do it as we already saw.\nHere we follow a different approach using the row (or column) sums of the graph’s adjacency matrix:\n\n   A <- as_adjacency_matrix(g)\n   A <- as.matrix(A)\n   rowSums(A)\n\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n              7               2              17               5               2 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n              4               1               3               2               3 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n              8               3               4              16               4 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n              5              10               6               3              11 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n              5               5               3               3               8 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n              3               6               2               1               2 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n              3              25               4               3               5 \n      YOUNG MAN     YOUNG WOMAN             ZED \n              4               4               2 \n\n\nThe igraph function as_adjancency_matrix doesn’t quite return a regular R matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the as.matrix function in line 2. Then we can apply the native rowSums function to obtain each node’s degree. Note that this is same output we got using the degree function before."
  },
  {
    "objectID": "handout2.html#indegree-and-outdegree",
    "href": "handout2.html#indegree-and-outdegree",
    "title": "Centrality",
    "section": "Indegree and Outdegree",
    "text": "Indegree and Outdegree\nThe movie network is based on the relationship of co-appearance in a scene which by nature lacks any natural directionality (it’s a symmetric relation) and can therefore be represented in an undirected graph. The concepts of in and outdegree, by contrast, are only applicable to directed relations. So to illustrate them, we need to switch to a different source of data.\nWe pick an advice network which is a classical directed kind of (asymmetric) relation. I can give advice to you, but that doesn’t necessarily mean you can give advice to me. The networkdata package contains one such data set collected in the late 80s early 1990s in a New England law firm (see the description here), called law_advice:\n\n   d.g <- law_advice\n   V(d.g)\n\n+ 71/71 vertices, from d1a9da7:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n[51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n\n   vertex_attr(d.g)\n\n$status\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n[39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n\n$gender\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 2 1 1 1 2\n[39] 2 1 1 1 2 2 1 2 1 2 1 1 2 1 1 1 1 1 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2\n\n$office\n [1] 1 1 2 1 2 2 2 1 1 1 1 1 1 2 3 1 1 2 1 1 1 1 1 1 2 1 1 2 1 2 2 2 2 1 2 1 3 1\n[39] 1 1 1 1 1 3 1 2 3 1 1 2 2 1 1 1 1 1 1 2 2 1 1 1 2 1 1 1 1 1 1 1 1\n\n$seniority\n [1] 31 32 13 31 31 29 29 28 25 25 23 24 22  1 21 20 23 18 19 19 17  9 16 15 15\n[26] 15 13 11 10  7  8  8  8  8  8  5  5  7  6  6  5  4  5  5  3  3  3  1  4  3\n[51]  4  4 10  3  3  3  3  3  2  2  2  2  2  2  2  1  1  1  1  1  1\n\n$age\n [1] 64 62 67 59 59 55 63 53 53 53 50 52 57 56 48 46 50 45 46 49 43 49 45 44 43\n[26] 41 47 38 38 39 34 33 37 36 33 43 44 53 37 34 31 31 47 53 38 42 38 35 36 31\n[51] 29 29 38 29 34 38 33 33 30 31 34 32 29 45 28 43 35 26 38 31 26\n\n$practice\n [1] 1 2 1 2 1 1 2 1 2 2 1 2 1 2 2 2 2 1 2 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2 2 1 2 1\n[39] 1 1 1 2 1 2 2 2 1 2 1 2 1 1 2 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 1\n\n$law_school\n [1] 1 1 1 3 2 1 3 3 1 3 1 2 2 1 3 1 1 2 1 1 2 3 2 2 2 3 1 2 3 3 2 3 3 2 3 3 3 2\n[39] 1 1 2 2 2 1 3 2 3 3 2 2 3 3 3 3 3 2 2 3 2 2 3 2 2 2 3 3 2 3 3 2 2\n\n\nWe can see that the graph has 71 vertices, and that there are various attributes associated with each vertex, like gender, age, seniority, status in the law firm, etc. We can query those attributes using the igraph function vertex_attr, which takes the graph object as input.\n\nSubsetting the Graph According to a Node Attribute\nTo keep things manageable, we will restrict our analysis to partners. To do that we need to select the subgraph that only includes the vertices with value of 1 in the “status” vertex attribute. From the data description, we know the first 36 nodes (with value of 1 in the status attribute) are the law firm’s partners (the rest are associates). In igraph we can do this as using the subgraph function:\n\n   d.g <- subgraph(d.g, 1:36)\n   V(d.g)\n\n+ 36/36 vertices, from 1423760:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n\n   V(d.g)$status\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\n\nThe first line just tells igraph to generate the subgraph containing the first 36 nodes (the partners). The subgraph function thus takes two main inputs: The graph object, and then a vector of node ids (or node labels) telling the function which nodes to select to create the node-induced subgraph.\nOf course we already knew from the data description that the first 36 nodes where the partners. But let’s say we have a large data set and we don’t know which nodes are the partners. A smarter way of selecting a subgraph based on a node attribute is as follows:\n\n   partners <- which(V(law_advice)$status == 1)\n   d.g <- subgraph(law_advice, partners)\n   V(d.g)\n\n+ 36/36 vertices, from 142abba:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n\n\nThe first line using the native R vector function which allowing us to subset a vector based on a logical condition. The function takes a vector followed by a logical condition as input, and returns the position of the vector elements that meet that condition. In this case, we took the vector of values for the attribute of status and selected the node ids where status is equal to 1. We then fed that vector to the subgraph function in line 2.\nWe could do this with any other attribute:\n\n   older <- which(V(law_advice)$age > 50)\n   older\n\n [1]  1  2  3  4  5  6  7  8  9 10 12 13 14 38 44\n\n   og <- subgraph(law_advice, older)\n   V(og)\n\n+ 15/15 vertices, from 14312b4:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\n\nHere we selected the subgraph (called “og”, get it, get it) formed by the subset of nodes over the age of 50 at the firm. The values of the vector older tell us which of the 71 members meet the relevant condition.\n\n\nComputing in and outdegree\nOK, going back to the partners subgraph, we can now create our (asymmetric) adjacency matrix and compute the row and column sums:\n\n   d.A <- as_adjacency_matrix(d.g)\n   d.A <- as.matrix(d.A)\n   rowSums(d.A)\n\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n\n   colSums(d.A)\n\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n\n\nNote that in contrast to the undirected case the row and column sums give you two different sets of numbers. The row sums provide the directed graph’s outdegree set (number of outgoing links incident to each node), and the column sums provide the graph’s indegree set (number of incoming links incident to each node). So if you are high in the first vector, you are an advice giver (perhaps indicating informal status or experience) and if you are high in the second you are advice taker.\nOf course igraph has a dedicated function for this, which is just our old friend degree with an extra option mode, indicating whether you want the in or outdegrees:\n\n   d.o <- degree(d.g, mode = \"out\")\n   d.i <- degree(d.g, mode = \"in\")\n   d.o\n\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n\n   d.i\n\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n\n\nNote that the graph attributes are just vectors of values, and can be accessed from the graph object using the $ operator attached to the V() function as we did above.\nSo if we wanted to figure out the correlation between some vertex attribute and in or out degree centrality, all we need to do is correlate the two vectors:\n\n   r <- cor(d.o, V(d.g)$age)\n   round(r, 2)\n\n[1] -0.43\n\n\nWhich tells us that at least in this case, younger partners are more sought after as sources of advice than older partners."
  },
  {
    "objectID": "handout2.html#closeness-centrality",
    "href": "handout2.html#closeness-centrality",
    "title": "Centrality",
    "section": "Closeness Centrality",
    "text": "Closeness Centrality\nRecall that the closeness centrality is defined as the inverse of the sum of shortest paths from each node to every other node. That means that to compute it, we first need to calculate the shortest path matrix. Then, we sum the rows (or columns) and then we obtain the inverse to get the closeness of each node:\n\n   S <- distances(g) #shortest paths matrix\n   d.sum <- rowSums(S)\n   close1 <- round(1/d.sum, 4)\n   close1\n\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n         0.0125          0.0108          0.0143          0.0125          0.0108 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n         0.0105          0.0070          0.0096          0.0104          0.0097 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n         0.0114          0.0093          0.0093          0.0132          0.0093 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n         0.0111          0.0104          0.0103          0.0098          0.0115 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n         0.0125          0.0111          0.0097          0.0097          0.0114 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n         0.0105          0.0125          0.0096          0.0057          0.0073 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n         0.0056          0.0139          0.0083          0.0105          0.0125 \n      YOUNG MAN     YOUNG WOMAN             ZED \n         0.0083          0.0083          0.0073 \n\n\nOf course, we could have just used the available function in igraph and computed the closeness centrality directly from the graph object using the function closeness:\n\n   close2 <- round(closeness(g), 4)\n   close2\n\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n         0.0125          0.0108          0.0143          0.0125          0.0108 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n         0.0105          0.0070          0.0096          0.0104          0.0097 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n         0.0114          0.0093          0.0093          0.0132          0.0093 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n         0.0111          0.0104          0.0103          0.0098          0.0115 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n         0.0125          0.0111          0.0097          0.0097          0.0114 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n         0.0105          0.0125          0.0096          0.0057          0.0073 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n         0.0056          0.0139          0.0083          0.0105          0.0125 \n      YOUNG MAN     YOUNG WOMAN             ZED \n         0.0083          0.0083          0.0073 \n\n\nOnce we have the closeness centrality values, we are interested in who are the top nodes. The following code creates a table with the top five:\n\n   library(kableExtra)\n   close2 <- sort(close2, decreasing = TRUE)\n   close2 <- data.frame(close2[1:5])\n   kbl(close2, format = \"pipe\", align = c(\"l\", \"c\"),\n       col.names = c(\"Character\", \"Closeness\"),\n       caption = \"Top Five Closeness Characters in Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nTop Five Closeness Characters in Pulp Fiction Network.\n \n  \n    Character \n    Closeness \n  \n \n\n  \n    BUTCH \n    0.0143 \n  \n  \n    VINCENT \n    0.0139 \n  \n  \n    JULES \n    0.0132 \n  \n  \n    BRETT \n    0.0125 \n  \n  \n    CAPT KOONS \n    0.0125 \n  \n\n\n\n\n\nIt makes sense that the three main characters are also the ones that are at closest distances from everyone else!\nWhat about closeness centrality for a directed network? Let us see how this works using a subgraph of the advice network, this time selecting just women under the age of forty:\n\n   women <- which(V(law_advice)$gender == 2)\n   wg <- subgraph(law_advice, women)\n   young <- which(V(wg)$age < 40)\n   wg <- subgraph(wg, young)\n   V(wg)\n\n+ 12/12 vertices, from 147f37f:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n\nThis network is small enough that a plot could be informative about its structure. Let us plot it using the package ggraph, a visualization package that follows the same principles as the ggplot grammar of graphics but for network graphs (see here).\n\n   #install.packages(\"ggraph\")\n   library(ggraph)\n    p <- ggraph(wg, layout = 'auto')\n    p <- p + geom_edge_parallel(color = \"steelblue\", edge_width = 0.5,\n                                arrow = arrow(length = unit(2.5, 'mm')),\n                                end_cap = circle(4, 'mm'), \n                                sep = unit(3, 'mm'))\n    p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = \"tan2\") \n    p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = \"white\")\n    p <- p + theme_graph() \n    p\n\n\n\n\nWomen lawyers advice network\n\n\n\n\nNow a question we might ask is who has the greatest closeness centrality in this advice network. We could proceed as usual and compute the geodesic distances between actors:\n\n   S <- distances(wg)\n   S\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,]    0    1    2    1    3    3    4    2    2     3     3     3\n [2,]    1    0    2    1    2    3    3    1    1     3     3     3\n [3,]    2    2    0    1    1    1    2    2    3     1     1     1\n [4,]    1    1    1    0    2    2    3    2    2     2     2     2\n [5,]    3    2    1    2    0    1    1    1    2     2     2     2\n [6,]    3    3    1    2    1    0    2    2    3     1     2     1\n [7,]    4    3    2    3    1    2    0    2    3     3     3     3\n [8,]    2    1    2    2    1    2    2    0    1     3     3     3\n [9,]    2    1    3    2    2    3    3    1    0     4     4     4\n[10,]    3    3    1    2    2    1    3    3    4     0     1     1\n[11,]    3    3    1    2    2    2    3    3    4     1     0     1\n[12,]    3    3    1    2    2    1    3    3    4     1     1     0\n\n\nNote that this is not quite right. In igraph the default settings of the distance function treats the graph as undirected. So it doesn’t use the strict directed paths, but it just treats them all as semi-paths ignoring direction. That is why, for instance, it counts node 1 as being “adjacent” to node 4 even though there is only one incoming link from 4 to 1 and why the whole matrix is symmetric, when we know from just eyeballing the network that there is a lot of asymmetry in terms of who can reach who via directed paths.\nTo get the actual directed distance matrix, we need to specify the “mode” option, asking whether we want in or out paths. Here, let’s select out-paths:\n\n   S <- distances(wg, mode = \"out\")\n   S\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,]    0    1  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf   Inf   Inf\n [2,]    1    0  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf   Inf   Inf\n [3,]    2    2    0    1  Inf    1  Inf  Inf  Inf   Inf   Inf   Inf\n [4,]    1    1    1    0  Inf    2  Inf  Inf  Inf   Inf   Inf   Inf\n [5,]    3    2    1    2    0    1    1    1    2   Inf   Inf   Inf\n [6,]    3    3    1    2  Inf    0  Inf  Inf  Inf   Inf   Inf   Inf\n [7,]    4    3    2    3    1    2    0    2    3   Inf   Inf   Inf\n [8,]    2    1  Inf  Inf  Inf  Inf  Inf    0    1   Inf   Inf   Inf\n [9,]    2    1  Inf  Inf  Inf  Inf  Inf    1    0   Inf   Inf   Inf\n[10,]    3    3    1    2  Inf    1  Inf  Inf  Inf     0     1     2\n[11,]    3    3    1    2  Inf    2  Inf  Inf  Inf     1     0     1\n[12,]    3    3    1    2  Inf    1  Inf  Inf  Inf     1     1     0\n\n\nThis is better but introduces a problem. The directed graph is not strongly connected, so it means that some nodes cannot reach other ones via a directed path of any length. That means that the geodesic distances from a node to an unreachable node is coded as “infinite” (Inf). The problem with infinity is that it gets in the way of calculatinng sums of distances, a requirement for the closeness centrality.\n\n   S <- distances(wg, mode = \"out\")\n   rowSums(S)\n\n [1] Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf\n\n\nAdding infinity to a number just returns infinity so all the rows with at least one “Inf” in the distance matrix get an Inf for the row sum. In this case that’s all of them. A bummer."
  },
  {
    "objectID": "handout2.html#betweenness",
    "href": "handout2.html#betweenness",
    "title": "Centrality",
    "section": "Betweenness",
    "text": "Betweenness\nWe finally come to betweenness centrality. Recall that the key conceptual distinction between closeness and betweenness according to Freeman (1979) is that between (pun intended) the capacity to reach others quickly (e.g., via the shortest paths) and the capacity to intermediate among those same paths. High betweenness nodes control the flow of information in the network between other nodes.\nThis is evident in the way betweenness is calculated. Recall that the betweenness of a node k relative to any pair of nodes i and j in the network is simply:\n\\[\n\\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n\\]\nWhere the denominator of the fraction (\\(\\sigma_{ij}\\)) is a count of the total number of shortest paths that start and end with nodes i and j and the numerator of the fraction (\\(\\sigma_{i(k)j}\\)) is the subset of those paths that include node k as an inner node.\nAs Freeman (1979) also notes because this is a ratio, it can range from zero to one, with everything in between. As such the betweenness centrality of a node relative to any two others has an intuitive interpretation as a probability, namely the probability that if you send something from i to j it has to go through k. This probability is 1.0 if k stands in every shortest path between i and j and zero if they stand in none of the shortest paths indirectly connecting i and j.\nThe betweenness of a given node is just the sum all of these probabilities across every pair of nodes in the graph for each node:\n\\[\n\\sum_{i \\neq j, i \\neq n, j \\neq v} \\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n\\]\nBelow we can see a point and line diagram of the undirectd Pulp Fiction network we have been working with.\n\n\n\n\n\nPulp Fiction character schene co-appearance network.\n\n\n\n\nWe should expect a character to have high betweenness in this network to the extent that they appear in scenes with characters who themselves don’t appear in any scenes together, thus inter-mediating between different parts of the story. Characters who only appear in one scene with some others (like The Wolf or The Gimp) are likely to be low in betweenness.\nLet’s create a top ten table of betweenness for the Pulp Fiction network. We use the igraph function betweenness to calculate the scores:\n\n   pulp.bet <- betweenness(g)\n   top.5.bet <- sort(pulp.bet, decreasing = TRUE)[1:10]\n   kbl(round(top.5.bet, 2), format = \"pipe\", align = c(\"l\", \"c\"),\n       col.names = c(\"Character\", \"Betweenness\"),\n       caption = \"Top Five Betweenness Characters in Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nTop Five Betweenness Characters in Pulp Fiction Network.\n \n  \n    Character \n    Betweenness \n  \n \n\n  \n    BUTCH \n    275.52 \n  \n  \n    VINCENT \n    230.19 \n  \n  \n    JULES \n    142.11 \n  \n  \n    MIA \n    76.68 \n  \n  \n    MAYNARD \n    70.00 \n  \n  \n    HONEY BUNNY \n    49.97 \n  \n  \n    PUMPKIN \n    49.97 \n  \n  \n    SPORTSCASTER #1 \n    36.00 \n  \n  \n    BRETT \n    29.85 \n  \n  \n    PREACHER \n    28.23 \n  \n\n\n\n\n\nUnsurprisingly, the top four characters are also the highest in betweenness. Somewhat surprisingly, the main antagonist of the story (the pawn shop owner) is also up there. After that we see a steep drop in the bottom five of the top ten.\nNow let us examine betweenness centrality in our directed women lawyers advice network:\n\n   w.bet <- betweenness(wg)\n   w.bet\n\n [1]  0.0000000  3.0000000 16.3333333 11.0000000  7.0000000  0.0000000\n [7]  0.0000000  5.0000000  0.0000000  0.3333333  1.0000000  0.3333333\n\n\nHere we see that node 3 is the highest in betweenness, pictured below:\n\n\n\n\n\nWomen lawyers advice network with highest closeness centrality node in blue and highest betweenness centrality node in red\n\n\n\n\nThis result makes sense. Node 3 intermediates all the connections linking the tightly knit group of nodes on the left side (6, 10, 11, 12) with the rest of the network. Also if nodes 5 and 7 need to pass something along to the rest, they have to use 3 at least half time. Node 4 also needs 3 to reach 6.\nThis result nicely illustrates the difference between closeness and betweenness."
  },
  {
    "objectID": "handout2.html#edge-betweenness",
    "href": "handout2.html#edge-betweenness",
    "title": "Centrality",
    "section": "Edge Betweenness",
    "text": "Edge Betweenness\nEdge betweenness is defined in similar fashion as node betweenness:\n\\[\n\\sum_{i \\neq j} \\frac{\\sigma_{i(e)j}}{\\sigma_{ij}}\n\\]\nWhere \\(\\sigma_{i(e)j}\\) is a count of the number of shortest paths between i and j that feature edge e as an intermediary link. This tells us that the betweenness of an edge e is the sum of the ratios of the number of times that edge appears in the middle of a shortest path connecting every pair of nodes in the graph i and j divided by the total number of shortest paths linking each pair of nodes.\nLike before, the edge betweenness with respect to a specific pair of nodes in the graph is a probability: Namely, that if you send something–using a shortest path–from any node i to any other node j it has to go through edge e. The resulting edge betweenness scores is the sum of these probabilities across every possible pair of nodes for each edge in the graph.\nFor this example, we will work with a simplified version of the women lawyers advice network, in which we transform it into an undirected graph. We use the igraph function as.undirected for that:\n\n   wg <- as.undirected(wg, mode = \"collapse\")\n\nThe “collapse” value in the “mode” argument tells as.undirected to link every connected dyad in the original directed graph using an undirected edge. It does that by removing the directional arrow of the single directed links and collapsing (hence the name) all the bi-directional links into a single undirected one.\nThe resulting undirected graph looks like this:\n\n\n\n\n\nLooking at this point and line plot of the women lawyers advice network, which edge do you think has the top betweenness?\nWell no need to figure that out via eyeballing! We can just use the igraph function edge_betweenness:\n\n   w.ebet <- edge_betweenness(wg)\n\nThe edge_betweenness function takes the igraph graph object as input and produces a vector of edge betweenness values of the same length as the number of edges in the graph, which happens to be 20 in this case.\nUsing this information, we can then create a table of the top ten edges ordered by betweenness:\n\n   edges <- as_edgelist(wg) #creating an edgelist\n   etab <- data.frame(edges, bet = round(w.ebet, 2)) #adding bet. scores to edgelist\n   etab <- etab[order(etab$bet, decreasing = TRUE), ] #ordering by bet.\n   kbl(etab[1:10, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Bet.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Betweenness in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nEdges Sorted by Betweenness in the Women Lawyers Advice Network\n \n  \n    i \n    j \n    Edge Bet. \n  \n \n\n  \n    3 \n    4 \n    19.17 \n  \n  \n    5 \n    8 \n    15.83 \n  \n  \n    3 \n    5 \n    13.67 \n  \n  \n    5 \n    7 \n    11.00 \n  \n  \n    2 \n    4 \n    9.17 \n  \n  \n    3 \n    11 \n    8.33 \n  \n  \n    5 \n    6 \n    8.17 \n  \n  \n    1 \n    4 \n    7.00 \n  \n  \n    2 \n    8 \n    6.50 \n  \n  \n    8 \n    9 \n    6.33 \n  \n\n\n\n\n\nNot surprisingly, the top edges are the ones linking nodes 3 and 4 and nodes 5 and 8.\n\nDisconnecting a Graph Via Bridge Removal\nHigh betweenness edges are likely to function as bridges being the only point of indirect connectivity between most nodes in the social structure. That means that an easy way to disconnect a connected graph is to remove the bridges (Girvan and Newman 2002).\nIn igraph we can produce an edge deleted subgraph of an original graph using the “minus” operator, along with the edge function like this:\n\n   del.g <- wg - edge(\"3|4\")\n   del.g <- del.g - edge(\"5|8\")\n\nThe first line creates a new graph object (a subgraph) which equals the original graph minus the edge linking nodes 3 and 4. The second line takes this last subgraph and further deletes the edge linking nodes 5 and 8.\nThe resulting subgraph, minus the top two high-betweenness edges, looks like:\n\n\n\n\n\nWhich is indeed disconnected!"
  },
  {
    "objectID": "handout2.html#degree-centrality",
    "href": "handout2.html#degree-centrality",
    "title": "Centrality",
    "section": "Degree Centrality",
    "text": "Degree Centrality\nDegree centrality is the simplest and most straightforward measure. In fact, we are already computed in handout 1 since it is the same as obtaining the graph’s degree sequence. So the igraph function degree would do it as we already saw.\nHere we follow a different approach using the row (or column) sums of the graph’s adjacency matrix:\n\n   A <- as_adjacency_matrix(g)\n   A <- as.matrix(A)\n   rowSums(A)\n\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n              7               2              17               5               2 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n              4               1               3               2               3 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n              8               3               4              16               4 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n              5              10               6               3              11 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n              5               5               3               3               8 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n              3               6               2               1               2 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n              3              25               4               3               5 \n      YOUNG MAN     YOUNG WOMAN             ZED \n              4               4               2 \n\n\nThe igraph function as_adjancency_matrix doesn’t quite return a regular R matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the as.matrix function in line 2. Then we can apply the native rowSums function to obtain each node’s degree. Note that this is same output we got using the degree function before."
  },
  {
    "objectID": "handout2.html#harmonic-centrality",
    "href": "handout2.html#harmonic-centrality",
    "title": "Centrality",
    "section": "Harmonic Centrality",
    "text": "Harmonic Centrality\nBut dont’ worry there’s a patch. It is called the harmonic centrality, a kind of closeness centrality that works whether you are working with connected or disconnected graphs (or in the case of directed graphs regardless of whether the graph is strongly or weakly connected), and therefore regardless of whether the geodesic distance matrix contains Infs.\nSome people (Boldi and Vigna 2014) claim that the harmonic centrality is the only centrality measure that could be called by that name from a purely axiomatic mathematical approach, but that’s a different story.\nThe main difference between the harmonic and regular closeness centrality is that instead of calculating the inverse of the sum of the distances for each node, we calculate the sum of the inverses:\n\n   S <- distances(wg, mode = \"out\")\n   S = round(1/S, 2) \n   diag(S) <- 0 #setting diagonals to zero\n   S\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,] 0.00 1.00  0.0 0.00    0  0.0    0  0.0 0.00     0     0   0.0\n [2,] 1.00 0.00  0.0 0.00    0  0.0    0  0.0 0.00     0     0   0.0\n [3,] 0.50 0.50  0.0 1.00    0  1.0    0  0.0 0.00     0     0   0.0\n [4,] 1.00 1.00  1.0 0.00    0  0.5    0  0.0 0.00     0     0   0.0\n [5,] 0.33 0.50  1.0 0.50    0  1.0    1  1.0 0.50     0     0   0.0\n [6,] 0.33 0.33  1.0 0.50    0  0.0    0  0.0 0.00     0     0   0.0\n [7,] 0.25 0.33  0.5 0.33    1  0.5    0  0.5 0.33     0     0   0.0\n [8,] 0.50 1.00  0.0 0.00    0  0.0    0  0.0 1.00     0     0   0.0\n [9,] 0.50 1.00  0.0 0.00    0  0.0    0  1.0 0.00     0     0   0.0\n[10,] 0.33 0.33  1.0 0.50    0  1.0    0  0.0 0.00     0     1   0.5\n[11,] 0.33 0.33  1.0 0.50    0  0.5    0  0.0 0.00     1     0   1.0\n[12,] 0.33 0.33  1.0 0.50    0  1.0    0  0.0 0.00     1     1   0.0\n\n\nNote that in this matrix of inverse distances, the closest (adjacent) nodes get the maximum score of one, and nodes farther apart when smaller scores (approaching zero). More importantly, those pesky Infs disappear (!) because unreachable directed pairs of nodes get the lowest score, corresponding to \\(1/\\infty = 0\\). Turns out the mathematics of infinity weren’t our enemy after all.\nAlso note that the reachability relation expressed in this matrix is asymmetric: So node 4 and reach node 1 (there is a directed tie from 4 to 1), but node 1 cannot reach 4. This is precisely what we want.\nOnce we have this matrix of inverse distances, we can then we can compute the harmonic centrality the same way as regular closeness by adding up the row scores for each node and dividing by the number of nodes minus one (to get the average):\n\n   d.harm <- rowSums(S)\n   d.harm <- d.harm/(vcount(wg) - 1)\n   d.harm <- round(d.harm, 2)\n   d.harm\n\n [1] 0.09 0.09 0.27 0.32 0.53 0.20 0.34 0.23 0.23 0.42 0.42 0.47\n\n\nWe can see that the highest harmonic closeness centrality node is 5, followed by 12. Here’s a plot of the network highlighting the highest harmonic (closeness) centrality node.\n\n   col <- rep(\"tan2\", vcount(wg)) #creating node color vector\n   col[which(d.harm == max(d.harm))] <- \"red\" #changing color of max centrality node to red\n   p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = col)\n   p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = \"white\")\n   p\n\n\n\n\nWomen lawyers advice network with highest closeness centrality node in red\n\n\n\n\nOf course, igraph has a built in function to calculate the harmonic centrality called (you guessed it) harmonic_centrality:\n\n   d.harm <- harmonic_centrality(wg, normalized = TRUE)\n   d.harm <- round(d.harm, 2)\n   d.harm\n\n [1] 0.09 0.09 0.27 0.32 0.53 0.20 0.34 0.23 0.23 0.42 0.42 0.47\n\n\nWhich gives us the same results."
  },
  {
    "objectID": "handout2.html#betweenness-as-an-induced-centrality",
    "href": "handout2.html#betweenness-as-an-induced-centrality",
    "title": "Centrality",
    "section": "Betweenness as an Induced Centrality",
    "text": "Betweenness as an Induced Centrality\nIn the assigned handbook chapter reading, Borgatti and Everett argue that another way of thinking about centrality of a node (or edge) is to calculate the difference that removing that node makes for some graph property in the network. In the case of betweenness that property is the number of shortest paths linking each pair of nodes.\nWe will use the undirected version of the women lawyers advice network for this example. We first need to calculate a matrix containing the number of shortest paths linking each pair of nodes. The igraph function all_shortest_paths can be used to do the job. Let us see how it works:\n\n   nsp <- all_shortest_paths(wg, from = 7, to = 1)\n   nsp$res\n\n[[1]]\n+ 5/12 vertices, from ed1cc14:\n[1] 7 5 8 2 1\n\n[[2]]\n+ 5/12 vertices, from ed1cc14:\n[1] 7 5 3 4 1\n\n\nThe all_shortest_paths takes three arguments: The igraph graph object, the starting node in the path (“from”) and the end node in the path (“to”). It returns an R list object as output. One of the elements of the list is called “res.” We can see that this is a sub-list, which each element listing the nodes in each of the shortest paths linking nodes 7 and 1 (in this example). The length of the res sublist gives us the number of shortest paths connecting the nodes, which in this case is 2.\nSo to produce a matrix with the number of shortest paths linking every pair of nodes in the graph, we just loop through each pair of nodes in the graph and compute the length of the all res sub list produced by all_shortest_paths:\n\n   W <- matrix(0, vcount(wg), vcount(wg)) #creating empty matrix\n   for (i in 1:vcount(wg)) {\n      for (j in 1:vcount(wg)) {\n         W[i, j] <- length(all_shortest_paths(wg, from = i, to = j)$res)\n      }\n   }\n   W\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,]    1    1    1    1    2    1    2    1    1     1     1     1\n [2,]    1    1    1    1    1    2    1    1    1     1     1     1\n [3,]    1    1    1    1    1    1    1    1    2     1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1     1\n [5,]    2    1    1    1    1    1    1    1    1     2     1     2\n [6,]    1    2    1    1    1    1    1    1    1     1     3     1\n [7,]    2    1    1    1    1    1    1    1    1     2     1     2\n [8,]    1    1    1    1    1    1    1    1    1     2     1     2\n [9,]    1    1    2    1    1    1    1    1    1     3     2     3\n[10,]    1    1    1    1    2    1    2    2    3     1     1     1\n[11,]    1    1    1    1    1    3    1    1    2     1     1     1\n[12,]    1    1    1    1    2    1    2    2    3     1     1     1\n\n\nIn fact, we like this so much, that we will turn the code above into an R custom function called “nsp”, so that we can use it with any graph object:\n\n   nsp <- function(x) {\n      W <- matrix(0, vcount(x), vcount(x)) #creating empty matrix\n      for (i in 1:vcount(x)) {\n         for (j in 1:vcount(x)) {\n            W[i, j] <- length(all_shortest_paths(x, from = i, to = j)$res)\n         }\n      }\n   return(W)\n   }\n\nOur custom function takes the igraph graph object as input and returns the shortest paths matrix as output.\nNow to create our induced centrality measure a la Borgatti & Everett all we need to do is figure out the difference node makes for the entries in the shortest paths matrix when it is removed from the graph. Let’s take node 5 as an example:\n\n   W <- nsp(wg)\n   W <- W[-5, -5]\n   wg.d <- wg - vertex(\"5\")\n   W.d <- nsp(wg.d)\n   i.bet <- sum((W - W.d)/W)\n   round(i.bet, 1)\n\n[1] 27.7\n\n\nThe positive number means that node 5 is pretty important for the indirect connectivity of others in the graph, as removing it kills about 28% of the shortest paths between nodes in the orginal graph.\nNow all we need to do is do the same for each node:\n\n   b <- 0\n   for (i in 1:vcount(wg)) {\n      W <- nsp(wg)\n      W <- W[-i, -i]\n      wg.d <- wg - vertex(as.character(i))\n      W.d <- nsp(wg.d)\n      i.bet <- sum((W - W.d)/W)\n      b[i] <- round(i.bet, 1)\n   }\n   b\n\n [1]  0.0  5.3  0.3 -1.7 27.7  7.3  0.0  7.7  0.0  0.7  0.0  0.7\n\n\nWe can now list these induced node betweenness centralities using a nice table:\n\n   i.bet <- data.frame(n = 1:vcount(wg), b, betweenness(wg))\n   kbl(i.bet, format = \"pipe\", align = c(\"l\", \"c\", \"c\"),\n       col.names = c(\"Node\", \"Induced Bet.\", \"Reg. Bet.\"), row.names = FALSE,\n       caption = \"Induced Betweenness Scores in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nInduced Betweenness Scores in the Women Lawyers Advice Network\n \n  \n    Node \n    Induced Bet. \n    Reg. Bet. \n  \n \n\n  \n    1 \n    0.0 \n    0.0000000 \n  \n  \n    2 \n    5.3 \n    6.6666667 \n  \n  \n    3 \n    0.3 \n    23.1666667 \n  \n  \n    4 \n    -1.7 \n    12.1666667 \n  \n  \n    5 \n    27.7 \n    18.8333333 \n  \n  \n    6 \n    7.3 \n    3.6666667 \n  \n  \n    7 \n    0.0 \n    0.0000000 \n  \n  \n    8 \n    7.7 \n    8.8333333 \n  \n  \n    9 \n    0.0 \n    0.0000000 \n  \n  \n    10 \n    0.7 \n    0.3333333 \n  \n  \n    11 \n    0.0 \n    0.0000000 \n  \n  \n    12 \n    0.7 \n    0.3333333 \n  \n\n\n\n\n\n```"
  },
  {
    "objectID": "handout2.html#induced-betweenness",
    "href": "handout2.html#induced-betweenness",
    "title": "Centrality",
    "section": "Induced Betweenness",
    "text": "Induced Betweenness\nIn the assigned handbook chapter reading, Borgatti and Everett argue that another way of thinking about centrality of a node (or edge) is to calculate the difference that removing that node makes for some graph property in the network. They further suggest that the sum of the centrality scores of each node is just such a property, proposing that betweenness is particularly interesting in this regard. Let’s see how this works.\nWe will use the undirected version of the women lawyers advice network for this example. Let’s say we are interested in the difference that node 10 makes for the betweenness centralities of everyone else. In that case we would proceed as follows:\n\n   bet <- betweenness(wg) #original centrality scores\n   Sbet <- sum(bet) #sum of original centrality scores\n   wg.d <- wg - vertex(\"10\") #removing vertex 10 from the graph\n   bet.d <- betweenness(wg.d) #centrality scores of node deleted subgraph\n   Sbet.d <- sum(bet.d) #sum of centrality scores of node deleted subgraph\n   total.c <- Sbet - Sbet.d #total centrality\n   indirect.c <- total.c - bet[10] #indirect centrality\n   indirect.c\n\n[1] 12.66667\n\n\nLine 1 just calculates the regular betweenness centrality vector for the graph. Line 2 sums up all of the entries of this vector. Line 3 creates a node deleted subgraph by removing node 10. This is done using the “minus” operator and the igraph function vertex, which works just like the edge function we used earlier to create an edge deleted subgraph, except it takes a node id or name as input.\nLines 4-5 just recalculate the sum of betweenness centralities in the subgraph that excludes node 10. Then in line 6 we subtract the sum of centralities of the node deleted subgraph from the sum of centralities of the original graph. If this number, which Borgatti and Everett call the “total” centrality, is large and positive then that means that node 10 makes a difference for the centrality of others.\nHowever, part of that difference is node 10’s own “direct” centrality, so to get a more accurate sense of node 10’s impact on other people’s centrality we need to subtract node 10’s direct centrality from the total number, which we do in line 7 to get node 10’s “indirect” centrality. The result is shown in the last line, which indicates that node 10 has a pretty big impact on other people’s betweenness centralities, net of their own (which is pretty small).\nNow all we need to do is do the same for each node to create a vector of indirect betweenness centralities. So we incorporate the code above into a short loop through all vertices:\n\n   total.c <- 0 #empty vector\n   indirect.c <- 0 #empty vector\n   for (i in 1:vcount(wg)) {\n      wg.d <- wg - vertex(i)\n      bet.d <- betweenness(wg.d) #centrality scores of node deleted subgraph\n      Sbet.d <- sum(bet.d) #sum of centrality scores of node deleted subgraph\n      total.c[i] <- Sbet - Sbet.d #total centrality\n   indirect.c[i] <- total.c[i] - bet[i] #total minus direct\n   }\n\nWe can now list the total, direct, and indirect betweenness centralities for the women lawyers graph using a nice table:\n\n   i.bet <- data.frame(n = 1:vcount(wg), total.c, round(betweenness(wg), 1), round(indirect.c, 1))\n   kbl(i.bet, format = \"pipe\", align = c(\"l\", \"c\", \"c\", \"c\"),\n       col.names = c(\"Node\", \"Total\", \"Direct\", \"Indirect\"), row.names = FALSE,\n       caption = \"Induced Betweenness Scores in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nInduced Betweenness Scores in the Women Lawyers Advice Network\n \n  \n    Node \n    Total \n    Direct \n    Indirect \n  \n \n\n  \n    1 \n    16 \n    0.0 \n    16.0 \n  \n  \n    2 \n    4 \n    6.7 \n    -2.7 \n  \n  \n    3 \n    -24 \n    23.2 \n    -47.2 \n  \n  \n    4 \n    -4 \n    12.2 \n    -16.2 \n  \n  \n    5 \n    19 \n    18.8 \n    0.2 \n  \n  \n    6 \n    10 \n    3.7 \n    6.3 \n  \n  \n    7 \n    18 \n    0.0 \n    18.0 \n  \n  \n    8 \n    4 \n    8.8 \n    -4.8 \n  \n  \n    9 \n    18 \n    0.0 \n    18.0 \n  \n  \n    10 \n    13 \n    0.3 \n    12.7 \n  \n  \n    11 \n    14 \n    0.0 \n    14.0 \n  \n  \n    12 \n    13 \n    0.3 \n    12.7 \n  \n\n\n\n\n\nThis approach to decomposing betweenness centrality provides a new way to categorize actors in a network:\n\nOn the one hand, we have actors like nodes 3 and 4 who “hog” centrality from others. Perhaps these are the prototypical high betweenness actors who monopolize the flow through the network. Their own direct centrality is high, but their indirect centrality is negative, suggesting that others become more central when they are removed from the graph as they can now become intermediaries themselves.\nIn contrast, we also have actors like node 5 who are high centrality themselves, but who’s removal from the network does not affect anyone else’s centrality. These actors are high betweenness but themselves don’t monopolize the flow of information in the network.\nThen we have actors (like nodes 9-12) who have low centrality, but whose removal from the network makes a positive difference for other people’s centrality, which overall decreases when they are removed from the network.\nFinally, we have actors line nodes 2 and 8, who are not particularly central, but who also hog centrality from others, in that removing them from the network also increases other people’s centrality (although not such an extent as the hogs)."
  },
  {
    "objectID": "handout1.html",
    "href": "handout1.html",
    "title": "Basic Network Statistics",
    "section": "",
    "text": "Here we will analyze a small network and computer some basic statistics of interst. The first thing we need to do is get some data! For this purpose, we will use the package networkdata (available here). To install the package, use the following code:\n\n   #install.packages(\"remotes\") \n   remotes::install_github(\"schochastics/networkdata\")\n\nTo load the network datasets in the networkdata just type:\n\n   library(networkdata)\n\nThe package contains a bunch of human and animal social networks to browse through them, type:\n\n   data(package = \"networkdata\")\n\nWe will pick one of the movies for this analysis, namely, Pulp Fiction. This is movie_559. In the movie network two characters are linked by an edge if they appear in a scene together. The networkdata data sets come in igraph format, so we need to load that package (or install it using install.packages if you haven’t done that yet).\n\n   #install.packages(\"igraph\") \n   library(igraph)\n   g <- movie_559"
  },
  {
    "objectID": "handout1.html#number-of-nodes-and-edges",
    "href": "handout1.html#number-of-nodes-and-edges",
    "title": "Basic Network Statistics",
    "section": "Number of Nodes and Edges",
    "text": "Number of Nodes and Edges\nNow we are ready to compute some basic network statistics. As with any network, we want to know what the number of nodes and the number of edges (links) are. Since this is a relatively small network, we can begin by listing the actors.\n\n   V(g)\n\n+ 38/38 vertices, named, from 9e7cc7a:\n [1] BRETT           BUDDY           BUTCH           CAPT KOONS     \n [5] ED SULLIVAN     ENGLISH DAVE    ESMARELDA       FABIENNE       \n [9] FOURTH MAN      GAWKER #2       HONEY BUNNY     JIMMIE         \n[13] JODY            JULES           LANCE           MANAGER        \n[17] MARSELLUS       MARVIN          MAYNARD         MIA            \n[21] MOTHER          PATRON          PEDESTRIAN      PREACHER       \n[25] PUMPKIN         RAQUEL          ROGER           SPORTSCASTER #1\n[29] SPORTSCASTER #2 THE GIMP        THE WOLF        VINCENT        \n[33] WAITRESS        WINSTON         WOMAN           YOUNG MAN      \n[37] YOUNG WOMAN     ZED            \n\n\nThe function V takes the igraph network object as input and returns an igraph.vs object as output (short for “igraph vertex sequence”), listing the names (if given as a graph attribute) of each node. The first line also tells us that there are 38 nodes in this network.\nThe igraph.vs object operates much like an R character vector, so we can query its length to figure out the number of nodes:\n\n   length(V(g))\n\n[1] 38\n\n\nThe analogue function for edges in igraph is E which also takes the network object as input and returns an object of class igraph.es (“igraph edge sequence”) as output:\n\n   E(g)\n\n+ 102/102 edges from 9e7cc7a (vertex names):\n [1] BRETT      --MARSELLUS       BRETT      --MARVIN         \n [3] BRETT      --ROGER           BRETT      --VINCENT        \n [5] BUDDY      --MIA             BUDDY      --VINCENT        \n [7] BRETT      --BUTCH           BUTCH      --CAPT KOONS     \n [9] BUTCH      --ESMARELDA       BUTCH      --GAWKER #2      \n[11] BUTCH      --JULES           BUTCH      --MARSELLUS      \n[13] BUTCH      --PEDESTRIAN      BUTCH      --SPORTSCASTER #1\n[15] BUTCH      --ENGLISH DAVE    BRETT      --FABIENNE       \n[17] BUTCH      --FABIENNE        FABIENNE   --JULES          \n[19] FOURTH MAN --JULES           FOURTH MAN --VINCENT        \n+ ... omitted several edges\n\n\nThis tells us that there are 102 edges (connected dyads) in the network. Some of these include Brett and Marsellus and Fabienne and Jules, but not all can be listed for reasons of space.\nigraph also has two dedicated functions that return the number of nodes and edges in the graph in one fell swoop. They are called vcount and ecount and take the graph object as input:\n\n   vcount(g)\n\n[1] 38\n\n   ecount(g)\n\n[1] 102"
  },
  {
    "objectID": "handout1.html#graph-density",
    "href": "handout1.html#graph-density",
    "title": "Basic Network Statistics",
    "section": "Graph Density",
    "text": "Graph Density\nOnce we have the number of edges and nodes, we can calculate the most basic derived statistic in a network, which is the density. Since the movie network is an undirected graph, the density is given by:\n\\[\n   \\frac{2m}{n(n-1)}\n\\]\nWhere \\(m\\) is the number of edges and \\(n\\) is the number of nodes, or in our case:\n\n   (2 * 102) / (38 * (38 - 1))\n\n[1] 0.1450925\n\n\nOf course, igraph has a dedicated function called edge_density to compute the density too, which takes the igraph object as input:\n\n   edge_density(g)\n\n[1] 0.1450925"
  },
  {
    "objectID": "handout1.html#degree",
    "href": "handout1.html#degree",
    "title": "Basic Network Statistics",
    "section": "Degree",
    "text": "Degree\nThe next set of graph metrics are based on the degree of the graph. We can list the graph’s degree set using the igraph function degree:\n\n   degree(g)\n\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n              7               2              17               5               2 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n              4               1               3               2               3 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n              8               3               4              16               4 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n              5              10               6               3              11 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n              5               5               3               3               8 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n              3               6               2               1               2 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n              3              25               4               3               5 \n      YOUNG MAN     YOUNG WOMAN             ZED \n              4               4               2 \n\n\nThe degree function takes the igraph network object as input and returns a plain old R named vector as output with the names being the names attribute of vertices in the network object.\nUsually we are interested in who are the “top nodes” in the network by degree (a kind of centrality). To figure that out, all we need to do is sort the degree set (to generate the graph’s degree sequence) and list the top entries:\n\n   d <- degree(g)\n   d.sort <- sort(d, decreasing = TRUE)\n   d.sort[1:8]\n\n    VINCENT       BUTCH       JULES         MIA   MARSELLUS HONEY BUNNY \n         25          17          16          11          10           8 \n    PUMPKIN       BRETT \n          8           7 \n\n\nLine 1 stores the degrees in an object “d”, line 2 creates a “sorted” version of the same object (from bigger to smaller) and line 3 shows the first eight entries of the sorted degree sequence.\nBecause the degree vector “d” is just a regular old vector we can use native R mathematical operations to figure out things like the sum, maximum, minimum, and average degree of the graph:\n\n   sum(d)\n\n[1] 204\n\n   max(d)\n\n[1] 25\n\n   min(d)\n\n[1] 1\n\n   mean(d)\n\n[1] 5.368421\n\n\nSo the sum of degrees is 204, the maximum degree is 25 (belonging to Vincent), the minimum is one, and the average is about 5.4.\nNote that these numbers recreate some well-known equalities in graph theory:\n\nThe sum of degrees is twice the number of edges (the first theorem of graph theory):\n\n\n   2 * ecount(g)\n\n[1] 204\n\n\n\nThe average degree is just the sum of degrees divided by the number of nodes:\n\n\n   sum(d)/vcount(g)\n\n[1] 5.368421\n\n\n\nThe density is just the average degree divided by the number of nodes minus one, as explained here:\n\n\n   mean(d)/(vcount(g) - 1)\n\n[1] 0.1450925\n\n\nSome people also consider the degree variance of the graph as a measure of inequality of connectivity in the system. It is equal to the average sum of square deviations of each node’s degree from the average:\n\\[\n  \\mathcal{v}(G) = \\frac{\\sum_i (k_i - \\bar{k})^2}{n}\n\\]\n\n   sum((d - mean(d))^2)/vcount(g)\n\n[1] 22.96953\n\n\nThis tells us that there is a lot of inequality in the distribution of degrees in the graph (a graph with all nodes equal degree would have variance zero)."
  },
  {
    "objectID": "handout1.html#the-degree-distribution",
    "href": "handout1.html#the-degree-distribution",
    "title": "Basic Network Statistics",
    "section": "The Degree Distribution",
    "text": "The Degree Distribution\nAnother way of looking at inequalities of degrees in a graph is to examine its degree distribution. This gives us the probability of observing a node with a given degree k in the graph.\n\n   deg.dist <- degree_distribution(g)\n   deg.dist <- round(deg.dist, 3)\n   deg.dist\n\n [1] 0.000 0.053 0.158 0.237 0.158 0.132 0.053 0.026 0.053 0.000 0.026 0.026\n[13] 0.000 0.000 0.000 0.000 0.026 0.026 0.000 0.000 0.000 0.000 0.000 0.000\n[25] 0.000 0.026\n\n\nThe igraph function degree_distribution just returns a numeric vector of the same length as the maximum degree of the graph plus one. In this case that’s a vector of length 25 + 1 = 26. The first entry gives us the proportion of nodes with degree zero (isolates), the second the proportion of nodes of degree one, and so on up to the graph’s maximum degree.\nSince there are no isolates in the network, we can ignore the first element of this vector, to get the proportion of nodes of each degree in the Pulp Fiction network. To that, we fist create a two-column data.frame with the degrees in the first column and the proportions in the second:\n\n   degree <- c(1:25)\n   prop <- deg.dist\n   prop <- prop[-1]\n   deg.dist <- data.frame(degree, prop)\n   deg.dist\n\n   degree  prop\n1       1 0.053\n2       2 0.158\n3       3 0.237\n4       4 0.158\n5       5 0.132\n6       6 0.053\n7       7 0.026\n8       8 0.053\n9       9 0.000\n10     10 0.026\n11     11 0.026\n12     12 0.000\n13     13 0.000\n14     14 0.000\n15     15 0.000\n16     16 0.026\n17     17 0.026\n18     18 0.000\n19     19 0.000\n20     20 0.000\n21     21 0.000\n22     22 0.000\n23     23 0.000\n24     24 0.000\n25     25 0.026\n\n\nOf course, a better way to display the degree distribution of a graph is via some kind of data visualization, particularly for large networks where a long table of numbers is just not feasible. To do that, we can call on our good friend ggplot:\n\n   # install.packages(ggplot2)\n   library(ggplot2)\n   p <- ggplot(data = deg.dist, aes(x = degree, y = prop))\n   p <- p + geom_bar(stat = \"identity\", fill = \"red\", color = \"red\")\n   p <- p + theme_minimal()\n   p <- p + labs(x = \"\", y = \"Proportion\", \n                 title = \"Degree Distribution in Pulp Fiction Network\") \n   p <- p + geom_vline(xintercept = mean(d), \n                       linetype = 2, linewidth = 0.5, color = \"blue\")\n   p <- p + scale_x_continuous(breaks = c(1, 5, 10, 15, 20, 25))\n   p\n\n\n\n\nThe plot clearly shows that the Pulp Fiction network degree distribution is skewed with a small number of characters having a large degree \\(k \\geq 15\\) while most other characters in the movie have a small degree \\(k \\leq 5\\) indicating inequality of connectivity in the system."
  },
  {
    "objectID": "handout1.html#the-degree-correlation",
    "href": "handout1.html#the-degree-correlation",
    "title": "Basic Network Statistics",
    "section": "The Degree Correlation",
    "text": "The Degree Correlation\nAnother overall network statistic we may want to know is the degree correlation (Newman 2002). How do we compute it? Imagine taking each edge in the network and creating two degree vectors, one based on the degree of the node in one end and the degre of the node in another. Then the degree assortativity coefficient is just the Pearson product moment correlation between these two vectors.\nLet’s see how this would work for the Pulp Fiction network. First we need to extract an edge list from the graph:\n\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   head(g.el)\n\n     [,1]    [,2]       \n[1,] \"BRETT\" \"MARSELLUS\"\n[2,] \"BRETT\" \"MARVIN\"   \n[3,] \"BRETT\" \"ROGER\"    \n[4,] \"BRETT\" \"VINCENT\"  \n[5,] \"BUDDY\" \"MIA\"      \n[6,] \"BUDDY\" \"VINCENT\"  \n\n\nWe can see that the as_edgelist function takes the igraph network object as input and returns an \\(E \\times 2\\) matrix, with \\(E = 102\\) being the number of rows. Each column of the matrix records the name of the node on each end of the edge. So the first row of the edge list with entries “BRETT” and “MARSELLUS” tells us that there is an edge linking Brett and Marsellus, and so forth for each row.\nTo compute the correlation between the degrees of each node, all we need to do is attach the corresponding degrees to each name for each of the columns of the edge list, which can be done via data wrangling magic from the dplyr package (part of the tidyverse):\n\n   # install.packages(dplyr)\n   library(dplyr)\n   deg.dat <- data.frame(name1 = names(d), name2 = names(d), d)\n   el.temp <- data.frame(name2 = g.el[, 2]) %>% \n      left_join(deg.dat, by = \"name2\") %>% \n      dplyr::select(c(\"name2\", \"d\")) %>% \n      rename(d2 = d) \n   d.el <- data.frame(name1 = g.el[, 1]) %>% \n      left_join(deg.dat, by = \"name1\") %>% \n      dplyr::select(c(\"name1\", \"d\")) %>% \n      rename(d1 = d) %>% \n      cbind(el.temp)\nhead(d.el)\n\n  name1 d1     name2 d2\n1 BRETT  7 MARSELLUS 10\n2 BRETT  7    MARVIN  6\n3 BRETT  7     ROGER  6\n4 BRETT  7   VINCENT 25\n5 BUDDY  2       MIA 11\n6 BUDDY  2   VINCENT 25\n\n\nLine 3 creates a two-column data frame called “deg.dat” with as many rows as there are nodes in the network. The first two columns contain the names of each node (identically listed with different names) and the third columns contains the corresponding node’s degree.\nLines 4-7 use dplyr functions to create a new object “el.temp” joining the degree information to each of the node names listed in the second position in the original edge list “g.el,” and rename the imported column of degrees “d2.”\nLines 8-12 do the same for the nodes listed in the first position in the original edge list, renames the imported columns of degrees “d1,” and the binds the columns of the “el.temp” object to the new object “d.el.” The resulting object has four columns: Two for the names of the nodes incident to each edge on the edge list (columns 1 and 3), and two other ones corresponding to the degrees of the corresponding nodes (columns 2 and 4).\nWe can see from the output of the first few rows of the “d.el” object that indeed “BRETT” is assigned a degree of 7 in each row of the edge list, “BUDDY” a degree of 2, “MARSELLUS” a degree of 10, “VINCENT” a degree of 25 and so forth.\nNow to compute the degree correlation in the network all we need to do is call the native R function cor on the two columns from “d.el” that containing the degree information. Note that because each degree appears twice at the end of each edge in an undirected graph (as both “sender” and “receiver”), we need to double each column by appending the other degree column at the end. So the first degree column is the vector:\n\n   d1 <- c(d.el$d1, d.el$d2)\n\nAnd the second degree column is the vector:\n\n   d2 <- c(d.el$d2, d.el$d1)\n\nAnd the graph’s degree correlation (Newman 2003) is just the Pearson correlation between these two degree vectors:\n\n   cor(d1, d2)\n\n[1] -0.2896427\n\n\nThe result \\(r_{deg} = -0.29\\) tells us that there is anti-correlation by degree in the Pulp Function network. That is high-degree characters tend to appear with low degree characters, or conversely, high-degree characters (like Marsellus and Jules) don’t appear together very often.\n\n   assortativity_degree(g)\n\n[1] -0.2896427"
  },
  {
    "objectID": "handout1.html#the-average-shortest-path-length",
    "href": "handout1.html#the-average-shortest-path-length",
    "title": "Basic Network Statistics",
    "section": "The Average Shortest Path Length",
    "text": "The Average Shortest Path Length\nThe final statistic people use to characterize networks is the average shortest path length. In a network, even nodes that are not adjacent, could be indirectly connected to other nodes via a path of some length. So it is useful to know what the average of this quantity is across all dyads in the network. To do that, we first need to compute the length of the shortest path \\(l\\) for each pair of nodes in the network (also known as the geodesic distance). Adjacent nodes get an automatic score of \\(l = 1\\). In igraph this is done as follows:\n\n   S <- distances(g)\n   S[1:7, 1:7]\n\n             BRETT BUDDY BUTCH CAPT KOONS ED SULLIVAN ENGLISH DAVE ESMARELDA\nBRETT            0     2     1          2           2            2         3\nBUDDY            2     0     2          2           2            2         4\nBUTCH            1     2     0          1           2            1         2\nCAPT KOONS       2     2     1          0           2            2         3\nED SULLIVAN      2     2     2          2           0            2         4\nENGLISH DAVE     2     2     1          2           2            0         3\nESMARELDA        3     4     2          3           4            3         0\n\n\nThe igraph function distances takes the network object as input and returns the desired shortest path matrix. So for instance, Brett is directly connected to Butch (they appear in a scene together) but indirectly connected to Buddy via a path of length two (they both appear in scenes with common neighbors even if they don’t appear together).\nThe maximum distance between two nodes in the graph (the longest shortest path to put it confusingly) is called the graph diameter. We can find this out simply by using the native R function for the maximum on the shortest paths matrix:\n\n   max(S)\n\n[1] 8\n\n\nThis means that in the Pulp Fiction network the maximum degree of separation between two characters is a path of length 8.\nOnce we have the geodesic distance matrix, it is easy to calculate the average path length of the graph:\n\n   rs.S <- rowSums(S)\n   rm.S <- rs.S/(vcount(g) - 1)\n   mean(rm.S)\n\n[1] 2.769559\n\n\n\nFirst (line 1) we sum all the rows (or columns) of the geodesic distance matrix. This vector (of the same length as the number of nodes) gives us the sum of the geodesic distance of each node to each of the nodes (we will use this to compute closeness centrality later).\nThen (line 2) we divide this vector by the number of nodes minus one (to exclude the focal node) to create a vector of the average distance of each node to each of the other nodes.\nFinally (line 3) we take the average across all nodes of this average distance vector to get the graph’s average shortest path length, which in this case equals L = 2.8.\n\nThis means that, on average, each character in Pulp Fiction is separated by little less than three contacts in the co-appearance network (a fairly small world).\nOf course this can also be done in just one step on igraph:\n\n   mean_distance(g)\n\n[1] 2.769559"
  },
  {
    "objectID": "handout1.html#putting-it-all-together",
    "href": "handout1.html#putting-it-all-together",
    "title": "Basic Network Statistics",
    "section": "Putting it all Together",
    "text": "Putting it all Together\nNow we can put together all the basic network statistics that we have computed into some sort of summary table, like the ones here. We first create a vector with the names of each statistic:\n\n   Stat <- c(\"Nodes\", \"Edges\", \"Min. Degree\", \"Max. Degree\", \"Avg. Degree\", \"Degree Corr.\", \"Diameter\", \"Avg. Shortest Path Length\")\n\nThen we create a vector with the values:\n\n   Value <- c(vcount(g), ecount(g), min(d), max(d), round(mean(d), 2), round(assortativity_degree(g), 2), max(S), round(mean_distance(g), 2))\n\nWe can then put these two vector together into a data frame:\n\n   net.stats <- data.frame(Stat, Value)\n\nWe can then use the package kableExtra (a nice table maker) to create a nice html table:\n\n   # intall.packages(kableExtra)\n   library(kableExtra)\n   kbl(net.stats, format = \"pipe\", align = c(\"l\", \"c\"),\n       caption = \"Key Statistics for Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n\n\n\nKey Statistics for Pulp Fiction Network.\n \n  \n    Stat \n    Value \n  \n \n\n  \n    Nodes \n    38.00 \n  \n  \n    Edges \n    102.00 \n  \n  \n    Min. Degree \n    1.00 \n  \n  \n    Max. Degree \n    25.00 \n  \n  \n    Avg. Degree \n    5.37 \n  \n  \n    Degree Corr. \n    -0.29 \n  \n  \n    Diameter \n    8.00 \n  \n  \n    Avg. Shortest Path Length \n    2.77"
  },
  {
    "objectID": "handout1.html#appendix-loading-network-data-from-a-file",
    "href": "handout1.html#appendix-loading-network-data-from-a-file",
    "title": "Basic Network Statistics",
    "section": "Appendix: Loading Network Data from a File",
    "text": "Appendix: Loading Network Data from a File\nWhen get network data from an archival source, and it will be in the form of a matrix or an edge list, typically in some kind of comma separated value (csv) format. Here will show how to input that into R to create an igraph network object from an outside file.\nFirst we will write the Pulp Fiction data into an edge list and save it to disk. We already did that earlier with the “g.el” object. So all we have to do is save it to your local folder as a csv file:\n\n   #install.packages(here)\n   library(here)\n   write.csv(d.el[c(\"name1\", \"name2\")], here(\"pulp.csv\"))\n\nThe write.csv function just saves an R object into a .csv file. Here the R object is “g.el” and we asked it to save just the columns which contain the name of each character. This represents the adjacency relations in the network as an edge list. We use the package here to keep track of our working directory. See here (pun intended) for details.\nNow suppose that’s the network we want to work with and it’s saved in our hard drive. To load it, we just type:\n\n   g.el <- read.csv(here(\"pulp.csv\"), \n                    col.names = c(\"name1\", \"name2\"))\n   head(g.el)\n\n  name1     name2\n1 BRETT MARSELLUS\n2 BRETT    MARVIN\n3 BRETT     ROGER\n4 BRETT   VINCENT\n5 BUDDY       MIA\n6 BUDDY   VINCENT\n\n\nWhich gives us the edge list we want now saved into an R object of class data.frame. So all we need is to convert that into an igraph object. To do that we use one of the many graph_from... functions in the igraph package. In this case, we want graph_from_edgelist because our network is stored as an edge list:\n\n   g.el <- as.matrix(g.el)\n   g <- graph_from_edgelist(g.el, directed = FALSE)\n   V(g)\n\n+ 38/38 vertices, named, from 024f75e:\n [1] BRETT           MARSELLUS       MARVIN          ROGER          \n [5] VINCENT         BUDDY           MIA             BUTCH          \n [9] CAPT KOONS      ESMARELDA       GAWKER #2       JULES          \n[13] PEDESTRIAN      SPORTSCASTER #1 ENGLISH DAVE    FABIENNE       \n[17] FOURTH MAN      HONEY BUNNY     MANAGER         JIMMIE         \n[21] JODY            PATRON          PUMPKIN         RAQUEL         \n[25] WINSTON         LANCE           MAYNARD         THE GIMP       \n[29] ZED             ED SULLIVAN     MOTHER          WOMAN          \n[33] PREACHER        SPORTSCASTER #2 THE WOLF        WAITRESS       \n[37] YOUNG MAN       YOUNG WOMAN    \n\n   E(g)\n\n+ 102/102 edges from 024f75e (vertex names):\n [1] BRETT      --MARSELLUS       BRETT      --MARVIN         \n [3] BRETT      --ROGER           BRETT      --VINCENT        \n [5] BUDDY      --MIA             VINCENT    --BUDDY          \n [7] BRETT      --BUTCH           BUTCH      --CAPT KOONS     \n [9] BUTCH      --ESMARELDA       BUTCH      --GAWKER #2      \n[11] BUTCH      --JULES           MARSELLUS  --BUTCH          \n[13] BUTCH      --PEDESTRIAN      BUTCH      --SPORTSCASTER #1\n[15] BUTCH      --ENGLISH DAVE    BRETT      --FABIENNE       \n[17] BUTCH      --FABIENNE        JULES      --FABIENNE       \n[19] JULES      --FOURTH MAN      VINCENT    --FOURTH MAN     \n+ ... omitted several edges\n\n\nWhich gives us back the original igraph object we have been working with. Note that first we converted the data.frame object into a matrix object. We also specified that the graph is undirected by setting the option directed to false."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Social Networks Sequence",
    "section": "",
    "text": "Website containing syllabi, reading schedules, and other instructional materials for the courses in the Social Network Analysis computational sequence (208A & 208B) at UCLA Sociology."
  }
]