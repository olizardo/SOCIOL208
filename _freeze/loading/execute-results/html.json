{
  "hash": "cb40d874054ac9cfde26bc95d2358d9b",
  "result": {
    "markdown": "---\ntitle: \"Loading Network Data from a File\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nWhen get network data from an archival source, and it will be in the form of a **matrix** or an **edge list**, typically in some kind of comma separated value (csv) format. Here will show how to input that into `R` to create an `igraph` network object from an outside file.\n\nFirst we will write the *Pulp Fiction* data into an edge list and save it to your local folder as a csv file.\n\nFirst, let's load the data and transform it into an edgelist:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(igraph)\n   library(networkdata)\n   g <- movie_559 #pulp fiction data\n   #install.packages(here)\n   library(here)\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   names(g.el) <- c(\"name1\", \"name2\")\n```\n:::\n\n\nNow, let's write it into disk:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   write.csv(g.el, here(\"pulp.csv\"))\n```\n:::\n\n\nThe `write.csv` function just saves an `R` object into a .csv file. Here the `R` object is \"g.el\" and we asked it to save just the columns which contain the name of each character. This represents the adjacency relations in the network as an edge list. We use the package `here` to keep track of our working directory. See [here](https://here.r-lib.org/) (pun intended) for details.\n\nNow suppose that's the network we want to work with and it's saved in our hard drive. To load it, we just type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.el <- read.csv(here(\"pulp.csv\"), \n                    col.names = c(\"name1\", \"name2\"))\n   head(g.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name1     name2\n1 BRETT MARSELLUS\n2 BRETT    MARVIN\n3 BRETT     ROGER\n4 BRETT   VINCENT\n5 BUDDY       MIA\n6 BUDDY   VINCENT\n```\n:::\n:::\n\n\nWhich gives us the edge list we want now saved into an `R` object of class `data.frame`. So all we need is to convert that into an `igraph` object. To do that we use one of the many `graph_from...` functions in the `igraph` package. In this case, we want `graph_from_edgelist` because our network is stored as an edge list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.el <- as.matrix(g.el)\n   g <- graph_from_edgelist(g.el, directed = FALSE)\n   V(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 38/38 vertices, named, from d3a8db6:\n [1] BRETT           MARSELLUS       MARVIN          ROGER          \n [5] VINCENT         BUDDY           MIA             BUTCH          \n [9] CAPT KOONS      ESMARELDA       GAWKER #2       JULES          \n[13] PEDESTRIAN      SPORTSCASTER #1 ENGLISH DAVE    FABIENNE       \n[17] FOURTH MAN      HONEY BUNNY     MANAGER         JIMMIE         \n[21] JODY            PATRON          PUMPKIN         RAQUEL         \n[25] WINSTON         LANCE           MAYNARD         THE GIMP       \n[29] ZED             ED SULLIVAN     MOTHER          WOMAN          \n[33] PREACHER        SPORTSCASTER #2 THE WOLF        WAITRESS       \n[37] YOUNG MAN       YOUNG WOMAN    \n```\n:::\n\n```{.r .cell-code}\n   E(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 102/102 edges from d3a8db6 (vertex names):\n [1] BRETT      --MARSELLUS       BRETT      --MARVIN         \n [3] BRETT      --ROGER           BRETT      --VINCENT        \n [5] BUDDY      --MIA             VINCENT    --BUDDY          \n [7] BRETT      --BUTCH           BUTCH      --CAPT KOONS     \n [9] BUTCH      --ESMARELDA       BUTCH      --GAWKER #2      \n[11] BUTCH      --JULES           MARSELLUS  --BUTCH          \n[13] BUTCH      --PEDESTRIAN      BUTCH      --SPORTSCASTER #1\n[15] BUTCH      --ENGLISH DAVE    BRETT      --FABIENNE       \n[17] BUTCH      --FABIENNE        JULES      --FABIENNE       \n[19] JULES      --FOURTH MAN      VINCENT    --FOURTH MAN     \n+ ... omitted several edges\n```\n:::\n:::\n\n\nWhich gives us back the original `igraph` object. Note that first we converted the `data.frame` object into a `matrix` object. We also specified that the graph is **undirected** by setting the option `directed` to false.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}