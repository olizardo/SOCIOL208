---
title: "Status and Prestige"
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  message: false
format: 
   html:
      code-line-numbers: true
---

In the last handout, we saw how to compute the most popular centrality measures. Freeman's "big three" have strong graph-theoretic foundation and do a good job of formalizing and quantifying the idea that a node is central if it is "well-placed" in the network, where being well-placed resolves into either being able to *reach* others (directly as with degree or indirectly as with closeness) or being able to *intermediate* between others (as with betweenness).

There is, however, another strong and well-motivated intuition as to what it means to be "well-placed" in a network. Here the ties in the network are seen less as "pipes" that transmit stuff and more like "prisms" that *reflect* on you [@podolny01]. Another way of thinking about this second version of well-placedness is that what is transmitted through the network is the *network itself*, or more accurately, the *importance*, *status*, and *prestige* of the people you are connected to.

Under this interpretation, actors get status and prestige in the network from being connected to prestigious and high status others. Those others, in turn, get their status from being connected to high status others, and so *ad infinitum*. 

One way of quantifying this idea goes like this. If $\mathbf{x}$ is a vector containing the desired status scores, then the status of each actor should be equal to:

$$
   x_i = \sum_{j} a_{ij}x_j
$$#first-eq

Where $a_{ij} = 1$ if $i$ is adjacent to $j$ in the network. Note that this formula just sums up the status scores of all the others each actor is connected to.

In matrix notation, if $\mathbf{x}$ is a column vector of status scores then:

$$
   \mathbf{x} = A\mathbf{x}
$$

Because $\mathbf{x}$ is an $n \times n$ matrix and $\mathbf{x}$ is $n \times 1$ column vector, the multiplication $A\mathbf{x}$ will return another column vector of dimensions $n \times 1$, in this case $\mathbf{x}$ itself!

Note the problem that this formulation poses: $\mathbf{x}$ appears on both sides of the equation, which means that in order to know the status of any one node we would need to know the status of the others, but calculating the status of the others depends on knowing the status of the focal node, and so on. There's a chicken and the egg problem here.

Now, there is an obvious (to the math majors) *mathematical solution* to this problem, because there's a class of solvable (under some mild conditions imposed on the matrix $\mathbf{A}$) linear algebra problems that take the form:

$$
   \lambda\mathbf{x} = A\mathbf{x}
$$

Where $\lambda$ is just a plain old number (a scalar). Once again under some very mild conditions we can search for a value $\lambda$ while also filling up the $\mathbf{x}$ with another set of values until we find some that make the above equality true. 

When we do that successfully, we say that the value of $\lambda$ we hit upon is an **eigenvalue** of the matrix $\mathbf{A}$ and the values we put in the vector $\mathbf{x}$ are an **eigenvector** of the same matrix (technically in the above equation a right eigenvector). 

Eigenvalues and eigenvectors, like Don Quixote and Sancho Panza, come in pairs, because you need a unique combination of both to solve the equation. Typically, a given matrix (like an adjacency matrix) will have multiple $\lambda/\mathbf{x}$ pairs that will solve the equation. Together the whole set $\lambda/\mathbf{x}$ pairs that make the equation true are the **eigenvalues** and **eigenvectors** of the matrix. 

Note that all of this obscure talk about eigenvalues and eigenvectors is just matrix math stuff. It has nothing to do with networks and social structure. In contrast, because the big three centrality measures have a direct foundation in graph theory, and graph theory is an isomorphic **model** of social structures (points map to actor and lines map to relations) the "math" we do with graph theory is **directly** meaningful as a model of networks (the counts of the number of edges incident to a node is the count of other actors they someone is directly connected to). 

Eigenvalues and eigenvectors are not a model of social structure in the way graph theory is (their first scientific application was in Physics). They are just a mechanical math fix to a circular equation problem. 

This is why it's a mistake to introduce network measures of status and prestige by jumping directly to the machinery of linear algebra (or worse talk about the idea of **eigenvector centrality** which means nothing to most people). 

A better approach is to see if we can *motivate* the use of measures like the ones above using the simple model of the distribution of status and prestige we started with earlier. We will see that we can, and that doing that leads us back to solutions that are the mathematical equivalent of all the eigenvector stuff. 

## Distributing Centrality to Others

Let's start with the simplest model of how people can get their status from the status of others in a network. It is the simplest because it is based on degree. Imagine everyone has the same "quantum" of status to begin with (this can be stored in a vector containing the same number of length equals to number of actors in the network). Then, at each step, people "send" the same amount of status to all their alters in the network. At the end of each step, we compute people's status scores using @first-eq. They stop doing this after the status scores of people stop changing.

Let us see a real-life example at work. 

We will use a data set collected by David Krackhardt on the friendships of 21 managers in a high tech company in the West coast. The data are reported as directed ties ($i$ nominates $j$ as a friend) but we will constrain ties to be undirected:

```{r}
   library(networkdata)
   library(igraph)
   g <- as.undirected(ht_friends)
```

This is what the network looks like:

```{r}
#| echo: false
#| fig-cap: "Krackhardt's Manager Data."
#| fig-height: 7
   library(ggraph)
   set.seed(456)
    p <- ggraph(g, layout = 'dh')
    p <- p + geom_edge_fan(color = gray(0.5), edge_width = 0.25)
    p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = "tan2") 
    p <- p + geom_node_text(aes(label = 1:vcount(g)), size = 4, color = "white")
    p <- p + theme_graph() 
    p
```

We extract the adjacency matrix corresponding to this network:

```{r}
   A <- as.matrix(as_adjacency_matrix(g))
```

And here's a simple `while` loop that exemplifies the process of status distribution through the network we talked about earlier:

```{r}
     n <- nrow(A) #number of actors
     c <- rep(1, n) #initial status vector set to all ones
     w <- 1 
     k <- 0 #initializing counter
     while (w > 0.0001) {
          o.c <- c #old status scores
          c <- A %*% c #new scores a function of old scores and adjacency matrix
          c <- c/norm(c, type = "E") #normalizing new status scores
          w <- abs(sum(abs(c) - abs(o.c))) #diff. between new and old scores
          k <- k + 1 #incrementing while counter
     }
```

And here's the resulting (row) vector of status scores for each node:

```{r}
   c <- as.vector(t(c))
   round(c, 3)
```      





