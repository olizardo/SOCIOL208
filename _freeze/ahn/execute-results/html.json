{
  "hash": "6b36a33f060ec217aeae15b3f498f1cd",
  "result": {
    "markdown": "---\ntitle: \"Assigning Nodes to Multiple Communities\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nIn the previous handout, we examined various approaches to community and dense subgraph detection. What they all have in common is they assign nodes into non-overlapping groups. That is, nodes are either in one group or another but cannot belong to multiple groups at once. While this may make sense for a lot of substantive settings, it might not make sense for other ones, where multiple group memberships are normal (e.g., think of high school). \n\n## Detecting Overlapping Communities\n\nMethodologically, overlapping community detection methods are not as well-developed as classical community detection methods. Here, we review one simple an intuitive approach that combines the idea of clustering nodes by computing a quantity on the links but instead of computing a rank order (like Newman and Girvan's edge betweenness), we compute pairwise *similarities* between links like we did in handout 5. We then cluster the links using standard hierarchical clustering methods, which because nodes are incident to many links results in a multigroup clustering of the nodes for free. This approach is called **link clustering** [@ahn_etal10].\n\nLet's see how it works.\n\nFirst we load data from an undirected graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(igraph)\n   library(networkdata)\n   g <- movie_559 #Pulp Fiction\n```\n:::\n\n\nAnd we plot:\n\n\n::: {.cell layout-ncol=\"2\"}\n::: {.cell-output-display}\n![Original Graph.](ahn_files/figure-html/unnamed-chunk-2-1.png){width=1152}\n:::\n\n::: {.cell-output-display}\n![Nodes Clusterered Into Communities According to the Modularity.](ahn_files/figure-html/unnamed-chunk-2-2.png){width=1152}\n:::\n\nThe Pulp Fiction Movie Network.\n:::\n\n\nThe key idea behind link clustering is that *similar* links should be assigned to the same clusters. How do we compute the similarity between links? \n\n## Measuring Edge Similarity\n\nAccording to @ahn_etal10 two links $e_{ik}$ and $e_{jk}$ are similar if they share a node $v_k$ *and* the other two nodes incident to each link ($v_i, v_k$) are themselves similar. To measure the similarity between these two nodes, we can use any of the off-the-shelf vertex similarity measures that we have seen in action, like Jaccard, cosine, or Dice.\n\nThe first step is thus to build a link by link similarity matrix based on this idea. The following function loops through each *pair of links* in the graph and computes the similarity between two links featuring a common node $v_k$  based on the Jaccard vertex similarity of the two other nodes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    edge.sim <- function(x) {\n      el <- as_edgelist(x)\n      A <- as.matrix(as_adjacency_matrix(x))\n      S <- A %*% A #shared neighbors\n      d <- degree(x)\n      E <- nrow(el)\n      E.sim <- matrix(0, E, E)\n      for (e1 in 1:E) {\n        for (e2 in 1:E) {\n          if (e1 < e2 & sum(as.numeric(intersect(el[e1,], el[e2,])!=\"0\"))==1) {\n              v <- setdiff(union(el[e1,], el[e2,]), intersect(el[e1,], el[e2,]))\n              E.sim[e1, e2] <- S[v[1], v[2]]/(S[v[1], v[2]] + d[v[1]] + d[v[2]])\n              E.sim[e2, e1] <- S[v[1], v[2]]/(S[v[1], v[2]] + d[v[1]] + d[v[2]])\n            }\n          }\n        }\n    return(round(E.sim, 3))\n    }\n```\n:::\n\n\nThe function takes the graph as input and returns an inter-link similarity matrix of dimensions $E \\times E$ where $E$ is the number of edges in the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    E.sim <- edge.sim(g)\n    E.sim[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10]\n [1,] 0.000 0.238 0.238 0.167 0.000 0.000 0.250 0.000 0.000 0.000\n [2,] 0.238 0.000 0.294 0.139 0.000 0.000 0.179 0.000 0.000 0.000\n [3,] 0.238 0.294 0.000 0.139 0.000 0.000 0.179 0.000 0.000 0.000\n [4,] 0.167 0.139 0.139 0.000 0.000 0.100 0.192 0.000 0.000 0.000\n [5,] 0.000 0.000 0.000 0.000 0.000 0.217 0.000 0.000 0.000 0.000\n [6,] 0.000 0.000 0.000 0.100 0.217 0.000 0.000 0.000 0.000 0.000\n [7,] 0.250 0.179 0.179 0.192 0.000 0.000 0.000 0.143 0.111 0.167\n [8,] 0.000 0.000 0.000 0.000 0.000 0.000 0.143 0.000 0.143 0.111\n [9,] 0.000 0.000 0.000 0.000 0.000 0.000 0.111 0.143 0.000 0.200\n[10,] 0.000 0.000 0.000 0.000 0.000 0.000 0.167 0.111 0.200 0.000\n```\n:::\n:::\n\n\nWe can then transform the link similarities into distances, and cluster them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    D <- 1 - E.sim\n    D <- as.dist(D)\n    hc.res <- hclust(D, method = \"ward.D2\")\n```\n:::\n\n\nThe resulting dendrogram looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    par(cex = 0.5)\n    plot(hc.res)\n```\n\n::: {.cell-output-display}\n![](ahn_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nThe leaves of the dendrogram (bottom-most objects) represent each link in the graph ($E = 102$ in this case), and the clusters are \"link communities\" [@ahn_etal10].\n\n## Clustering Nodes\n\nAs we noted, because it is the links that got clustered, the nodes incident to each link can go to more than one cluster (because nodes with degree $k>1$ will be incident to multiple links). \n\nThe following function uses the dendrogram information to return a list of node assignments to multiple communities, controlled by the parameter `k`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    create.clus <- function(x, k) {\n      library(dendextend)\n      link.clus <- cutree(x, k = k)\n      link.dat <- data.frame(as_edgelist(g), link.clus)\n      clus.list <- list()\n      for (i in 1:max(link.clus)) {\n        sub.dat <- link.dat[link.dat$link.clus == i, ]\n        clus.list[[i]] <- unique(c(sub.dat[, 1], sub.dat[, 2]))\n        }\n    return(clus.list)\n    }\n```\n:::\n\n\nLet's see the list with twelve overlapping communities:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    C <- create.clus(hc.res, k = 12)\n    C\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"BRETT\"      \"GAWKER #2\"  \"JULES\"      \"MARSELLUS\"  \"MARVIN\"    \n[6] \"PEDESTRIAN\" \"ROGER\"      \"VINCENT\"   \n\n[[2]]\n [1] \"BRETT\"           \"FABIENNE\"        \"MARVIN\"          \"SPORTSCASTER #1\"\n [5] \"JIMMIE\"          \"RAQUEL\"          \"ROGER\"           \"JULES\"          \n [9] \"SPORTSCASTER #2\" \"THE WOLF\"        \"WINSTON\"        \n\n[[3]]\n [1] \"BRETT\"       \"FOURTH MAN\"  \"RAQUEL\"      \"THE WOLF\"    \"HONEY BUNNY\"\n [6] \"JIMMIE\"      \"JULES\"       \"MANAGER\"     \"MARVIN\"      \"PATRON\"     \n[11] \"PUMPKIN\"     \"ROGER\"       \"VINCENT\"     \"WINSTON\"    \n\n[[4]]\n [1] \"BUDDY\"        \"JODY\"         \"LANCE\"        \"BUTCH\"        \"CAPT KOONS\"  \n [6] \"ED SULLIVAN\"  \"ENGLISH DAVE\" \"MARSELLUS\"    \"MIA\"          \"MOTHER\"      \n[11] \"WOMAN\"        \"VINCENT\"     \n\n[[5]]\n [1] \"BUDDY\"        \"LANCE\"        \"PREACHER\"     \"CAPT KOONS\"   \"ED SULLIVAN\" \n [6] \"ENGLISH DAVE\" \"JODY\"         \"MOTHER\"       \"VINCENT\"      \"WOMAN\"       \n\n[[6]]\n [1] \"BRETT\"           \"BUTCH\"           \"ENGLISH DAVE\"    \"CAPT KOONS\"     \n [5] \"ESMARELDA\"       \"GAWKER #2\"       \"JULES\"           \"MARSELLUS\"      \n [9] \"PEDESTRIAN\"      \"SPORTSCASTER #1\" \"FABIENNE\"        \"MARVIN\"         \n[13] \"MAYNARD\"         \"MOTHER\"          \"ROGER\"           \"VINCENT\"        \n[17] \"WOMAN\"          \n\n[[7]]\n [1] \"FOURTH MAN\"  \"JIMMIE\"      \"BRETT\"       \"HONEY BUNNY\" \"JULES\"      \n [6] \"MANAGER\"     \"MARVIN\"      \"PATRON\"      \"PUMPKIN\"     \"RAQUEL\"     \n[11] \"ROGER\"       \"WINSTON\"     \"THE WOLF\"   \n\n[[8]]\n[1] \"HONEY BUNNY\" \"MANAGER\"     \"PATRON\"      \"PUMPKIN\"    \n\n[[9]]\n[1] \"JODY\"     \"LANCE\"    \"PREACHER\"\n\n[[10]]\n[1] \"MAYNARD\"  \"THE GIMP\" \"ZED\"     \n\n[[11]]\n[1] \"CAPT KOONS\" \"MOTHER\"     \"WOMAN\"     \n\n[[12]]\n[1] \"HONEY BUNNY\" \"PUMPKIN\"     \"WAITRESS\"    \"YOUNG MAN\"   \"YOUNG WOMAN\"\n```\n:::\n:::\n\n\nBecause there are nodes that belong to multiple communities, the resulting actor by community ties form a **two-mode network**. \n\nWe can see re-construct this network from the list of community memberships for each node using this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    create.two <- function(x) {\n      v <- unique(unlist(x))\n      B <- as.numeric(v %in% x[[1]])\n      for(j in 2:length(x)) {\n        B <- cbind(B, as.numeric(v %in% x[[j]]))\n      }\n      rownames(B) <- v\n      colnames(B) <- paste(\"c\", 1:12, sep = \"\")\n      return(B)\n      }\n```\n:::\n\n\nHere's the two mode matrix of characters by communities:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    B <- create.two(C)\n    B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12\nBRETT            1  1  1  0  0  1  1  0  0   0   0   0\nGAWKER #2        1  0  0  0  0  1  0  0  0   0   0   0\nJULES            1  1  1  0  0  1  1  0  0   0   0   0\nMARSELLUS        1  0  0  1  0  1  0  0  0   0   0   0\nMARVIN           1  1  1  0  0  1  1  0  0   0   0   0\nPEDESTRIAN       1  0  0  0  0  1  0  0  0   0   0   0\nROGER            1  1  1  0  0  1  1  0  0   0   0   0\nVINCENT          1  0  1  1  1  1  0  0  0   0   0   0\nFABIENNE         0  1  0  0  0  1  0  0  0   0   0   0\nSPORTSCASTER #1  0  1  0  0  0  1  0  0  0   0   0   0\nJIMMIE           0  1  1  0  0  0  1  0  0   0   0   0\nRAQUEL           0  1  1  0  0  0  1  0  0   0   0   0\nSPORTSCASTER #2  0  1  0  0  0  0  0  0  0   0   0   0\nTHE WOLF         0  1  1  0  0  0  1  0  0   0   0   0\nWINSTON          0  1  1  0  0  0  1  0  0   0   0   0\nFOURTH MAN       0  0  1  0  0  0  1  0  0   0   0   0\nHONEY BUNNY      0  0  1  0  0  0  1  1  0   0   0   1\nMANAGER          0  0  1  0  0  0  1  1  0   0   0   0\nPATRON           0  0  1  0  0  0  1  1  0   0   0   0\nPUMPKIN          0  0  1  0  0  0  1  1  0   0   0   1\nBUDDY            0  0  0  1  1  0  0  0  0   0   0   0\nJODY             0  0  0  1  1  0  0  0  1   0   0   0\nLANCE            0  0  0  1  1  0  0  0  1   0   0   0\nBUTCH            0  0  0  1  0  1  0  0  0   0   0   0\nCAPT KOONS       0  0  0  1  1  1  0  0  0   0   1   0\nED SULLIVAN      0  0  0  1  1  0  0  0  0   0   0   0\nENGLISH DAVE     0  0  0  1  1  1  0  0  0   0   0   0\nMIA              0  0  0  1  0  0  0  0  0   0   0   0\nMOTHER           0  0  0  1  1  1  0  0  0   0   1   0\nWOMAN            0  0  0  1  1  1  0  0  0   0   1   0\nPREACHER         0  0  0  0  1  0  0  0  1   0   0   0\nESMARELDA        0  0  0  0  0  1  0  0  0   0   0   0\nMAYNARD          0  0  0  0  0  1  0  0  0   1   0   0\nTHE GIMP         0  0  0  0  0  0  0  0  0   1   0   0\nZED              0  0  0  0  0  0  0  0  0   1   0   0\nWAITRESS         0  0  0  0  0  0  0  0  0   0   0   1\nYOUNG MAN        0  0  0  0  0  0  0  0  0   0   0   1\nYOUNG WOMAN      0  0  0  0  0  0  0  0  0   0   0   1\n```\n:::\n:::\n\n\nAnd the matrix of inter-community ties based on shared characters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    M <- t(B) %*% B\n    M\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12\nc1   8  4  5  2  1  8  4  0  0   0   0   0\nc2   4 11  8  0  0  6  8  0  0   0   0   0\nc3   5  8 14  1  1  5 13  4  0   0   0   2\nc4   2  0  1 12  9  7  0  0  2   0   3   0\nc5   1  0  1  9 10  5  0  0  3   0   3   0\nc6   8  6  5  7  5 17  4  0  0   1   3   0\nc7   4  8 13  0  0  4 13  4  0   0   0   2\nc8   0  0  4  0  0  0  4  4  0   0   0   2\nc9   0  0  0  2  3  0  0  0  3   0   0   0\nc10  0  0  0  0  0  1  0  0  0   3   0   0\nc11  0  0  0  3  3  3  0  0  0   0   3   0\nc12  0  0  2  0  0  0  2  2  0   0   0   5\n```\n:::\n:::\n\n\nAnd we can visualize the nodes connected to multiple communities as follows: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(RColorBrewer)\n    set.seed(45)\n    g <- graph_from_biadjacency_matrix(B)\n    V(g)$type <- bipartite_mapping(g)$type\n    V(g)$shape <- ifelse(V(g)$type, \"square\", \"circle\")\n    V(g)$color <- c(rep(\"orange\", 38), \n                    c(brewer.pal(8, \"Paired\"), brewer.pal(4, \"Dark2\"))) \n    E(g)$color <- \"lightgray\"\n    plot(g, \n    vertex.size=5, vertex.frame.color=\"lightgray\", \n    vertex.label = V(g)$name,\n    vertex.label.dist=1, vertex.label.cex = 1)\n```\n\n::: {.cell-output-display}\n![](ahn_files/figure-html/unnamed-chunk-12-1.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "ahn_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}