---
title: "Closeness Centrality"
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  message: false
format: 
   html:
      code-line-numbers: true
---

The **closeness centrality** of a node in a graph is defined as the inverse of the sum of the *lengths* of shortest paths from each node to every other node. That means that to compute it, we first need to calculate the **geodesic distance matrix** ($\mathbf{G}$). This is matrix in which each entry $g_{ij}$ records the *length* of the shortest path(s) between row node $i$ and column node $j$. Then, we sum the rows (or columns) of this symmetric matrix and then we obtain the inverse to get the closeness of each node:

$$
C^{CLO}_i = \left[\sum_{j \neq i}^N g_{ij}\right]^{-1}
$$

Let's see how this works. We first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:

```{r}
    library(networkdata)
    library(igraph)
    library(stringr) #using stringr to change names from all caps to title case
    g <- movie_559
    V(g)$name <- str_to_title(V(g)$name)
    V(g)$name[which(V(g)$name == "Esmarelda")] <- "Esmeralda" #fixing misspelled name
    E(g)$weight <- 1 #setting edge weights to 1.0
```

Let us extract the geodesic distance matrix of the graph using the `distances` function in `igraph`:

```{r}
   G <- distances(g) #geodesic distance matrix
   G[1:10, 1:10]
```

Then we compute the closeness of each node like this:

```{r}
   close1 <- rowSums(G)^-1 #inverse of the row sums of G
   round(close1, 4)
```

Of course, we could have just used the available function in `igraph` and computed the closeness centrality directly from the graph object using the function `closeness`:

```{r}
   close2 <- closeness(g)
   round(close2, 4)
```

Once we have the closeness centrality values, we are naturally interested in who are the top nodes. The following code creates a table listing the top ten:

```{r}
   library(kableExtra)
   close2 <- sort(close2, decreasing = TRUE)
   close2 <- data.frame(close2[1:10])
   kbl(close2, format = "pipe", align = c("l", "c"),
       col.names = c("Character", "Closeness"), digits = 4,
       caption = "Top Ten Closeness Characters in Pulp Fiction Network.") %>% 
   kable_styling(bootstrap_options = c("hover", "condensed", "responsive"))
```

It makes sense that the three main characters are also the ones that are at closest distances from everyone else!

## Normalized Closeness

We can also compute the **normalized closeness centrality** which is given by:

$$
C^{NCLO}_i = \frac{N-1}{\sum_{j \neq i}g_{ij}}
$$

Where $N$ is the number of nodes in the network. The normalized closeness is just the inverse of the *average* distance of node $i$ to the other nodes in the network.

In `R` this is just:

```{r}
   close3 <- (vcount(g) - 1)/(rowSums(G))
   round(close3, 4)
```

Which gives us the same result as using the `igraph` function with the argument `normalized` set to `TRUE`:

```{r}
   close3 <- closeness(g, normalized = TRUE)
   round(close3, 4)
```

## Computing the Geodesic Distance Matrix

As noted by @fouss_etal16 [p. 56, Algorithm 1.2] the geodesic distance matrix returned by the `distances` function in `igraph` can be computed by a relatively simple algorithm, a version of which goes like this.

First we define a "cost matrix" $\mathbf{C}$ with entries $c_{ij} = 1$ if nodes $i$ and $j$ are adjacent in the graph and $g_{ij} = \infty$ if they are not (if $i = j$ then $c_{ij} = 0$):


```{r}
   C <- 1/as.matrix(as_adjacency_matrix((g))) #cost matrix
   diag(C) <- 0
   C[1:10, 1:10]
```

Now, we loop through each node pair in the graph $i$, $j$, substituting the entries in the $\mathbf{C}$ matrix with the following expression at each iteration $k$:

$$
c^{(k)}_{ij} = min\left[c^{(k-1)}_{ij}, \left(c^{(k-1)}_{ik} + c^{(k-1)}_{kj}\right)\right]
$$

We stop once none of the entries in $\mathbf{C}$ are equal to `Inf` (in the case of a connected undirected graph).

Here's a little `R` program that implements this idea:

```{r}
   n <- nrow(C)
   while (sum(C[upper.tri(C)]) == Inf) {
      for(i in 1:n) {
         for (j in i:n) { #looping through upper triangle
            for (k in 1:n) {
               C[i,j] <- min(C[i,j], (C[i, k] + C[k, j]))
               }
            }
         }
      }
   C[lower.tri(C)] <- t(C)[lower.tri(C)] #copying upper triangle into lower triangle
```

And as we can see the entries in `C` are the same as those returned by `distances`:

```{r}
   C[1:10, 1:10]
   distances(g)[1:10, 1:10]
```

## Closeness Centrality in Directed Graphs
What about closeness centrality for a directed network? Let us see how this works using a **subgraph** of the @lazega01 `law_advice` network, this time selecting just women under the age of forty:

```{r}
    g <- law_advice
    women <- which(V(g)$gender == 2) #selecting women
    wg <- subgraph(g, women)
    young <- which(V(wg)$age < 40) #selecting women under forty
    wg <- subgraph(wg, young)
    V(wg)$name <- 1:vcount(wg) #naming nodes
```

This network is small enough that a plot could be informative about its structure. Let us plot it using the package `ggraph`, a visualization package that follows the same principles as the `ggplot` grammar of graphics but for network graphs (see [here](https://exts.ggplot2.tidyverse.org/ggraph.html)).

```{r}
#| fig-cap: "Women lawyers advice network"
#| fig-cap-location: margin
   #install.packages("ggraph")
   library(ggraph)
    p <- ggraph(wg, layout = 'auto')
    p <- p + geom_edge_parallel(color = "steelblue", edge_width = 0.5,
                                arrow = arrow(length = unit(2.5, 'mm')),
                                end_cap = circle(4, 'mm'), 
                                sep = unit(3, 'mm'))
    p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = "tan2") 
    p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = "white")
    p <- p + theme_graph() 
    p
```

Now a question we might ask is who has the greatest closeness centrality in this advice network. We could proceed as usual and compute the geodesic distances between actors:

```{r}
   G <- distances(wg)
   G
```

Note that this is not quite right. In `igraph` the default settings of the distance function treats the graph as undirected even though it is actually directed. So it doesn't use the strict **directed paths**, but it just treats them all as **semi-paths** ignoring direction. That is why, for instance, it counts node 1 as being "adjacent" to node 4 even though there is only one incoming link from 4 to 1 and why the whole matrix is symmetric, when we know from just eyeballing the network that there is a lot of asymmetry in terms of who can reach who via directed paths. 

To get the actual directed distance matrix, we need to specify the "mode" option, asking whether we want in or out paths. Here, we follow convention and select the out-paths:

```{r}
   G <- distances(wg, mode = "out")
   G
```

This is better but introduces a problem. The directed graph is not **strongly connected**, so it means that some nodes cannot reach other ones via a directed path of *any* length. That means that the **geodesic distances** from a node to an unreachable node is coded as "infinite" (`Inf`). The problem with infinity is that it gets in the way of calculating sums of distances, a requirement for the closeness centrality. 

```{r}
   G <- distances(wg, mode = "out")
   rowSums(G)
```

Adding infinity to a number just returns infinity so all the rows with at least one `Inf` in the distance matrix get an `Inf` for the row sum. In this case that's all of them. A bummer.

### Harmonic Centrality
But dont' worry there's a patch. It is called the **harmonic centrality** [@rochat09].^[@agneessens_etal17 call the harmonic centrality "reciprocal closeness"] This is a variation on the closeness centrality that works whether you are working with connected or disconnected graphs (or in the case of directed graphs regardless of whether the graph is strongly or weakly connected), and therefore regardless of whether the geodesic distance matrix contains `Inf`s.^[Some people [@boldi_vigna14] claim that the harmonic centrality is the *only* centrality measure that could be called by that name from a purely axiomatic mathematical approach, but that's a different story.]  

The main difference between the harmonic and regular closeness centrality is that instead of calculating the inverse of the sum of the distances for each node, we calculate the *sum of the inverses*:

$$
C^{HC}_i = \sum_{j \neq i}(g_{ij})^{-1}
$$

And the normalized version:

$$
C^{NHC}_i = \frac{\sum_{j \neq i}(g_{ij})^{-1}}{N-1}
$$

In `R` we can do this as follows. First, let's compute the inverse of the entries of the geodesic distance matrix:

```{r}
   inv.G = G^-1
   diag(inv.G) <- 0 #setting diagonals to zero
   round(inv.G, 3)
```

Note that in this matrix of inverse distances, the closest (adjacent) nodes get the maximum score of one, and nodes farther apart when smaller scores (approaching zero). More importantly, those pesky `Inf`s disappear (!) because unreachable directed pairs of nodes get the lowest score, corresponding to $1/\infty = 0$. Turns out the mathematics of infinity weren't our enemy after all. 

Also note that the reachability relation expressed in this matrix is asymmetric: So node 4 can reach node 1 (there is a directed tie from 4 to 1), but node 1 cannot reach 4. This is precisely what we want. 

Once we have this matrix of inverse distances, we can then we can compute the normalized harmonic centrality the same way as regular closeness by adding up the row scores for each node and dividing by the number of nodes minus one:

```{r}
   close4 <- rowSums(inv.G)/(vcount(wg) - 1)
   round(close4, 4)
```

We can see that the highest harmonic closeness centrality node is 5, followed by 12. Here's a plot of the network highlighting the highest harmonic centrality node. 

```{r}
#| fig-cap: "Women lawyers advice network with highest closeness centrality node in red"
#| fig-cap-location: margin
   col <- rep("tan2", vcount(wg)) #creating node color vector
   col[which(close4 == max(close4))] <- "red" #changing color of max centrality node to red
   p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = col)
   p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = "white")
   p
```

Of course, `igraph` has a built in function to calculate the harmonic centrality called (you guessed it) `harmonic_centrality`:

```{r}
   close4 <- harmonic_centrality(wg, normalized = TRUE)
   round(close4, 4)
```

Which gives us the same results (note we set the argument `normalized` to `TRUE` to get the normalized scores).

## Generalized Harmonic Centrality

@agneessens_etal17 propose a "generalized" version of the harmonic centrality that yields plain old degree centrality and the regular harmonic centrality as special cases. The key is to introduce a parameter $\delta$ governing how much weight we give to shortest paths based on distance. Let's see how this works. 

Recall that (the normalized version of) the harmonic centrality we defined earlier is given by:

$$
C^{NHC}_i = \frac{\sum_{j \neq i}(g_{ij})^{-1}}{N-1}
$$

For any node $i$, where $g_{ij}$ is the geodesic distance between $i$ and every other node in the graph $j$, which could be "infinite" if there is no path linking them. 

Agneessens et al's tweak is to instead compute:

$$
C^{GHC}_i = \frac{\sum_{j \neq i}(g_{ij})^{-\delta}}{N-1}
$$

Where $\delta$ is a free parameter chosen by the researcher with the restriction that $\delta \geq 0$ (if you want to calculate a closeness measure as we will see below). 

When $\delta = \infty$ the numerator element $1/(g_{ij})^{\infty} = 1$ only when nodes are adjacent and $g_{ij} = 1$ (because $1^{\infty} = 1$); otherwise, for $g_{ij} > 1$ then $1/(g_{ij})^{\infty} = 0$, and therefore the generalized harmonic centrality just becomes a (normalized) version of degree centrality. Alternatively, when $\delta = 1$ we just get the plain old harmonic centrality we defined earlier.

The interesting cases come from $1 > \delta < \infty$ and $0 > \delta < 1$. In the first case, nodes at shorter distances are weighted more (like in the standard harmonic centrality measure) as $\delta$ becomes bigger and bigger then the generalized harmonic centrality approximates degree. For values below one, as $\delta$ approaches zero, then indirect connections to nodes of greater length are discounted less, and thus count for "more" in defining your generalized harmonic centrality score.

Let us see a real-world example of the generalized harmonic centrality in action:

First, we create a custom function to compute the generalized harmonic centrality:

```{r}
   g.harm <- function(x, d) {
      library(igraph)
      w <- distances(x) #get distances from graph object
      w <- (w^d)^-1 #matrix of generalized inverse distances
      diag(w) <- 0 #set diagonals to zero
      h <- rowSums(w)/(vcount(x) - 1) #summing and averaging
      return(h)
      }
```

Second, we compute three versions of the harmonic centrality, with $\delta = 5$, $\delta = 0.05$, and $\delta = -5$, using the full (unrestricted by age) subgraph of the `law_advice` network composed of the women lawyers at the firm, with relations constrained to be undirected:

```{r}
   women <- which(V(law_advice)$gender == 2)
   wg <- subgraph(law_advice, women)
   wg <- as.undirected(wg)
   close5 <- g.harm(wg, d = 5)
   close6 <- g.harm(wg, d = 0.05)
   far1 <- g.harm(wg, d = -5)
```

- The first version of the harmonic centrality in line 5, with a positive value of $\delta$ above zero, will compute centrality scores emphasizing *direct* (one-step) connections, thus coming closer to **degree**. 

- The second version, in line 6, with a value of $\delta$ close to zero, will give comparatively more emphasis to *indirect* connections weighing longer paths almost as much as shorter paths (but always a little less), thus being more similar to **closeness** centrality. 

- Finally, the last version, in line 7, with $\delta < 0$, will weigh *longer* paths more than shorter ones, serving as a measure of **eccentricity** (farness from others) not closeness. 


```{r}
#| fig-cap: "Full women lawyers advice network"
#| fig-cap-location: margin
#| echo: false
   col <- rep("tan2", vcount(wg)) #creating node color vector
   col[which(close5 == max(close5))] <- "red" 
   col[which(close6 == max(close6))] <- "blue" 
   col[which(far1 == max(far1))] <- "purple" 
   set.seed(123)
   p <- ggraph(wg, layout = 'dh')
   p <- p + geom_edge_fan0(color = "steelblue", width = 0.35) 
   p <- p + geom_node_point(aes(x = x, y = y), size = 7, color = col) 
   p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 3.5, color = "white")
   p <- p + theme_graph() 
   p
```

Above is a plot of the women lawyers network showing the top node for each of the centralities:

- In red we have node 3 who has the largest degree ($k(3) = 8$) and thus comes out on top using the generalized harmonic centrality version emphasizing direct connections ($\delta > 1$). 

- Then in blue we have node 9 who can reach the most others via the shortest paths, and thus comes out on top when the generalized harmonic centrality emphasizes indirect connectivity. 

- Finally, in purple we have node 12, which is *farthest* from everyone else, and thus comes out on "top" when longer indirect connections count for more ($\delta < 0)$. 

As we said earlier, both regular harmonic centrality and degree are special cases of the generalized measure. We can check this by setting $\delta$ to either one or infinity.

When we set $\delta=1$ the generalized harmonic centrality is the same as the normalized harmonic centrality:

```{r}
   round(g.harm(wg, d = 1), 3)
   round(harmonic_centrality(wg, normalized = TRUE), 3)
```

When we set $\delta=\infty$ the generalized harmonic centrality is the same as the normalized degree centrality:

```{r}
   round(g.harm(wg, d = Inf), 3)
   round(degree(wg, normalized = TRUE), 3)
```

## Computing the Geodesic Distance Matrix

