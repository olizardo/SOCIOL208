{
  "hash": "d19a022bf54b2913355f84042241a72d",
  "result": {
    "markdown": "---\ntitle: \"The Duality of Persons and Groups\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nRecall that in the [one-mode case](prestige.qmd), multiplying the adjacency matrix times its transpose yields the **common neighbors matrix** $\\mathbf{M}$:\n\n$$\n\\mathbf{M} = \\mathbf{A}\\mathbf{A}^T\n$$\n\nAs famously noted by @breiger74, doing the same for the affiliation matrix of a two-mode network also returns the common-neighbors matrix, but because objects in one mode can only connect to objects in another mode, this also reveals the **duality of persons and groups**: The connections between people are made up of the groups they share, and the connections between groups are revealed by the groups they share.\n\nThus, computing the common neighbors matrix for both persons and groups (also called the **projection** of the two-mode network into each of its modes) produces a one-mode similarity matrix between people and groups, where the similarities are defined by the number of objects in the other mode that they share. \n\nFor the people the relevant projection is:\n\n$$\n\\mathbf{P} = \\mathbf{A}\\mathbf{A}^T\n$$\n\nAnd for the groups:\n\n$$\n\\mathbf{G} = \\mathbf{A}^T\\mathbf{A}\n$$\n\nLet's see how this works out with real data by loading our usual friend the *Southern Women* data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(igraph)\n    library(networkdata)\n    g <- southern_women\n    A <- as_biadjacency_matrix(g)\n```\n:::\n\n\nIn this case, the above equations yield:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   P <- A %*% t(A)\n   P\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         8     6       7      6         3       4       3     3    3\nLAURA          6     7       6      6         3       4       4     2    3\nTHERESA        7     6       8      6         4       4       4     3    4\nBRENDA         6     6       6      7         4       4       4     2    3\nCHARLOTTE      3     3       4      4         4       2       2     0    2\nFRANCES        4     4       4      4         2       4       3     2    2\nELEANOR        3     4       4      4         2       3       4     2    3\nPEARL          3     2       3      2         0       2       2     3    2\nRUTH           3     3       4      3         2       2       3     2    4\nVERNE          2     2       3      2         1       1       2     2    3\nMYRNA          2     1       2      1         0       1       1     2    2\nKATHERINE      2     1       2      1         0       1       1     2    2\nSYLVIA         2     2       3      2         1       1       2     2    3\nNORA           2     2       3      2         1       1       2     2    2\nHELEN          1     2       2      2         1       1       2     1    2\nDOROTHY        2     1       2      1         0       1       1     2    2\nOLIVIA         1     0       1      0         0       0       0     1    1\nFLORA          1     0       1      0         0       0       0     1    1\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        2     2         2      2    2     1       2      1     1\nLAURA         2     1         1      2    2     2       1      0     0\nTHERESA       3     2         2      3    3     2       2      1     1\nBRENDA        2     1         1      2    2     2       1      0     0\nCHARLOTTE     1     0         0      1    1     1       0      0     0\nFRANCES       1     1         1      1    1     1       1      0     0\nELEANOR       2     1         1      2    2     2       1      0     0\nPEARL         2     2         2      2    2     1       2      1     1\nRUTH          3     2         2      3    2     2       2      1     1\nVERNE         4     3         3      4    3     3       2      1     1\nMYRNA         3     4         4      4    3     3       2      1     1\nKATHERINE     3     4         6      6    5     3       2      1     1\nSYLVIA        4     4         6      7    6     4       2      1     1\nNORA          3     3         5      6    8     4       1      2     2\nHELEN         3     3         3      4    4     5       1      1     1\nDOROTHY       2     2         2      2    1     1       2      1     1\nOLIVIA        1     1         1      1    2     1       1      2     2\nFLORA         1     1         1      1    2     1       1      2     2\n```\n:::\n\n```{.r .cell-code}\n   G <- t(A) %*% A\n   G\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     3   2    3    2    3    3    2    3   1    0    0   0     0   0\n3/2      2   3    3    2    3    3    2    3   2    0    0   0     0   0\n4/12     3   3    6    4    6    5    4    5   2    0    0   0     0   0\n9/26     2   2    4    4    4    3    3    3   2    0    0   0     0   0\n2/25     3   3    6    4    8    6    6    7   3    0    0   0     0   0\n5/19     3   3    5    3    6    8    5    7   4    1    1   1     1   1\n3/15     2   2    4    3    6    5   10    8   5    3    2   4     2   2\n9/16     3   3    5    3    7    7    8   14   9    4    1   5     2   2\n4/8      1   2    2    2    3    4    5    9  12    4    3   5     3   3\n6/10     0   0    0    0    0    1    3    4   4    5    2   5     3   3\n2/23     0   0    0    0    0    1    2    1   3    2    4   2     1   1\n4/7      0   0    0    0    0    1    4    5   5    5    2   6     3   3\n11/21    0   0    0    0    0    1    2    2   3    3    1   3     3   3\n8/3      0   0    0    0    0    1    2    2   3    3    1   3     3   3\n```\n:::\n:::\n\n\nThe off-diagonal entries of these square person by person (group by group) matrices is the number of groups (people) shared by each person (group) and the diagonals are the number of memberships of each person (the size of each group/event).\n\nIn `igraph` the  relevant function is called `bipartite_projection`. It takes a graph as an input and returns a list containing `igraph` graph objects of both projections by default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Proj <- bipartite_projection(g)\n   G.p <- Proj[[1]]\n   G.g <- Proj[[2]]\n```\n:::\n\n\nIn the graph objects produced by the `bipartite_projection` function, the actual shared memberships and shared members are stored as an *attribute* of each edge called `weight` used in the plotting code below to set the `edge.width`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   edge_attr(G.p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$weight\n  [1] 6 6 7 3 4 3 3 3 2 2 2 2 2 1 2 1 1 6 6 3 4 4 3 2 2 2 2 2 1 1 1 6 4 4 4 4 3\n [38] 3 3 3 2 2 2 2 1 1 4 4 4 3 2 2 2 2 2 1 1 1 2 2 2 1 1 1 1 3 2 2 1 1 1 1 1 1\n [75] 1 3 2 2 2 2 2 1 1 1 2 2 2 2 2 2 1 2 1 1 3 3 2 2 2 2 2 1 1 4 3 3 3 3 2 1 1\n[112] 4 4 3 2 3 1 1 6 3 2 5 1 1 6 4 2 1 1 4 1 2 2 1 1 1 1 1 2\n```\n:::\n\n```{.r .cell-code}\n   edge_attr(G.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$weight\n [1] 2 3 2 3 3 3 1 2 3 2 3 3 3 2 2 4 6 5 5 2 4 4 3 3 2 3 6 7 3 6 7 4 5 1 1 1 1 1\n[39] 8 5 4 3 2 2 2 9 5 4 2 2 1 5 4 3 3 3 5 3 3 2 2 1 1 3 3 3\n```\n:::\n:::\n\n\nSo to get the weighted projection matrix, we need to type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   as.matrix(as_adjacency_matrix(G.p, attr = \"weight\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         0     6       7      6         3       4       3     3    3\nLAURA          6     0       6      6         3       4       4     2    3\nTHERESA        7     6       0      6         4       4       4     3    4\nBRENDA         6     6       6      0         4       4       4     2    3\nCHARLOTTE      3     3       4      4         0       2       2     0    2\nFRANCES        4     4       4      4         2       0       3     2    2\nELEANOR        3     4       4      4         2       3       0     2    3\nPEARL          3     2       3      2         0       2       2     0    2\nRUTH           3     3       4      3         2       2       3     2    0\nVERNE          2     2       3      2         1       1       2     2    3\nMYRNA          2     1       2      1         0       1       1     2    2\nKATHERINE      2     1       2      1         0       1       1     2    2\nSYLVIA         2     2       3      2         1       1       2     2    3\nNORA           2     2       3      2         1       1       2     2    2\nHELEN          1     2       2      2         1       1       2     1    2\nDOROTHY        2     1       2      1         0       1       1     2    2\nOLIVIA         1     0       1      0         0       0       0     1    1\nFLORA          1     0       1      0         0       0       0     1    1\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        2     2         2      2    2     1       2      1     1\nLAURA         2     1         1      2    2     2       1      0     0\nTHERESA       3     2         2      3    3     2       2      1     1\nBRENDA        2     1         1      2    2     2       1      0     0\nCHARLOTTE     1     0         0      1    1     1       0      0     0\nFRANCES       1     1         1      1    1     1       1      0     0\nELEANOR       2     1         1      2    2     2       1      0     0\nPEARL         2     2         2      2    2     1       2      1     1\nRUTH          3     2         2      3    2     2       2      1     1\nVERNE         0     3         3      4    3     3       2      1     1\nMYRNA         3     0         4      4    3     3       2      1     1\nKATHERINE     3     4         0      6    5     3       2      1     1\nSYLVIA        4     4         6      0    6     4       2      1     1\nNORA          3     3         5      6    0     4       1      2     2\nHELEN         3     3         3      4    4     0       1      1     1\nDOROTHY       2     2         2      2    1     1       0      1     1\nOLIVIA        1     1         1      1    2     1       1      0     2\nFLORA         1     1         1      1    2     1       1      2     0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n   as.matrix(as_adjacency_matrix(G.g, attr = \"weight\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     0   2    3    2    3    3    2    3   1    0    0   0     0   0\n3/2      2   0    3    2    3    3    2    3   2    0    0   0     0   0\n4/12     3   3    0    4    6    5    4    5   2    0    0   0     0   0\n9/26     2   2    4    0    4    3    3    3   2    0    0   0     0   0\n2/25     3   3    6    4    0    6    6    7   3    0    0   0     0   0\n5/19     3   3    5    3    6    0    5    7   4    1    1   1     1   1\n3/15     2   2    4    3    6    5    0    8   5    3    2   4     2   2\n9/16     3   3    5    3    7    7    8    0   9    4    1   5     2   2\n4/8      1   2    2    2    3    4    5    9   0    4    3   5     3   3\n6/10     0   0    0    0    0    1    3    4   4    0    2   5     3   3\n2/23     0   0    0    0    0    1    2    1   3    2    0   2     1   1\n4/7      0   0    0    0    0    1    4    5   5    5    2   0     3   3\n11/21    0   0    0    0    0    1    2    2   3    3    1   3     0   3\n8/3      0   0    0    0    0    1    2    2   3    3    1   3     3   0\n```\n:::\n:::\n\nWe can also use the weights to draw a weighted graph network plot of people and group projections. All we have to do is set the `edge.with` argument to the value of the edge weight attribute in the corresponding graph:\n\n\n::: {#fig-projection .cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n   set.seed(123)\n   plot(G.p, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.p)$weight)\n\n   set.seed(123)\n   plot(G.g, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.g)$weight)\n```\n\n::: {.cell-output-display}\n![Persons](tm-duality_files/figure-html/fig-projection-1.png){#fig-projection-1 width=1152}\n:::\n\n::: {.cell-output-display}\n![Groups](tm-duality_files/figure-html/fig-projection-2.png){#fig-projection-2 width=1152}\n:::\n\nOne mode projections.\n:::\n\n\nNote that because both `G.p` and `G.g` are **weighted graphs** we can calculate the weighted version of degree for both persons and groups from them (sometimes called the **vertex strength**).\n\nIn `igraph` we can do this using the `strength` function, which takes a weighted graph object as input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   strength(G.p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   EVELYN     LAURA   THERESA    BRENDA CHARLOTTE   FRANCES   ELEANOR     PEARL \n       50        45        57        46        24        32        36        31 \n     RUTH     VERNE     MYRNA KATHERINE    SYLVIA      NORA     HELEN   DOROTHY \n       40        38        33        37        46        43        34        24 \n   OLIVIA     FLORA \n       14        14 \n```\n:::\n\n```{.r .cell-code}\n   strength(G.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 6/27   3/2  4/12  9/26  2/25  5/19  3/15  9/16   4/8  6/10  2/23   4/7 11/21 \n   19    20    32    23    38    41    48    59    46    25    13    28    18 \n  8/3 \n   18 \n```\n:::\n:::\n\n\nInterestingly, as noted by @faust97 [p. 167], there is a (dual!) mathematical connection between the strength of each vertex in the weighted projection and the centrality of the nodes from the other set they are connected to:\n\n1. For people, the vertex strength is equal to the sum of the sizes of the groups they belong to minus their own degree.\n\n1. For groups, the vertex strength is equal to the sum of the memberships of the people that belong to them, minus their own size.\n\nWe can verify this relationship for $EVELYN$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum.size.evelyn <- sum(A[\"EVELYN\", ] * degree(g)[which(V(g)$type == TRUE)]) #sum of the sizes of the groups Evelyn belongs to\n   sum.size.evelyn - degree(g)[which(V(g)$name == \"EVELYN\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEVELYN \n    50 \n```\n:::\n:::\n\n\nWhich is indeed Evelyn's vertex strength. \n\nDually, the same relation applies to groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum.mem.6.27 <- sum(A[, \"6/27\"] * degree(g)[which(V(g)$type == FALSE)]) #sum of the memberships of people in the first group\n   sum.mem.6.27 - degree(g)[which(V(g)$name == \"6/27\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6/27 \n  19 \n```\n:::\n:::\n\n\nWhich is indeed the vertex strength of the event held on 6/27.\n\n## Visualizing Dual Projections Using the Minimum Spanning Tree\n\nAs we just saw projecting the original biadjacency matrix using Breiger's [-@breiger74] approach results in two weighted one mode networks. Because there is an edge between two persons (groups) if they share at least one group (person) the resulting graphs tend to be dense featuring high levels of connectivity between nodes as with @fig-projection. This can make it hard to discern the connectivity structure of the projected networks and detect patterns.\n\nOne approach to simplifying the visual projections of two-mode networks is to calculate the resulting weighted graph's **minimum spanning tree**. For any weighted network, the minimum spanning tree is the graph that connects all nodes using the smallest number of edges that form a tree^[Recall that a tree is a connected graph without any cycles.], which happens to be $N-1$ where $N$ is the number of nodes. \n\nTo do this, we can follow **Kruskal's Algorithm**. It goes like this:\n\n- First, we create an edgelist containing each of the edge weights of the one-mode projection graph.\n- Then we sort the edgelist by weight in increasing order (smallest weights first).\n- Then, we create an undirected empty graph with $N$ nodes.\n- Now, we go down the edgelist adding edges to the empty graph one at a time, at each step checking that:\n  1. We are not connecting nodes that have already been connected (avoiding **multiedges**).\n  1. Additional edges do not create **cycles** (as the resulting graph would be no longer a tree). \n\nWe stop when we have the desired number of edges ($N-1$), meaning all nodes are connected in the tree.\n\nHere's a function that does all of this, taking the weighted projection `igraph` object as input and returning the minimum spanning tree:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   make.mst <- function(x) {\n      E <- data.frame(as_edgelist(x), w = E(x)$weight) #creating weighted edge list\n      E <- E[order(E$w), ] #ordering by edge weight\n      Tr <- make_empty_graph(n = vcount(x), directed = FALSE) #creating empty graph\n      V(Tr)$name <- V(x)$name\n      k <- 1\n      n.e <- ecount(Tr)\n      n.v <- vcount(Tr) - 1\n      while(n.e < n.v) {\n         i <- which(V(x)$name == E[k,1])\n         j <- which(V(x)$name == E[k,2])\n         if (are_adjacent(Tr, i, j) == 0) { #checking nodes are not adjacent\n            Tr <- add_edges(Tr, c(i,j)) #add edge\n            n.e <- ecount(Tr) #new edge id\n            if (is_acyclic(Tr) == 0) { #checking new edge does not add a cycle\n               Tr <- delete_edges(Tr, n.e) # delete edge if it adds a cycle\n               }\n            }\n         n.e <- ecount(Tr)\n         k <- k + 1\n         }\n      return(Tr)\n   }\n```\n:::\n\n\nWe can now build the minimum spanning tree graph for each weighted projection:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Tr.p <- make.mst(G.p)\n   Tr.g <- make.mst(G.g)\n```\n:::\n\n\nAnd here's a point and line plot the minimum spanning tree for persons and groups in the *Southern Women* data (we use the `layout_as_tree` option in `igraph`):\n\n\n::: {#fig-mst .cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n   plot(Tr.p, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, layout=layout_as_tree,\n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = 3)\n   plot(Tr.g, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, layout=layout_as_tree,\n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = 3)\n```\n\n::: {.cell-output-display}\n![Persons](tm-duality_files/figure-html/fig-mst-1.png){#fig-mst-1 width=1152}\n:::\n\n::: {.cell-output-display}\n![Groups](tm-duality_files/figure-html/fig-mst-2.png){#fig-mst-2 width=1152}\n:::\n\nOne mode projection MST.\n:::\n",
    "supporting": [
      "tm-duality_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}