{
  "hash": "f7acaeb689788e6beab4c68914914d7c",
  "result": {
    "markdown": "---\ntitle: \"An Agglomertive Approach to Community Detection\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(networkdata)\n   library(igraph)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n    louvain <- function(x)  {\n      iter <- 0\n      n.moves <- 1\n      Q <- modularity_matrix(x, directed = FALSE)\n      v.names <- V(x)$name\n      while(n.moves != 0) {\n        n.moves <- 0\n        if (iter == 0) {\n          I <- diag(1, vcount(x), vcount(x)) #identity matrix\n          U <- I\n          l <- 1:vcount(x)\n          names(l) <- 1:vcount(x)\n          A <- as.matrix(as_adjacency_matrix(x))\n          vol <- sum(A)\n          }\n        node.list <- 1:vcount(x)\n        sampled.nodes <- 0\n        m <- 1\n        while (length(sampled.nodes) < 5*vcount(x)) {\n          i <- sample(node.list, 1, replace = TRUE)\n          sampled.nodes[m] <- i\n          #sampled.nodes <- sort(unique(sampled.nodes))\n          #print(sampled.nodes)\n          u.k <- U[, l[i]] #i's group\n          N <- unique(as.numeric(neighbors(x, i))) #i's neighbors\n          adj.clus <- l[N] #adjacent clusters\n          e.i <- I[, i]\n          Q.delta <- 0\n          k <- 1\n          for (j in N) { #populating Q.delta vector\n            u.l <- U[, adj.clus[k]] #j's group\n            Q.new <- (t(u.k - e.i) %*% Q %*% (u.k - e.i) + \n                      t(u.l + e.i) %*% Q %*% (u.l + e.i))\n            Q.old <- (t(u.k) %*% Q %*% u.k) + (t(u.l) %*% Q %*% u.l)\n            Q.delta[k] <- (Q.new - Q.old)/vol\n            k <- k + 1\n            } #end j for loop\n          max.Q <- max(Q.delta)\n          max.Q.pos <- which(Q.delta == max.Q)\n          if (max.Q > 0 & length(max.Q.pos) == 1) {\n            j <- N[max.Q.pos]\n            U[i, l[i]] <- 0\n            U[i, l[j]] <- 1\n            n.moves <- n.moves + 1\n            } #end if\n          if (max.Q > 0 & length(max.Q.pos) > 1) {\n            j <- N[sample(max.Q.pos, 1)]\n            U[i, l[i]] <- 0\n            U[i, l[j]] <- 1\n            n.moves <- n.moves + 1\n            } #end if\n          m <- m + 1\n          } # end main while loop\n        U <- U[, colSums(U)> 0] #eliminating zero columns\n        for (k in 1:ncol(U)) {\n          l[which(U[, k] == 1)] <- k #re-assigning node labels\n          }\n        #print(l)\n        print(n.moves)\n        A.new <- t(U) %*% A %*% U #coarsening adjacency matrix\n        x <- graph_from_adjacency_matrix(A.new, mode = \"undirected\")\n        iter <- iter + 1\n        } #end while\n      rownames(U) <- v.names\n      return(list(U, l))\n      } #end function\n  g <- movie_651\n  louvain(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 84\n[1] 6\n[1] 0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n                    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nBEACH                  0    0    0    0    1    0    0    0    1     0\nBONES                  0    0    0    0    0    0    0    1    0     0\nCADET                  0    0    0    0    0    0    1    0    0     0\nCAROL                  0    1    1    0    0    0    0    0    0     0\nCHEKOV                 0    0    0    0    0    0    0    0    1     0\nCOMPUTER VOICE         1    0    0    0    0    0    0    1    0     0\nDAVID                  0    1    0    0    0    0    0    0    0     0\nHELMSMAN               0    0    0    1    0    0    0    0    0     0\nHURRY                  0    0    0    1    0    0    0    0    0     0\nINTERCOM VOICE         0    0    0    0    0    1    0    1    0     0\nJEDDA                  0    1    0    0    0    0    0    0    0     0\nJOACHIM                0    0    0    1    0    0    0    0    0     0\nKHAN                   0    0    0    1    0    0    0    0    0     0\nKIRK                   0    0    0    0    0    0    0    1    0     0\nKYLE                   0    0    0    0    0    0    0    0    1     0\nMADISON                0    1    1    0    0    0    0    0    0     0\nMAIN TITLE SEQUENCE    0    0    0    0    0    0    1    0    0     0\nPRESTON                1    0    0    0    0    0    0    0    0     0\nSAAVIK                 0    0    0    0    0    0    0    1    0     0\nSCOTTY                 1    0    0    0    0    0    0    1    0     0\nSPOCK                  0    0    0    0    0    0    0    1    0     0\nSTATIC                 0    1    0    0    0    0    0    1    0     1\nSULU                   0    0    0    0    0    0    0    1    0     0\nTERRELL                0    0    0    0    0    0    0    0    1     0\nUHURA                  0    0    0    0    0    0    0    1    0     0\n\n[[2]]\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \n 9  8  7  3  9  8  2  4  4  8  2  4  4  8  9  3  7  1  8  8  8 10  8  9  8 \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}