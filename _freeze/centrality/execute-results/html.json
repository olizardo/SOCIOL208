{
  "hash": "44196979bb7641d1c97c14c7cd2e55dd",
  "result": {
    "markdown": "---\ntitle: \"Centrality\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nIn this handout we will go through the basic centrality metrics. Particularly, the \"big three\" according to @freeman79, namely, **degree**, **closeness** (in two flavors) and **betweenness**. \n\nWe first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(networkdata)\n   library(igraph)\n   g <- movie_559\n```\n:::\n\n\n## Degree Centrality\n\nDegree centrality is the simplest and most straightforward measure. In fact, we are already computed in the [lecture notes on basic network statistics](basic.qmd) since it is the same as obtaining the graph's **degree sequence**. So the `igraph` function `degree` would do it as we already saw. \n\nHere we follow a different approach using the row (or column) sums of the graph's **adjacency matrix**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as_adjacency_matrix(g)\n   A <- as.matrix(A)\n   rowSums(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n              7               2              17               5               2 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n              4               1               3               2               3 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n              8               3               4              16               4 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n              5              10               6               3              11 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n              5               5               3               3               8 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n              3               6               2               1               2 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n              3              25               4               3               5 \n      YOUNG MAN     YOUNG WOMAN             ZED \n              4               4               2 \n```\n:::\n:::\n\n\nThe `igraph` function `as_adjancency_matrix` doesn't quite return a regular `R` matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the `as.matrix` function in line 2. Then we can apply the native `rowSums` function to obtain each node's degree. Note that this is same output we got using the `degree` function before. \n\n## Indegree and Outdegree\n\nThe movie network is based on the relationship of co-appearance in a scene which by nature lacks any natural directionality (it's a symmetric relation) and can therefore be represented in an **undirected graph**. The concepts of in and outdegree, by contrast, are only applicable to directed relations. So to illustrate them, we need to switch to a different source of data.\n\nWe pick an **advice network** which is a classical directed kind of (asymmetric) relation. I can give advice to you, but that doesn't necessarily mean you can give advice to me. The `networkdata` package contains one such data set collected in the late 80s early 1990s in a New England law firm (see the description [here](https://rdrr.io/github/schochastics/networkdata/man/law_advice.html)), called `law_advice`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- law_advice\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 71/71 vertices, from d1a9da7:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n[51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n```\n:::\n\n```{.r .cell-code}\n   vertex_attr(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$status\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n[39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n\n$gender\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 2 1 1 1 2\n[39] 2 1 1 1 2 2 1 2 1 2 1 1 2 1 1 1 1 1 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2\n\n$office\n [1] 1 1 2 1 2 2 2 1 1 1 1 1 1 2 3 1 1 2 1 1 1 1 1 1 2 1 1 2 1 2 2 2 2 1 2 1 3 1\n[39] 1 1 1 1 1 3 1 2 3 1 1 2 2 1 1 1 1 1 1 2 2 1 1 1 2 1 1 1 1 1 1 1 1\n\n$seniority\n [1] 31 32 13 31 31 29 29 28 25 25 23 24 22  1 21 20 23 18 19 19 17  9 16 15 15\n[26] 15 13 11 10  7  8  8  8  8  8  5  5  7  6  6  5  4  5  5  3  3  3  1  4  3\n[51]  4  4 10  3  3  3  3  3  2  2  2  2  2  2  2  1  1  1  1  1  1\n\n$age\n [1] 64 62 67 59 59 55 63 53 53 53 50 52 57 56 48 46 50 45 46 49 43 49 45 44 43\n[26] 41 47 38 38 39 34 33 37 36 33 43 44 53 37 34 31 31 47 53 38 42 38 35 36 31\n[51] 29 29 38 29 34 38 33 33 30 31 34 32 29 45 28 43 35 26 38 31 26\n\n$practice\n [1] 1 2 1 2 1 1 2 1 2 2 1 2 1 2 2 2 2 1 2 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2 2 1 2 1\n[39] 1 1 1 2 1 2 2 2 1 2 1 2 1 1 2 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 1\n\n$law_school\n [1] 1 1 1 3 2 1 3 3 1 3 1 2 2 1 3 1 1 2 1 1 2 3 2 2 2 3 1 2 3 3 2 3 3 2 3 3 3 2\n[39] 1 1 2 2 2 1 3 2 3 3 2 2 3 3 3 3 3 2 2 3 2 2 3 2 2 2 3 3 2 3 3 2 2\n```\n:::\n:::\n\n\nWe can see that the graph has 71 vertices, and that there are various **attributes** associated with each vertex, like gender, age, seniority, status in the law firm, etc. We can query those attributes using the `igraph` function `vertex_attr`, which takes the graph object as input. \n\n### Subsetting the Graph According to a Node Attribute\n\nTo keep things manageable, we will restrict our analysis to partners. To do that we need to select the **subgraph** that only includes the vertices with value of 1 in the \"status\" vertex attribute. From the [data description](https://rdrr.io/github/schochastics/networkdata/man/law_advice.html), we know the first 36 nodes (with value of 1 in the status attribute) are the law firm's partners (the rest are associates). In `igraph` we can do this as using the `subgraph` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- subgraph(d.g, 1:36)\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 36/36 vertices, from 14f08a2:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n```\n:::\n\n```{.r .cell-code}\n   V(d.g)$status\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n\nThe first line just tells `igraph` to generate the subgraph containing the first 36 nodes (the partners). The `subgraph` function thus takes two main inputs: The graph object, and then a vector of node ids (or node labels) telling the function which nodes to select to create the **node-induced subgraph**.\n\nOf course we already knew from the data description that the first 36 nodes where the partners. But let's say we have a large data set and we don't know *which* nodes are the partners. A smarter way of selecting a subgraph based on a node attribute is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   partners <- which(V(law_advice)$status == 1)\n   d.g <- subgraph(law_advice, partners)\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 36/36 vertices, from 14f709f:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n```\n:::\n:::\n\n\nThe first line using the native `R` vector function `which` allowing us to subset a vector based on a logical condition. The function takes a vector followed by a logical condition as input, and returns the *position* of the vector elements that meet that condition. In this case, we took the vector of values for the attribute of status and selected the node ids where status is equal to 1. We then fed that vector to the `subgraph` function in line 2. \n\nWe could do this with any other attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   older <- which(V(law_advice)$age > 50)\n   older\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 12 13 14 38 44\n```\n:::\n\n```{.r .cell-code}\n   og <- subgraph(law_advice, older)\n   V(og)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 15/15 vertices, from 14fd537:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n```\n:::\n:::\n\n\nHere we selected the subgraph (called \"og\", get it, get it) formed by the subset of nodes over the age of 50 at the firm. The values of the vector older tell us which of the 71 members meet the relevant condition. \n\n### Computing in and outdegree\n\nOK, going back to the partners subgraph, we can now create our (asymmetric) adjacency matrix and compute the row and column sums:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.A <- as_adjacency_matrix(d.g)\n   d.A <- as.matrix(d.A)\n   rowSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   colSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that in contrast to the undirected case the row and column sums give you two different sets of numbers. The row sums provide the directed graph's **outdegree set** (number of *outgoing* links incident to each node), and the column sums provide the graph's **indegree set** (number of *incoming* links incident to each node). So if you are high in the first vector, you are an *advice giver* (perhaps indicating informal status or experience) and if you are high in the second you are advice taker.\n\nOf course `igraph` has a dedicated function for this, which is just our old friend `degree` with an extra option `mode`, indicating whether you want the in or outdegrees:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.o <- degree(d.g, mode = \"out\")\n   d.i <- degree(d.g, mode = \"in\")\n   d.o\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   d.i\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that the graph attributes are just vectors of values, and can be accessed from the graph object using the $ operator attached to the `V()` function as we did above. \n\nSo if we wanted to figure out the correlation between some vertex attribute and in or out degree centrality, all we need to do is correlate the two vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   r <- cor(d.o, V(d.g)$age)\n   round(r, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.43\n```\n:::\n:::\n\n\nWhich tells us that at least in this case, younger partners are more sought after as sources of advice than older partners. \n\n\n## Closeness Centrality\n\nRecall that the **closeness centrality** is defined as the inverse of the sum of the *lengths* of shortest paths from each node to every other node. That means that to compute it, we first need to calculate the **geodesic distance matrix**. This is matrix in which each entry $g_{ij}$ records the length of the shortest path(s) between row node $i$ and column node $j$. Then, we sum the rows (or columns) of this symmetric matrix and then we obtain the inverse to get the closeness of each node:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(g) #length of shortest paths matrix\n   d.sum <- rowSums(S)\n   close1 <- round(1/d.sum, 4)\n   close1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n         0.0125          0.0108          0.0143          0.0125          0.0108 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n         0.0105          0.0070          0.0096          0.0104          0.0097 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n         0.0114          0.0093          0.0093          0.0132          0.0093 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n         0.0111          0.0104          0.0103          0.0098          0.0115 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n         0.0125          0.0111          0.0097          0.0097          0.0114 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n         0.0105          0.0125          0.0096          0.0057          0.0073 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n         0.0056          0.0139          0.0083          0.0105          0.0125 \n      YOUNG MAN     YOUNG WOMAN             ZED \n         0.0083          0.0083          0.0073 \n```\n:::\n:::\n\n\nOf course, we could have just used the available function in igraph and computed the closeness centrality directly from the graph object using the function `closeness`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   close2 <- round(closeness(g), 4)\n   close2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          BRETT           BUDDY           BUTCH      CAPT KOONS     ED SULLIVAN \n         0.0125          0.0108          0.0143          0.0125          0.0108 \n   ENGLISH DAVE       ESMARELDA        FABIENNE      FOURTH MAN       GAWKER #2 \n         0.0105          0.0070          0.0096          0.0104          0.0097 \n    HONEY BUNNY          JIMMIE            JODY           JULES           LANCE \n         0.0114          0.0093          0.0093          0.0132          0.0093 \n        MANAGER       MARSELLUS          MARVIN         MAYNARD             MIA \n         0.0111          0.0104          0.0103          0.0098          0.0115 \n         MOTHER          PATRON      PEDESTRIAN        PREACHER         PUMPKIN \n         0.0125          0.0111          0.0097          0.0097          0.0114 \n         RAQUEL           ROGER SPORTSCASTER #1 SPORTSCASTER #2        THE GIMP \n         0.0105          0.0125          0.0096          0.0057          0.0073 \n       THE WOLF         VINCENT        WAITRESS         WINSTON           WOMAN \n         0.0056          0.0139          0.0083          0.0105          0.0125 \n      YOUNG MAN     YOUNG WOMAN             ZED \n         0.0083          0.0083          0.0073 \n```\n:::\n:::\n\n\nOnce we have the closeness centrality values, we are interested in who are the top nodes. The following code creates a table with the top five:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(kableExtra)\n   close2 <- sort(close2, decreasing = TRUE)\n   close2 <- data.frame(close2[1:5])\n   kbl(close2, format = \"pipe\", align = c(\"l\", \"c\"),\n       col.names = c(\"Character\", \"Closeness\"),\n       caption = \"Top Five Closeness Characters in Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Top Five Closeness Characters in Pulp Fiction Network.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Character </th>\n   <th style=\"text-align:left;\"> Closeness </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> 0.0143 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:left;\"> 0.0139 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JULES </td>\n   <td style=\"text-align:left;\"> 0.0132 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BRETT </td>\n   <td style=\"text-align:left;\"> 0.0125 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CAPT KOONS </td>\n   <td style=\"text-align:left;\"> 0.0125 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nIt makes sense that the three main characters are also the ones that are at closest distances from everyone else!\n\n## Edge Closeness\n\n@brohl_lehnertz22 define the closeness of an edge as a function of the closeness of the two nodes incident to it. An edge $e_{jk}$ linking vertex $v_j$ to $v_k$ has high closeness whenever vertices $v_j$ and $v_k$ also have high closeness. \n\nMore specifically, the closeness centrality of an edge is proportional to the ratio of the product of the closeness of the two nodes incident to it divided by their sum:\n\n$$\nC(e_{jk}) = (E - 1)\\frac{C(v_j) \\times C(v_k)}{C(v_j)+C(v_k)}\n$$\n\nNote that the equation normalizes the ratio of the product to the sum of the vertex closeness centralities by the number of edges minus one.  \n\nTo compute edge closeness in a real network, we can use the same approach to data wrangling we used to compute the degree correlation in Handout 1. The goal is to create an edge list data frame containing five columns. The ids of the two nodes in the edge, the closeness centralities of the two nodes in the edge, and the closeness centrality of the edge calculated according to the above equation.\n\nIn the *Pulp Fiction* network this looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(dplyr)\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   c <- round(closeness(g), 3)  #closeness centrality vector\n   c.dat <- data.frame(name1 = names(c), name2 = names(c), c)\n   el.temp <- data.frame(name2 = g.el[, 2]) %>% \n      left_join(c.dat, by = \"name2\") %>% \n      dplyr::select(c(\"name2\", \"c\")) %>% \n      rename(c2 = c) \n   c.el <- data.frame(name1 = g.el[, 1]) %>% \n      left_join(c.dat, by = \"name1\") %>% \n      dplyr::select(c(\"name1\", \"c\")) %>% \n      rename(c1 = c) %>% \n      cbind(el.temp) %>% \n      mutate(e.clos = round((ecount(g)-1)*(c1*c2)/(c+c2), 3))\nhead(c.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name1    c1     name2    c2 e.clos\n1 BRETT 0.013 MARSELLUS 0.010  0.571\n2 BRETT 0.013    MARVIN 0.010  0.625\n3 BRETT 0.013     ROGER 0.013  0.632\n4 BRETT 0.013   VINCENT 0.014  0.681\n5 BUDDY 0.011       MIA 0.011  0.555\n6 BUDDY 0.011   VINCENT 0.014  0.622\n```\n:::\n:::\n\n\nTo create a table of the top five closeness centrality edges, we just order the data frame by the last column and table it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   c.el <- c.el[order(c.el$e.clos, decreasing = TRUE), ] %>% \n      dplyr::select(c(\"name1\", \"name2\", \"e.clos\"))\n\n   kbl(c.el[1:5, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Clos.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Closeness in the Pulp Fiction Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Edges Sorted by Closeness in the Pulp Fiction Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> i </th>\n   <th style=\"text-align:left;\"> j </th>\n   <th style=\"text-align:center;\"> Edge Clos. </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:center;\"> 0.900 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BRETT </td>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:center;\"> 0.875 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MOTHER </td>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:center;\"> 0.875 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> MIA </td>\n   <td style=\"text-align:center;\"> 0.864 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JULES </td>\n   <td style=\"text-align:left;\"> PUMPKIN </td>\n   <td style=\"text-align:center;\"> 0.850 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nInterestingly, the top closeness edges tend to bring somewhat strange bedfellows together, characters that themselves don't spend much time together in the film (e.g., the Butch/Vincent interaction is relatively brief and somewhat embarrassing for Vincent) but who themselves can reach other character clusters in the film via relatively short paths.\n\n## Closeness Centrality in Directed Graphs\nWhat about closeness centrality for a directed network? Let us see how this works using a **subgraph** of the advice network, this time selecting just women under the age of forty:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   women <- which(V(law_advice)$gender == 2)\n   wg <- subgraph(law_advice, women)\n   young <- which(V(wg)$age < 40)\n   wg <- subgraph(wg, young)\n   V(wg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 12/12 vertices, from 159163f:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n```\n:::\n:::\n\n\nThis network is small enough that a plot could be informative about its structure. Let us plot it using the package `ggraph`, a visualization package that follows the same principles as the `ggplot` grammar of graphics but for network graphs (see [here](https://exts.ggplot2.tidyverse.org/ggraph.html)).\n\n\n::: {.cell fig-cap-location='margin'}\n\n```{.r .cell-code}\n   #install.packages(\"ggraph\")\n   library(ggraph)\n    p <- ggraph(wg, layout = 'auto')\n    p <- p + geom_edge_parallel(color = \"steelblue\", edge_width = 0.5,\n                                arrow = arrow(length = unit(2.5, 'mm')),\n                                end_cap = circle(4, 'mm'), \n                                sep = unit(3, 'mm'))\n    p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = \"tan2\") \n    p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = \"white\")\n    p <- p + theme_graph() \n    p\n```\n\n::: {.cell-output-display}\n![Women lawyers advice network](centrality_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nNow a question we might ask is who has the greatest closeness centrality in this advice network. We could proceed as usual and compute the geodesic distances between actors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(wg)\n   S\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,]    0    1    2    1    3    3    4    2    2     3     3     3\n [2,]    1    0    2    1    2    3    3    1    1     3     3     3\n [3,]    2    2    0    1    1    1    2    2    3     1     1     1\n [4,]    1    1    1    0    2    2    3    2    2     2     2     2\n [5,]    3    2    1    2    0    1    1    1    2     2     2     2\n [6,]    3    3    1    2    1    0    2    2    3     1     2     1\n [7,]    4    3    2    3    1    2    0    2    3     3     3     3\n [8,]    2    1    2    2    1    2    2    0    1     3     3     3\n [9,]    2    1    3    2    2    3    3    1    0     4     4     4\n[10,]    3    3    1    2    2    1    3    3    4     0     1     1\n[11,]    3    3    1    2    2    2    3    3    4     1     0     1\n[12,]    3    3    1    2    2    1    3    3    4     1     1     0\n```\n:::\n:::\n\n\nNote that this is not quite right. In `igraph` the default settings of the distance function treats the graph as undirected. So it doesn't use the strict **directed paths**, but it just treats them all as **semi-paths** ignoring direction. That is why, for instance, it counts node 1 as being \"adjacent\" to node 4 even though there is only one incoming link from 4 to 1 and why the whole matrix is symmetric, when we know from just eyeballing the network that there is a lot of asymmetry in terms of who can reach who via directed paths. \n\nTo get the actual directed distance matrix, we need to specify the \"mode\" option, asking whether we want in or out paths. Here, let's select out-paths:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(wg, mode = \"out\")\n   S\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,]    0    1  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf   Inf   Inf\n [2,]    1    0  Inf  Inf  Inf  Inf  Inf  Inf  Inf   Inf   Inf   Inf\n [3,]    2    2    0    1  Inf    1  Inf  Inf  Inf   Inf   Inf   Inf\n [4,]    1    1    1    0  Inf    2  Inf  Inf  Inf   Inf   Inf   Inf\n [5,]    3    2    1    2    0    1    1    1    2   Inf   Inf   Inf\n [6,]    3    3    1    2  Inf    0  Inf  Inf  Inf   Inf   Inf   Inf\n [7,]    4    3    2    3    1    2    0    2    3   Inf   Inf   Inf\n [8,]    2    1  Inf  Inf  Inf  Inf  Inf    0    1   Inf   Inf   Inf\n [9,]    2    1  Inf  Inf  Inf  Inf  Inf    1    0   Inf   Inf   Inf\n[10,]    3    3    1    2  Inf    1  Inf  Inf  Inf     0     1     2\n[11,]    3    3    1    2  Inf    2  Inf  Inf  Inf     1     0     1\n[12,]    3    3    1    2  Inf    1  Inf  Inf  Inf     1     1     0\n```\n:::\n:::\n\n\nThis is better but introduces a problem. The directed graph is not **strongly connected**, so it means that some nodes cannot reach other ones via a directed path of *any* length. That means that the **geodesic distances** from a node to an unreachable node is coded as \"infinite\" (Inf). The problem with infinity is that it gets in the way of calculating sums of distances, a requirement for the closeness centrality. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(wg, mode = \"out\")\n   rowSums(S)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf\n```\n:::\n:::\n\n\nAdding infinity to a number just returns infinity so all the rows with at least one \"Inf\" in the distance matrix get an Inf for the row sum. In this case that's all of them. A bummer.\n\n### Harmonic Centrality\nBut dont' worry there's a [patch](https://olizardo.github.io/networks-textbook/lesson-sna-closeness.html#houston-we-have-a-problem). It is called the **harmonic centrality** [@rochat09].^[@agneessens_etal17 call the harmonic centrality \"reciprocal closeness\"] This is a variation on the closeness centrality that works whether you are working with connected or disconnected graphs (or in the case of directed graphs regardless of whether the graph is strongly or weakly connected), and therefore regardless of whether the geodesic distance matrix contains Infs.^[Some people [@boldi_vigna14] claim that the harmonic centrality is the *only* centrality measure that could be called by that name from a purely axiomatic mathematical approach, but that's a different story.]  \n\nThe main difference between the harmonic and regular closeness centrality is that instead of calculating the inverse of the sum of the distances for each node, we calculate the *sum of the inverses*:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(wg, mode = \"out\")\n   S = round(1/S, 2) \n   diag(S) <- 0 #setting diagonals to zero\n   S\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n [1,] 0.00 1.00  0.0 0.00    0  0.0    0  0.0 0.00     0     0   0.0\n [2,] 1.00 0.00  0.0 0.00    0  0.0    0  0.0 0.00     0     0   0.0\n [3,] 0.50 0.50  0.0 1.00    0  1.0    0  0.0 0.00     0     0   0.0\n [4,] 1.00 1.00  1.0 0.00    0  0.5    0  0.0 0.00     0     0   0.0\n [5,] 0.33 0.50  1.0 0.50    0  1.0    1  1.0 0.50     0     0   0.0\n [6,] 0.33 0.33  1.0 0.50    0  0.0    0  0.0 0.00     0     0   0.0\n [7,] 0.25 0.33  0.5 0.33    1  0.5    0  0.5 0.33     0     0   0.0\n [8,] 0.50 1.00  0.0 0.00    0  0.0    0  0.0 1.00     0     0   0.0\n [9,] 0.50 1.00  0.0 0.00    0  0.0    0  1.0 0.00     0     0   0.0\n[10,] 0.33 0.33  1.0 0.50    0  1.0    0  0.0 0.00     0     1   0.5\n[11,] 0.33 0.33  1.0 0.50    0  0.5    0  0.0 0.00     1     0   1.0\n[12,] 0.33 0.33  1.0 0.50    0  1.0    0  0.0 0.00     1     1   0.0\n```\n:::\n:::\n\n\nNote that in this matrix of inverse distances, the closest (adjacent) nodes get the maximum score of one, and nodes farther apart when smaller scores (approaching zero). More importantly, those pesky Infs disappear (!) because unreachable directed pairs of nodes get the lowest score, corresponding to $1/\\infty = 0$. Turns out the mathematics of infinity weren't our enemy after all. \n\nAlso note that the reachability relation expressed in this matrix is asymmetric: So node 4 and reach node 1 (there is a directed tie from 4 to 1), but node 1 cannot reach 4. This is precisely what we want. \n\nOnce we have this matrix of inverse distances, we can then we can compute the harmonic centrality the same way as regular closeness by adding up the row scores for each node and dividing by the number of nodes minus one (to get the average):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.harm <- rowSums(S)\n   d.harm <- d.harm/(vcount(wg) - 1)\n   d.harm <- round(d.harm, 2)\n   d.harm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.09 0.09 0.27 0.32 0.53 0.20 0.34 0.23 0.23 0.42 0.42 0.47\n```\n:::\n:::\n\n\nWe can see that the highest harmonic closeness centrality node is 5, followed by 12. Here's a plot of the network highlighting the highest harmonic (closeness) centrality node. \n\n\n::: {.cell fig-cap-location='margin'}\n\n```{.r .cell-code}\n   col <- rep(\"tan2\", vcount(wg)) #creating node color vector\n   col[which(d.harm == max(d.harm))] <- \"red\" #changing color of max centrality node to red\n   p <- p + geom_node_point(aes(x = x, y = y), size = 8, color = col)\n   p <- p + geom_node_text(aes(label = 1:vcount(wg)), size = 4, color = \"white\")\n   p\n```\n\n::: {.cell-output-display}\n![Women lawyers advice network with highest closeness centrality node in red](centrality_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nOf course, `igraph` has a built in function to calculate the harmonic centrality called (you guessed it) `harmonic_centrality`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.harm <- harmonic_centrality(wg, normalized = TRUE)\n   d.harm <- round(d.harm, 2)\n   d.harm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.09 0.09 0.27 0.32 0.53 0.20 0.34 0.23 0.23 0.42 0.42 0.47\n```\n:::\n:::\n\n\nWhich gives us the same results.\n\n## Generalized Harmonic Centrality\n\n@agneessens_etal17 propose a \"generalized\" version of the harmonic centrality that yields plain old degree centrality and the regular harmonic centrality as special cases. The key is to introduce a parameter $\\delta$ governing how much weight we give to shortest paths based on distance. Let's see how this works. \n\nRecall that the harmonic centrality we defined earlier is given by:\n\n$$\n\\frac{\\sum_{j \\neq i} (g_{ij})^{-1}}{n-1} \n$$\n\nFor any node $i$, where $g_{ij}$ is the geodesic distance between $i$ and every other node in the graph $j$, which could be \"infinite\" if there is no path linking them. \n\nAgneessens et al's tweak is to instead compute:\n\n$$\n\\frac{\\sum_{j \\neq i} (g_{ij})^{-\\delta}}{n-1} \n$$\n\nWhere $\\delta$ is a free parameter chosen by the researcher with the restriction that $\\delta \\geq 0$ (if you want to calculate a closeness measure as we will see below). \n\nWhen $\\delta = \\infty$ the numerator element $1/(g_{ij})^{\\infty} = 1$ only when nodes are adjacent and $g_{ij} = 1$ (because $1^{\\infty} = 1$); otherwise, for $g_{ij} > 1$ then $1/(g_{ij})^{\\infty} = 0$, and therefore the generalized harmonic centrality just becomes a (normalized) version of degree centrality. Alternatively, when $\\delta = 1$ we just get the plain old harmonic centrality we defined earlier.\n\nThe interesting cases come from $1 > \\delta < \\infty$ and $0 > \\delta < 1$. In the first case, nodes at shorter distances are weighted more (like in the standard harmonic centrality measure) as $\\delta$ becomes bigger and bigger then the generalized harmonic centrality approximates degree. For values below one, as $\\delta$ approaches zero, then indirect connections to nodes of greater length are discounted less, and thus count for \"more\" in defining your generalized harmonic centrality score.\n\nLet us see a real-world example of the generalized harmonic centrality in action:\n\nFirst, we create a custom function to compute the generalized harmonic centrality:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.harm <- function(x, d) {\n      library(igraph)\n      S <- distances(x) #get distances from graph object\n      S <- 1/S^d #matrix of generalized inverse distances\n      diag(S) <- 0 #set diagonals to zero\n      c <- rowSums(S)/(vcount(x) - 1) #summing and averaging\n      return(c)\n   }\n```\n:::\n\n\nSecond, we compute three versions of the harmonic centrality, with $\\delta = 5$, $\\delta = 0.05$, and $\\delta = -5$, using the full (unrestricted by age) subgraph of the `law_advice` network composed of the women lawyers at the firm, with relations constrained to be undirected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   women <- which(V(law_advice)$gender == 2)\n   wg <- subgraph(law_advice, women)\n   wg <- as.undirected(wg)\n   c1 <- g.harm(wg, d = 5)\n   c2 <- g.harm(wg, d = 0.05)\n   c3 <- g.harm(wg, d = -5)\n```\n:::\n\n\n- The first version of the harmonic centrality in line 5, with a positive value of $\\delta$ above zero, will compute centrality scores emphasizing *direct* (one-step) connections, thus coming closer to **degree**. \n\n- The second version, in line 6, with a value of $\\delta$ close to zero, will give comparatively more emphasis to *indirect* connections weighing longer paths almost as much as shorter paths (but always a little less), thus being more similar to **closeness** centrality. \n\n- Finally, the last version, in line 7, with $\\delta < 0$, will weigh *longer* paths more than shorter ones, serving as a measure of **eccentricity** (farness from others) not closeness. \n\n\n\n::: {.cell fig-cap-location='margin'}\n::: {.cell-output-display}\n![Full women lawyers advice network](centrality_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nAbove is a plot of the women lawyers network showing the top node for each of the centralities:\n\n- In red we have node 3 who has the largest degree ($k(3) = 8$) and thus comes out on top using the generalized harmonic centrality version emphasizing direct connections ($\\delta > 1$). \n\n- Then in blue we have node 9 who can reach the most others via the shortest paths, and thus comes out on top when the generalized harmonic centrality emphasizes indirect connectivity. \n\n- Finally, in purple we have node 12, which is *farthest* from everyone else, and thus comes out on \"top\" when longer indirect connections count for more ($\\delta < 0)$. \n\nAs we said earlier, both regular harmonic centrality and degree are special cases of the generalized measure. We can check this by setting $\\delta$ to either one or infinity.\n\nWhen we set $\\delta=1$ the generalized harmonic centrality is the same as (normalized by number of nodes minus one) the regular harmonic centrality:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.harm(wg, d = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.5980392 0.5343137 0.7058824 0.5980392 0.6568627 0.6274510 0.4264706\n [8] 0.5392157 0.6960784 0.6470588 0.6666667 0.4068627 0.5882353 0.5196078\n[15] 0.5833333 0.6029412 0.5588235 0.5441176\n```\n:::\n\n```{.r .cell-code}\n   harmonic_centrality(wg, normalized = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.5980392 0.5343137 0.7058824 0.5980392 0.6568627 0.6274510 0.4264706\n [8] 0.5392157 0.6960784 0.6470588 0.6666667 0.4068627 0.5882353 0.5196078\n[15] 0.5833333 0.6029412 0.5588235 0.5441176\n```\n:::\n:::\n\n\nWhen we set $\\delta=\\infty$ the generalized harmonic centrality is the same as (normalized by number of nodes minus one) degree centrality:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.harm(wg, d = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.23529412 0.17647059 0.47058824 0.23529412 0.35294118 0.29411765\n [7] 0.05882353 0.17647059 0.41176471 0.35294118 0.41176471 0.05882353\n[13] 0.23529412 0.17647059 0.23529412 0.35294118 0.23529412 0.23529412\n```\n:::\n\n```{.r .cell-code}\n   degree(wg, normalized = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.23529412 0.17647059 0.47058824 0.23529412 0.35294118 0.29411765\n [7] 0.05882353 0.17647059 0.41176471 0.35294118 0.41176471 0.05882353\n[13] 0.23529412 0.17647059 0.23529412 0.35294118 0.23529412 0.23529412\n```\n:::\n:::\n\n\n## Betweenness\n\nWe finally come to betweenness centrality. Recall that the key conceptual distinction between closeness and betweenness according to @freeman79 is that between (pun intended) the capacity to reach others quickly (e.g., via the shortest paths) and the capacity to *intermediate* among those same paths. High betweenness nodes control the flow of information in the network between other nodes.\n\nThis is evident in the way betweenness is calculated. Recall that the betweenness of a node *k* relative to any pair of nodes *i* and *j* in the network is simply:\n\n$$\n\\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n$$\n\nWhere the denominator of the fraction ($\\sigma_{ij}$) is a count of the *total* number of shortest paths that start and end with nodes *i* and *j* and the numerator of the fraction ($\\sigma_{i(k)j}$) is the subset of those paths that include node *k* as an **inner node**.\n\nAs @freeman79 also notes because this is a ratio, it can range from zero to one,  with everything in between. As such the betweenness centrality of a node relative to any two others has an intuitive interpretation as a *probability*, namely the probability that if you send something from *i* to *j* it has to go *through* *k*. This probability is 1.0 if *k* stands in *every* shortest path between *i* and *j* and zero if they stand in none of the shortest paths indirectly connecting *i* and *j*. \n\nThe betweenness of a given node is just the sum all of these probabilities across every pair of nodes in the graph for each node:\n\n$$\n\\sum_{i \\neq j, i \\neq n, j \\neq v} \\frac{\\sigma_{i(k)j}}{\\sigma_{ij}}\n$$\n\nBelow we can see a point and line diagram of the undirected *Pulp Fiction* network we have been working with. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![Pulp Fiction character schene co-appearance network.](centrality_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nWe should expect a character to have high betweenness in this network to the extent that they appear in scenes with characters who themselves don't appear in any scenes together, thus inter-mediating between different parts of the story. Characters who only appear in one scene with some others (like The Wolf or The Gimp) are likely to be low in betweenness.\n\nLet's create a top ten table of betweenness for the *Pulp Fiction* network. We use the `igraph` function `betweenness` to calculate the scores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   pulp.bet <- betweenness(g)\n   top.5.bet <- sort(pulp.bet, decreasing = TRUE)[1:10]\n   kbl(round(top.5.bet, 2), format = \"pipe\", align = c(\"l\", \"c\"),\n       col.names = c(\"Character\", \"Betweenness\"),\n       caption = \"Top Five Betweenness Characters in Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Top Five Betweenness Characters in Pulp Fiction Network.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Character </th>\n   <th style=\"text-align:left;\"> Betweenness </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> BUTCH </td>\n   <td style=\"text-align:left;\"> 275.52 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> VINCENT </td>\n   <td style=\"text-align:left;\"> 230.19 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> JULES </td>\n   <td style=\"text-align:left;\"> 142.11 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MIA </td>\n   <td style=\"text-align:left;\"> 76.68 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MAYNARD </td>\n   <td style=\"text-align:left;\"> 70.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> HONEY BUNNY </td>\n   <td style=\"text-align:left;\"> 49.97 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PUMPKIN </td>\n   <td style=\"text-align:left;\"> 49.97 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SPORTSCASTER #1 </td>\n   <td style=\"text-align:left;\"> 36.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> BRETT </td>\n   <td style=\"text-align:left;\"> 29.85 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PREACHER </td>\n   <td style=\"text-align:left;\"> 28.23 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nUnsurprisingly, the top four characters are also the highest in betweenness. Somewhat surprisingly, the main antagonist of the story (the pawn shop owner) is also up there. After that we see a big drop in the bottom five of the top ten. \n\nNow let us examine betweenness centrality in our directed young women lawyers advice network:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   women <- which(V(law_advice)$gender == 2)\n   wg <- subgraph(law_advice, women)\n   young <- which(V(wg)$age < 40)\n   wg <- subgraph(wg, young)\n   w.bet <- betweenness(wg)\n   w.bet\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.0000000  3.0000000 16.3333333 11.0000000  7.0000000  0.0000000\n [7]  0.0000000  5.0000000  0.0000000  0.3333333  1.0000000  0.3333333\n```\n:::\n:::\n\n\nHere we see that node 3 is the highest in betweenness, pictured below:\n\n\n::: {.cell fig-cap-location='margin'}\n::: {.cell-output-display}\n![Women lawyers advice network with highest closeness centrality node in blue and highest betweenness centrality node in red](centrality_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nThis result makes sense. Node 3 intermediates all  the connections linking the tightly knit group of nodes on the left side (6, 10, 11, 12) with the rest of the network. Also if nodes 5 and 7 need to pass something along to the rest, they have to use 3 at least half time. Node 4 also needs 3 to reach 6. \n\nThis result nicely illustrates the difference between closeness and betweenness. \n\n## Edge Betweenness\n\nEdge betweenness is defined in similar fashion as node betweenness:\n\n$$\n\\sum_{i \\neq j} \\frac{\\sigma_{i(e)j}}{\\sigma_{ij}}\n$$\n\nWhere $\\sigma_{i(e)j}$ is a count of the number of shortest paths between *i* and *j* that feature edge *e* as an intermediary link. This tells us that the betweenness of an edge *e* is the sum of the ratios of the number of times that edge appears in the middle of a shortest path connecting every pair of nodes in the graph *i* and *j* divided by the total number of shortest paths linking each pair of nodes. \n\nLike before, the edge betweenness with respect to a specific pair of nodes in the graph is a probability: Namely, that if you send something--using a shortest path--from any node *i* to any other node *j* it has to go through edge *e*. The resulting edge betweenness scores is the sum of these probabilities across every possible pair of nodes for each edge in the graph. \n\nFor this example, we will work with a simplified version of the women lawyers advice network, in which we transform it into an **undirected** graph. We use the `igraph` function `as.undirected` for that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   wg <- as.undirected(wg, mode = \"collapse\")\n```\n:::\n\n\nThe \"collapse\" value in the \"mode\" argument tells `as.undirected` to link every connected dyad in the original directed graph using an undirected edge. It does that by removing the directional arrow of the single directed links and collapsing (hence the name) all the bi-directional links into a single undirected one.  \n\nThe resulting undirected graph looks like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](centrality_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nLooking at this point and line plot of the women lawyers advice network, which edge do you think has the top betweenness? \n\nWell no need to figure that out via eyeballing! We can just use the `igraph` function `edge_betweenness`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   w.ebet <- edge_betweenness(wg)\n```\n:::\n\n\nThe `edge_betweenness` function takes the `igraph` graph object as input and produces a vector of edge betweenness values of the same length as the number of edges in the graph, which happens to be 20 in this case.\n\nUsing this information, we can then create a table of the top ten edges ordered by betweenness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   edges <- as_edgelist(wg) #creating an edgelist\n   etab <- data.frame(edges, bet = round(w.ebet, 2)) #adding bet. scores to edgelist\n   etab <- etab[order(etab$bet, decreasing = TRUE), ] #ordering by bet.\n   kbl(etab[1:10, ], format = \"pipe\", align = c(\"l\", \"l\", \"c\"),\n       col.names = c(\"i\", \"j\", \"Edge Bet.\"), row.names = FALSE,\n       caption = \"Edges Sorted by Betweenness in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Edges Sorted by Betweenness in the Women Lawyers Advice Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> i </th>\n   <th style=\"text-align:left;\"> j </th>\n   <th style=\"text-align:center;\"> Edge Bet. </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 19.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:center;\"> 15.83 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:center;\"> 13.67 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 7 </td>\n   <td style=\"text-align:center;\"> 11.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 9.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> 11 </td>\n   <td style=\"text-align:center;\"> 8.33 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> 6 </td>\n   <td style=\"text-align:center;\"> 8.17 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> 7.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:center;\"> 6.50 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:left;\"> 9 </td>\n   <td style=\"text-align:center;\"> 6.33 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nNot surprisingly, the top edges are the ones linking nodes 3 and 4 and nodes 5 and 8. \n\n### Disconnecting a Graph Via Bridge Removal\n\nHigh betweenness edges are likely to function as **bridges** being the only point of indirect connectivity between most nodes in the social structure. That means that an easy way to disconnect a connected graph is to remove the bridges [@girvan_newman02].\n\nIn `igraph` we can produce an **edge deleted subgraph** of an original graph using the \"minus\" operator, along with the `edge` function like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   del.g <- wg - edge(\"3|4\")\n   del.g <- del.g - edge(\"5|8\")\n```\n:::\n\n\nThe first line creates a new graph object (a subgraph) which equals the original graph minus the edge linking nodes 3 and 4. The second line takes this last subgraph and further deletes the edge linking nodes 5 and 8. \n\nThe resulting subgraph, minus the top two high-betweenness edges, looks like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](centrality_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nWhich is indeed disconnected!\n\n## Induced Betweenness\n\n@borgatti_everett20 [p. 340-345] argue that another way of thinking about centrality of a node (or edge) is to calculate the difference that *removing* that node makes for some graph property in the network. They further suggest that the sum of the centrality scores of each node is just such a property, proposing that betweenness is particularly interesting in this regard. Let's see how this works. \n\nWe will use the undirected version of the women lawyers advice network for this example. Let's say we are interested in the difference that node 10 makes for the betweenness centralities of everyone else. In that case we would proceed as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   bet <- betweenness(wg) #original centrality scores\n   Sbet <- sum(bet) #sum of original centrality scores\n   wg.d <- wg - vertex(\"10\") #removing vertex 10 from the graph\n   bet.d <- betweenness(wg.d) #centrality scores of node deleted subgraph\n   Sbet.d <- sum(bet.d) #sum of centrality scores of node deleted subgraph\n   total.c <- Sbet - Sbet.d #total centrality\n   indirect.c <- total.c - bet[10] #indirect centrality\n   indirect.c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12.66667\n```\n:::\n:::\n\n\nLine 1 just calculates the regular betweenness centrality vector for the graph. Line 2 sums up all of the entries of this vector. Line 3 creates a node deleted subgraph by removing node 10. This is done using the \"minus\" operator and the `igraph` function `vertex`, which works just like the `edge` function we used earlier to create an edge deleted subgraph, except it takes a node id or name as input.\n\nLines 4-5 just recalculate the sum of betweenness centralities in the subgraph that excludes node 10. Then in line 6 we subtract the sum of centralities of the node deleted subgraph from the sum of centralities of the original graph. If this number, which Borgatti and Everett call the \"total\" centrality, is large and positive then that means that node 10 makes a difference for the centrality of others. \n\nHowever, part of that difference is node 10's own \"direct\" centrality, so to get a more accurate sense of node 10's impact on other people's centrality we need to subtract node 10's direct centrality from the total number, which we do in line 7 to get node 10's \"indirect\" centrality. The result is shown in the last line, which indicates that node 10 has a pretty big impact on other people's betweenness centralities, net of their own (which is pretty small). \n\nNow all we need to do is do the same for each node to create a vector of indirect betweenness centralities. So we incorporate the code above into a short loop through all vertices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   total.c <- 0 #empty vector\n   indirect.c <- 0 #empty vector\n   for (i in 1:vcount(wg)) {\n      wg.d <- wg - vertex(i)\n      bet.d <- betweenness(wg.d) #centrality scores of node deleted subgraph\n      Sbet.d <- sum(bet.d) #sum of centrality scores of node deleted subgraph\n      total.c[i] <- Sbet - Sbet.d #total centrality\n   indirect.c[i] <- total.c[i] - bet[i] #total minus direct\n   }\n```\n:::\n\n\nWe can now list the total, direct, and indirect betweenness centralities for the women lawyers graph using a nice table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   i.bet <- data.frame(n = 1:vcount(wg), total.c, round(betweenness(wg), 1), round(indirect.c, 1))\n   kbl(i.bet, format = \"pipe\", align = c(\"l\", \"c\", \"c\", \"c\"),\n       col.names = c(\"Node\", \"Total\", \"Direct\", \"Indirect\"), row.names = FALSE,\n       caption = \"Induced Betweenness Scores in the Women Lawyers Advice Network\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Induced Betweenness Scores in the Women Lawyers Advice Network</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Node </th>\n   <th style=\"text-align:center;\"> Total </th>\n   <th style=\"text-align:center;\"> Direct </th>\n   <th style=\"text-align:center;\"> Indirect </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:center;\"> 16 </td>\n   <td style=\"text-align:center;\"> 0.0 </td>\n   <td style=\"text-align:center;\"> 16.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:center;\"> 4 </td>\n   <td style=\"text-align:center;\"> 6.7 </td>\n   <td style=\"text-align:center;\"> -2.7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:center;\"> -24 </td>\n   <td style=\"text-align:center;\"> 23.2 </td>\n   <td style=\"text-align:center;\"> -47.2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:center;\"> -4 </td>\n   <td style=\"text-align:center;\"> 12.2 </td>\n   <td style=\"text-align:center;\"> -16.2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:center;\"> 19 </td>\n   <td style=\"text-align:center;\"> 18.8 </td>\n   <td style=\"text-align:center;\"> 0.2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 6 </td>\n   <td style=\"text-align:center;\"> 10 </td>\n   <td style=\"text-align:center;\"> 3.7 </td>\n   <td style=\"text-align:center;\"> 6.3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 7 </td>\n   <td style=\"text-align:center;\"> 18 </td>\n   <td style=\"text-align:center;\"> 0.0 </td>\n   <td style=\"text-align:center;\"> 18.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 8 </td>\n   <td style=\"text-align:center;\"> 4 </td>\n   <td style=\"text-align:center;\"> 8.8 </td>\n   <td style=\"text-align:center;\"> -4.8 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 9 </td>\n   <td style=\"text-align:center;\"> 18 </td>\n   <td style=\"text-align:center;\"> 0.0 </td>\n   <td style=\"text-align:center;\"> 18.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 10 </td>\n   <td style=\"text-align:center;\"> 13 </td>\n   <td style=\"text-align:center;\"> 0.3 </td>\n   <td style=\"text-align:center;\"> 12.7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 11 </td>\n   <td style=\"text-align:center;\"> 14 </td>\n   <td style=\"text-align:center;\"> 0.0 </td>\n   <td style=\"text-align:center;\"> 14.0 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 12 </td>\n   <td style=\"text-align:center;\"> 13 </td>\n   <td style=\"text-align:center;\"> 0.3 </td>\n   <td style=\"text-align:center;\"> 12.7 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nThis approach to decomposing betweenness centrality provides a new way to categorize actors in a network: \n\n- On the one hand, we have actors like nodes 3 and 4 who \"hog\" centrality from others. Perhaps these are the prototypical high betweenness actors who monopolize the flow through the network. Their own direct centrality is high, but their indirect centrality is negative, suggesting that others become *more* central when they are removed from the graph as they can now become intermediaries themselves.\n\n- In contrast, we also have actors like node 5 who are high centrality themselves, but who's removal from the network does not affect anyone else's centrality. These actors are high betweenness but themselves don't monopolize the flow of information in the network. \n\n- Then we have actors (like nodes 9-12) who have low centrality, but whose removal from the network makes a positive difference for other people's centrality, which overall *decreases* when they are removed from the network. \n\n- Finally, we have actors line nodes 2 and 8, who are not particularly central, but who also hog centrality from others, in that removing them from the network also increases other people's centrality (although not such an extent as the hogs). \n\n\n\n\n",
    "supporting": [
      "centrality_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}