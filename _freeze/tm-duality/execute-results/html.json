{
  "hash": "e04ea29966d2fa877e4afee43fa8828b",
  "result": {
    "markdown": "---\ntitle: \"The Duality of Persons and Groups\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nRecall that in the [one-mode case](prestige.qmd), multiplying the adjacency matrix times its transpose yields the **common neighbors matrix** $\\mathbf{M}$:\n\n$$\n\\mathbf{M} = \\mathbf{A}\\mathbf{A}^T\n$$\n\nAs famously noted by @breiger74, doing the same for the affiliation matrix of a two-mode network also returns the common-neighbors matrix, but because objects in one mode can only connect to objects in another mode, this also reveals the **duality of persons and groups**: The connections between people are made up of the groups they share, and the connections between groups are revealed by the groups they share.\n\nThus, computing the common neighbors matrix for both persons and groups (also called the **projection** of the two-mode network into each of its modes) produces a one-mode similarity matrix between people and groups, where the similarities are defined by the number of objects in the other mode that they share. \n\nFor the people the relevant projection is:\n\n$$\n\\mathbf{P} = \\mathbf{A}\\mathbf{A}^T\n$$ {#eq-p}\n\nAnd for the groups:\n\n$$\n\\mathbf{G} = \\mathbf{A}^T\\mathbf{A}\n$$ {#eq-g}\n\nLet's see how this works out with real data by loading our usual friend the *Southern Women* data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(igraph)\n    library(networkdata)\n    g <- southern_women\n    library(stringr) #using stringr to change names from all caps to title case\n    V(g)$name <- str_to_title(V(g)$name)\n```\n:::\n\n\nIn this case, equations @eq-g and @eq-p yield:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as_biadjacency_matrix(g)\n   P <- A %*% t(A)\n   P\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Evelyn Laura Theresa Brenda Charlotte Frances Eleanor Pearl Ruth\nEvelyn         8     6       7      6         3       4       3     3    3\nLaura          6     7       6      6         3       4       4     2    3\nTheresa        7     6       8      6         4       4       4     3    4\nBrenda         6     6       6      7         4       4       4     2    3\nCharlotte      3     3       4      4         4       2       2     0    2\nFrances        4     4       4      4         2       4       3     2    2\nEleanor        3     4       4      4         2       3       4     2    3\nPearl          3     2       3      2         0       2       2     3    2\nRuth           3     3       4      3         2       2       3     2    4\nVerne          2     2       3      2         1       1       2     2    3\nMyrna          2     1       2      1         0       1       1     2    2\nKatherine      2     1       2      1         0       1       1     2    2\nSylvia         2     2       3      2         1       1       2     2    3\nNora           2     2       3      2         1       1       2     2    2\nHelen          1     2       2      2         1       1       2     1    2\nDorothy        2     1       2      1         0       1       1     2    2\nOlivia         1     0       1      0         0       0       0     1    1\nFlora          1     0       1      0         0       0       0     1    1\n          Verne Myrna Katherine Sylvia Nora Helen Dorothy Olivia Flora\nEvelyn        2     2         2      2    2     1       2      1     1\nLaura         2     1         1      2    2     2       1      0     0\nTheresa       3     2         2      3    3     2       2      1     1\nBrenda        2     1         1      2    2     2       1      0     0\nCharlotte     1     0         0      1    1     1       0      0     0\nFrances       1     1         1      1    1     1       1      0     0\nEleanor       2     1         1      2    2     2       1      0     0\nPearl         2     2         2      2    2     1       2      1     1\nRuth          3     2         2      3    2     2       2      1     1\nVerne         4     3         3      4    3     3       2      1     1\nMyrna         3     4         4      4    3     3       2      1     1\nKatherine     3     4         6      6    5     3       2      1     1\nSylvia        4     4         6      7    6     4       2      1     1\nNora          3     3         5      6    8     4       1      2     2\nHelen         3     3         3      4    4     5       1      1     1\nDorothy       2     2         2      2    1     1       2      1     1\nOlivia        1     1         1      1    2     1       1      2     2\nFlora         1     1         1      1    2     1       1      2     2\n```\n:::\n\n```{.r .cell-code}\n   G <- t(A) %*% A\n   G\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     3   2    3    2    3    3    2    3   1    0    0   0     0   0\n3/2      2   3    3    2    3    3    2    3   2    0    0   0     0   0\n4/12     3   3    6    4    6    5    4    5   2    0    0   0     0   0\n9/26     2   2    4    4    4    3    3    3   2    0    0   0     0   0\n2/25     3   3    6    4    8    6    6    7   3    0    0   0     0   0\n5/19     3   3    5    3    6    8    5    7   4    1    1   1     1   1\n3/15     2   2    4    3    6    5   10    8   5    3    2   4     2   2\n9/16     3   3    5    3    7    7    8   14   9    4    1   5     2   2\n4/8      1   2    2    2    3    4    5    9  12    4    3   5     3   3\n6/10     0   0    0    0    0    1    3    4   4    5    2   5     3   3\n2/23     0   0    0    0    0    1    2    1   3    2    4   2     1   1\n4/7      0   0    0    0    0    1    4    5   5    5    2   6     3   3\n11/21    0   0    0    0    0    1    2    2   3    3    1   3     3   3\n8/3      0   0    0    0    0    1    2    2   3    3    1   3     3   3\n```\n:::\n:::\n\n\nThe off-diagonal entries of these square person by person (group by group) matrices is the number of groups (people) shared by each person (group) and the diagonals are the number of memberships of each person (the size of each group/event).\n\nIn `igraph` the  relevant function is called `bipartite_projection`. It takes a bipartite graph as an input and returns a list containing `igraph` graph objects of both projections by default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Proj <- bipartite_projection(g)\n   G.p <- Proj[[1]]\n   G.g <- Proj[[2]]\n```\n:::\n\n\nIn the graph objects produced by the `bipartite_projection` function, the actual shared memberships and shared members are stored as an *attribute* of each edge called `weight` used in the plotting code for @fig-projection to set the `edge.width`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   edge_attr(G.p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$weight\n  [1] 6 6 7 3 4 3 3 3 2 2 2 2 2 1 2 1 1 6 6 3 4 4 3 2 2 2 2 2 1 1 1 6 4 4 4 4 3\n [38] 3 3 3 2 2 2 2 1 1 4 4 4 3 2 2 2 2 2 1 1 1 2 2 2 1 1 1 1 3 2 2 1 1 1 1 1 1\n [75] 1 3 2 2 2 2 2 1 1 1 2 2 2 2 2 2 1 2 1 1 3 3 2 2 2 2 2 1 1 4 3 3 3 3 2 1 1\n[112] 4 4 3 2 3 1 1 6 3 2 5 1 1 6 4 2 1 1 4 1 2 2 1 1 1 1 1 2\n```\n:::\n\n```{.r .cell-code}\n   edge_attr(G.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$weight\n [1] 2 3 2 3 3 3 1 2 3 2 3 3 3 2 2 4 6 5 5 2 4 4 3 3 2 3 6 7 3 6 7 4 5 1 1 1 1 1\n[39] 8 5 4 3 2 2 2 9 5 4 2 2 1 5 4 3 3 3 5 3 3 2 2 1 1 3 3 3\n```\n:::\n:::\n\n\nSo to get the weighted projection matrix, we need to type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   as.matrix(as_adjacency_matrix(G.p, attr = \"weight\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Evelyn Laura Theresa Brenda Charlotte Frances Eleanor Pearl Ruth\nEvelyn         0     6       7      6         3       4       3     3    3\nLaura          6     0       6      6         3       4       4     2    3\nTheresa        7     6       0      6         4       4       4     3    4\nBrenda         6     6       6      0         4       4       4     2    3\nCharlotte      3     3       4      4         0       2       2     0    2\nFrances        4     4       4      4         2       0       3     2    2\nEleanor        3     4       4      4         2       3       0     2    3\nPearl          3     2       3      2         0       2       2     0    2\nRuth           3     3       4      3         2       2       3     2    0\nVerne          2     2       3      2         1       1       2     2    3\nMyrna          2     1       2      1         0       1       1     2    2\nKatherine      2     1       2      1         0       1       1     2    2\nSylvia         2     2       3      2         1       1       2     2    3\nNora           2     2       3      2         1       1       2     2    2\nHelen          1     2       2      2         1       1       2     1    2\nDorothy        2     1       2      1         0       1       1     2    2\nOlivia         1     0       1      0         0       0       0     1    1\nFlora          1     0       1      0         0       0       0     1    1\n          Verne Myrna Katherine Sylvia Nora Helen Dorothy Olivia Flora\nEvelyn        2     2         2      2    2     1       2      1     1\nLaura         2     1         1      2    2     2       1      0     0\nTheresa       3     2         2      3    3     2       2      1     1\nBrenda        2     1         1      2    2     2       1      0     0\nCharlotte     1     0         0      1    1     1       0      0     0\nFrances       1     1         1      1    1     1       1      0     0\nEleanor       2     1         1      2    2     2       1      0     0\nPearl         2     2         2      2    2     1       2      1     1\nRuth          3     2         2      3    2     2       2      1     1\nVerne         0     3         3      4    3     3       2      1     1\nMyrna         3     0         4      4    3     3       2      1     1\nKatherine     3     4         0      6    5     3       2      1     1\nSylvia        4     4         6      0    6     4       2      1     1\nNora          3     3         5      6    0     4       1      2     2\nHelen         3     3         3      4    4     0       1      1     1\nDorothy       2     2         2      2    1     1       0      1     1\nOlivia        1     1         1      1    2     1       1      0     2\nFlora         1     1         1      1    2     1       1      2     0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n   as.matrix(as_adjacency_matrix(G.g, attr = \"weight\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\n6/27     0   2    3    2    3    3    2    3   1    0    0   0     0   0\n3/2      2   0    3    2    3    3    2    3   2    0    0   0     0   0\n4/12     3   3    0    4    6    5    4    5   2    0    0   0     0   0\n9/26     2   2    4    0    4    3    3    3   2    0    0   0     0   0\n2/25     3   3    6    4    0    6    6    7   3    0    0   0     0   0\n5/19     3   3    5    3    6    0    5    7   4    1    1   1     1   1\n3/15     2   2    4    3    6    5    0    8   5    3    2   4     2   2\n9/16     3   3    5    3    7    7    8    0   9    4    1   5     2   2\n4/8      1   2    2    2    3    4    5    9   0    4    3   5     3   3\n6/10     0   0    0    0    0    1    3    4   4    0    2   5     3   3\n2/23     0   0    0    0    0    1    2    1   3    2    0   2     1   1\n4/7      0   0    0    0    0    1    4    5   5    5    2   0     3   3\n11/21    0   0    0    0    0    1    2    2   3    3    1   3     0   3\n8/3      0   0    0    0    0    1    2    2   3    3    1   3     3   0\n```\n:::\n:::\n\nWe can also use the weights to draw a weighted graph network plot of people and group projections. All we have to do is set the `edge.with` argument to the value of the edge weight attribute in the corresponding graph:\n\n\n::: {#fig-projection .cell layout-ncol=\"1\"}\n\n```{.r .cell-code}\n   set.seed(123)\n   plot(G.p, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.p)$weight)\n\n   set.seed(123)\n   plot(G.g, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.g)$weight)\n```\n\n::: {.cell-output-display}\n![Persons](tm-duality_files/figure-html/fig-projection-1.png){#fig-projection-1 width=1152}\n:::\n\n::: {.cell-output-display}\n![Groups](tm-duality_files/figure-html/fig-projection-2.png){#fig-projection-2 width=1152}\n:::\n\nOne mode projections.\n:::\n\n\nNote that because both `G.p` and `G.g` are **weighted graphs** we can calculate the weighted version of degree for both persons and groups from them (sometimes called the **vertex strength**).\n\nIn `igraph` we can do this using the `strength` function, which takes a weighted graph object as input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   strength(G.p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Evelyn     Laura   Theresa    Brenda Charlotte   Frances   Eleanor     Pearl \n       50        45        57        46        24        32        36        31 \n     Ruth     Verne     Myrna Katherine    Sylvia      Nora     Helen   Dorothy \n       40        38        33        37        46        43        34        24 \n   Olivia     Flora \n       14        14 \n```\n:::\n\n```{.r .cell-code}\n   strength(G.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 6/27   3/2  4/12  9/26  2/25  5/19  3/15  9/16   4/8  6/10  2/23   4/7 11/21 \n   19    20    32    23    38    41    48    59    46    25    13    28    18 \n  8/3 \n   18 \n```\n:::\n:::\n\n\nInterestingly, as noted by @faust97 [p. 167], there is a (dual!) mathematical connection between the strength of each vertex in the weighted projection and the centrality of the nodes from the other set they are connected to:\n\n1. For people, the vertex strength is equal to the sum of the sizes of the groups they belong to minus their own degree.\n\n1. For groups, the vertex strength is equal to the sum of the memberships of the people that belong to them, minus their own size.\n\nWe can verify this relationship for Evelyn:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum.size.evelyn <- sum(A[\"Evelyn\", ] * degree(g)[which(V(g)$type == TRUE)]) #sum of the sizes of the groups Evelyn belongs to\n   sum.size.evelyn - degree(g)[which(V(g)$name == \"Evelyn\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvelyn \n    50 \n```\n:::\n:::\n\n\nWhich is indeed Evelyn's vertex strength. \n\nDually, the same relation applies to groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum.mem.6.27 <- sum(A[, \"6/27\"] * degree(g)[which(V(g)$type == FALSE)]) #sum of the memberships of people in the first group\n   sum.mem.6.27 - degree(g)[which(V(g)$name == \"6/27\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6/27 \n  19 \n```\n:::\n:::\n\n\nWhich is indeed the vertex strength of the event held on 6/27.\n\n## Visualizing Dual Projections Using the Minimum Spanning Tree\n\nAs we just saw projecting the original biadjacency matrix using Breiger's [-@breiger74] approach results in two weighted one mode networks. Because there is an edge between two persons (groups) if they share at least one group (person) the resulting graphs tend to be dense featuring high levels of connectivity between nodes as with @fig-projection. This can make it hard to discern the connectivity structure of the projected networks and detect patterns.\n\nOne approach to simplifying the visual projections of two-mode networks is to calculate the resulting weighted graph's **minimum spanning tree**. For any weighted network, the minimum spanning tree is the graph that connects all nodes using the smallest number of edges that form a tree^[Recall that a tree is a connected graph without any cycles.], which happens to be $N-1$ where $N$ is the number of nodes. \n\nTo do this, we can follow **Kruskal's Algorithm**. It goes like this:\n\n- First, we create an edgelist containing each of the edge weights of the one-mode projection graph.\n- Then we sort the edgelist by weight in increasing order (smallest weights first).\n- Then, we create an undirected empty graph with $N$ nodes.\n- Now, we go down the edgelist adding edges to the empty graph one at a time, at each step checking that:\n  1. We are not connecting nodes that have already been connected (avoiding **multiedges**).\n  1. Additional edges do not create **cycles** (as the resulting graph would be no longer a tree). \n\nWe stop when we have the desired number of edges ($N-1$), meaning all nodes are connected in the tree.\n\nHere's a function that does all of this, taking the weighted projection `igraph` object as input and returning the minimum spanning tree:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   make.mst <- function(x) {\n      E <- data.frame(as_edgelist(x), w = E(x)$weight) #creating weighted edge list\n      E <- E[order(E$w), ] #ordering by edge weight\n      Tr <- make_empty_graph(n = vcount(x), directed = FALSE) #creating empty graph\n      V(Tr)$name <- V(x)$name\n      k <- 1\n      n.e <- ecount(Tr)\n      n.v <- vcount(Tr) - 1\n      while(n.e < n.v) {\n         i <- which(V(x)$name == E[k,1])\n         j <- which(V(x)$name == E[k,2])\n         if (are_adjacent(Tr, i, j) == 0) { #checking nodes are not adjacent\n            Tr <- add_edges(Tr, c(i,j)) #add edge\n            n.e <- ecount(Tr) #new edge id\n            if (is_acyclic(Tr) == 0) { #checking new edge does not add a cycle\n               Tr <- delete_edges(Tr, n.e) # delete edge if it adds a cycle\n               }\n            }\n         n.e <- ecount(Tr)\n         k <- k + 1\n         }\n      return(Tr)\n   }\n```\n:::\n\n\nWe can now build the minimum spanning tree graph for each weighted projection:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Tr.p <- make.mst(G.p)\n   Tr.g <- make.mst(G.g)\n```\n:::\n\n\nAnd here's a point and line plot the minimum spanning tree for persons and groups in the *Southern Women* data (we use the `layout_as_tree` option in `igraph`):\n\n\n::: {#fig-mst .cell layout-ncol=\"1\"}\n\n```{.r .cell-code}\nset.seed(123)\n   plot(Tr.p, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, layout=layout_as_tree,\n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = 3, vertex.color = cluster_leading_eigen(Tr.p)$membership)\nset.seed(123)\n   plot(Tr.g, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, layout=layout_as_tree,\n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = 3, vertex.color = cluster_leading_eigen(Tr.g)$membership)\n```\n\n::: {.cell-output-display}\n![Persons](tm-duality_files/figure-html/fig-mst-1.png){#fig-mst-1 width=1152}\n:::\n\n::: {.cell-output-display}\n![Groups](tm-duality_files/figure-html/fig-mst-2.png){#fig-mst-2 width=1152}\n:::\n\nOne mode projection MST.\n:::\n\n\n## An Asymmetric Approach to Dual Projection\n\n@zhou_etal07 describe an asymmetric approach to projecting a two-mode network into two one-mode weighted networks. The motivation is to move beyond two limitations of the Breiger projection approach: (1) the fact that the standard projection always results in a *symmetric* weighted adjacency matrix, and (2) the fact that nodes in two-mode networks that only connect to single entity in the other node are necessarily excluded from the traditional projection (they are isolates).\n\nTo deal with this issue, @zhou_etal07 propose to weigh the one mode projections reciprocally by the degree of the nodes in each mode, similar to the degree-weighting that motivates the CA approach to analyzing two-mode networks we considered [here](tm-ca.qmd). So the idea is that instead of using the usual Breiger projection we considered above, we instead use the *degree-normalized projection*. \n\nRecall from that [lecture](tm-ca.qmd) that the degree normalized projections for persons and groups are obtained as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   D.p <- diag(1/rowSums(A)) #inverse of degree matrix of persons\n   P.pg <- D.p %*% A\n   rownames(P.pg) <- rownames(A) \n   D.g <- diag(1/colSums(A)) #inverse of degree matrix of groups\n   P.gp <- D.g %*% t(A) #person-degree normalized biadjacency matrix\n   rownames(P.gp) <- colnames(A) #group-degree normalized biadjacency matrix\n   P.pp <- P.pg %*% P.gp #degree-normalized projection for people\n   P.gg <- P.gp %*% P.pg #degree-normalized projection for groups\n```\n:::\n\n\nChecking the first rows and columns of the degree-weighted person projection reveals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   round(P.pp[1:5, 1:5], 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Evelyn Laura Theresa Brenda Charlotte\nEvelyn     0.186 0.144   0.144  0.134     0.068\nLaura      0.165 0.179   0.132  0.132     0.056\nTheresa    0.144 0.115   0.157  0.105     0.080\nBrenda     0.153 0.132   0.120  0.167     0.092\nCharlotte  0.135 0.098   0.160  0.160     0.160\n```\n:::\n:::\n\n\nNote that the entries of this matrix are *not* symmetric, like in the standard Breiger projection. For instance the weight of the link going form Evelyn to Laura is 0.144, but the weight of the link going from Laura to Evenly is  0.165.\n\nWe can check this formally using the base `R` function `isSymmetric`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   isSymmetric(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n   isSymmetric(P.pp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nWhich returns `TRUE` for the usual Breiger projection but `FALSE` for the degree-weighted projection.\n\nWe can create weighted directed `igraph` objects from the degree-weighted projections using the function `graph_from_adjacency_matrix` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   G.dp <- graph_from_adjacency_matrix(P.pp, mode = \"directed\", weighted = TRUE)\n   G.dg <- graph_from_adjacency_matrix(P.gg, mode = \"directed\", weighted = TRUE)\n```\n:::\n\n\nNote that we specify the `mode` argument to be `directed` and the `weighted` argument to be `TRUE`.\n\nWe can of course plot the directed weighted graphs on each mode as usual:\n\n\n::: {#fig-dgproj .cell layout-ncol=\"1\"}\n\n```{.r .cell-code}\n   set.seed(123)\n   plot(G.dp, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.p)$weight*0.5)\n\n   set.seed(123)\n   plot(G.dg, \n     vertex.size=8, vertex.frame.color=\"lightgray\", \n     vertex.label.dist=2, edge.curved=0.2, \n     vertex.label.cex = 1.5, edge.color = \"lightgray\",\n     edge.width = E(G.g)$weight*0.5)\n```\n\n::: {.cell-output-display}\n![Persons](tm-duality_files/figure-html/fig-dgproj-1.png){#fig-dgproj-1 width=1152}\n:::\n\n::: {.cell-output-display}\n![Groups](tm-duality_files/figure-html/fig-dgproj-2.png){#fig-dgproj-2 width=1152}\n:::\n\nDegree-weighted one mode projections.\n:::\n",
    "supporting": [
      "tm-duality_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}