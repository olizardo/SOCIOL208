{
  "hash": "942109dba01bfd21895c67c1e104bb76",
  "result": {
    "markdown": "---\ntitle: \"Degree Centrality\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\nIn the following lecture notes we will go through the basic centrality metrics. Particularly, the \"big three\" according to @freeman79, namely, **degree** (treated here), followed by [**closeness**](closcent.qmd) and [**betweenness**](betcent.qmd). \n\n## Degree Centrality in Undirected Graphs\n\nWe first load our trusty *Pulp Fiction* data set from the `networkdata` package, which is an **undirected** graph of character scene co-appearances in the film:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    library(networkdata)\n    library(igraph)\n    library(stringr) #using stringr to change names from all caps to title case\n    g <- movie_559\n    V(g)$name <- str_to_title(V(g)$name)\n```\n:::\n\n\nDegree centrality is the simplest and most straightforward measure. In fact, we are already computed in the [lecture notes on basic network statistics](basic.qmd) since it is the same as obtaining the graph's **degree sequence**. So the `igraph` function `degree` would do it as we already saw. \n\nHere we follow a different approach using the row (or column) sums of the graph's **adjacency matrix**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as_adjacency_matrix(g)\n   A <- as.matrix(A)\n   rowSums(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Brett           Buddy           Butch      Capt Koons     Ed Sullivan \n              7               2              17               5               2 \n   English Dave       Esmarelda        Fabienne      Fourth Man       Gawker #2 \n              4               1               3               2               3 \n    Honey Bunny          Jimmie            Jody           Jules           Lance \n              8               3               4              16               4 \n        Manager       Marsellus          Marvin         Maynard             Mia \n              5              10               6               3              11 \n         Mother          Patron      Pedestrian        Preacher         Pumpkin \n              5               5               3               3               8 \n         Raquel           Roger Sportscaster #1 Sportscaster #2        The Gimp \n              3               6               2               1               2 \n       The Wolf         Vincent        Waitress         Winston           Woman \n              3              25               4               3               5 \n      Young Man     Young Woman             Zed \n              4               4               2 \n```\n:::\n:::\n\n\nThe `igraph` function `as_adjancency_matrix` doesn't quite return a regular `R` matrix object, so we have to further coerce the resulting object into a numerical matrix containing zeroes and ones using the `as.matrix` function in line 2. Then we can apply the native `rowSums` function to obtain each node's degree. Note that this is same output we got using the `degree` function before. \n\nOf course, we can also use the `igraph` function `degree` which returns the same named vector with the degrees of each node as output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d <- degree(g)\n   sort(d, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Vincent           Butch           Jules             Mia       Marsellus \n             25              17              16              11              10 \n    Honey Bunny         Pumpkin           Brett          Marvin           Roger \n              8               8               7               6               6 \n     Capt Koons         Manager          Mother          Patron           Woman \n              5               5               5               5               5 \n   English Dave            Jody           Lance        Waitress       Young Man \n              4               4               4               4               4 \n    Young Woman        Fabienne       Gawker #2          Jimmie         Maynard \n              4               3               3               3               3 \n     Pedestrian        Preacher          Raquel        The Wolf         Winston \n              3               3               3               3               3 \n          Buddy     Ed Sullivan      Fourth Man Sportscaster #1        The Gimp \n              2               2               2               2               2 \n            Zed       Esmarelda Sportscaster #2 \n              2               1               1 \n```\n:::\n:::\n\n\n## Degree in Weighted Graphs\n\nTypically, undirected graphs record the interactions between actors in the networks as binary (1/0) ties. Nevertheless in many cases edges have a **weight** associated with them, recording the intensity of the interactions between pair of actors, resulting in a **weighted graph**.\n\nIn `igraph` we can check if the network in question is weighted by seeing whether there is a `weight` attribute associated with the edges in the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   E(g)$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1 1 1 1 1 1 1 1 2 1 1 3 1 1 1 1 2 1 1 1 1 1 2 1 2 1 1 2 2 1 1 1 1 1 3 1 4\n [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 6 4 3 3 1 1 2\n [75] 1 1 3 9 1 3 2 6 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n\nIf the graph was unweighted, this call would return a `NULL` value. We can see however, that there are weights associated with each edge. In the *Pulp Fiction* network, the weights represent the *number of scenes* in the movie that two characters co-appeared in. \n\nWe can take a quick peek at how these edge weights look by creating an edge list data frame using the `igraph` function `as_edgelist` and then attaching the edge weight attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   dat <- data.frame(as_edgelist(g), w = E(g)$weight)\n```\n:::\n\n\nAnd looking at the first twenty rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   dat[1:20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           X1              X2 w\n1       Brett       Marsellus 1\n2       Brett          Marvin 1\n3       Brett           Roger 1\n4       Brett         Vincent 1\n5       Buddy             Mia 1\n6       Buddy         Vincent 1\n7       Brett           Butch 1\n8       Butch      Capt Koons 1\n9       Butch       Esmarelda 2\n10      Butch       Gawker #2 1\n11      Butch           Jules 1\n12      Butch       Marsellus 3\n13      Butch      Pedestrian 1\n14      Butch Sportscaster #1 1\n15      Butch    English Dave 1\n16      Brett        Fabienne 1\n17      Butch        Fabienne 2\n18   Fabienne           Jules 1\n19 Fourth Man           Jules 1\n20 Fourth Man         Vincent 1\n```\n:::\n:::\n\n\nWe can see, for instance, that Butch and Marsellus co-appear in three different scenes.\n\n### Vertex Strength\n\nHow do we incorporate edge weights into the calculation of degree centrality? One approach, proposed by @barrat_etal04 is to compute:\n\n$$\nC^{VS}_i = \\sum_j w_{ij}\n$$ {#eq-vs}\n\nWhere the weighted degree (@barrat_etal04 call it the **vertex strength**) of a node is just the sum of the weights of the edges incident to that node. \n\nIn `R` we can compute the vertex strength by calculating the row (or column) sums of the **weighted adjacency matrix** $\\mathbf{W}$ containing the weight of the edge between $i$ and $j$ in each cell $w_{ij}$. \n\nWe can do that like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   W <- as.matrix(as_adjacency_matrix(g, attr=\"weight\"))\n   vs <- rowSums(W)\n   sort(vs, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Vincent           Jules           Butch             Mia       Marsellus \n             51              31              23              16              15 \n       The Wolf     Honey Bunny          Jimmie           Lance         Pumpkin \n             13               9               9               9               9 \n          Brett            Jody          Marvin           Roger      Capt Koons \n              8               8               8               6               5 \n   English Dave         Manager          Mother          Patron           Woman \n              5               5               5               5               5 \n       Fabienne        Waitress       Young Man     Young Woman       Gawker #2 \n              4               4               4               4               3 \n        Maynard      Pedestrian        Preacher          Raquel Sportscaster #1 \n              3               3               3               3               3 \n        Winston           Buddy     Ed Sullivan       Esmarelda      Fourth Man \n              3               2               2               2               2 \nSportscaster #2        The Gimp             Zed \n              2               2               2 \n```\n:::\n:::\n\n\nNote that in `igraph`, we obtain the weighted adjacency matrix , by specifying `\"weight\"` as the value of the `attr` argument (for edge attribute) in the call to the `as_adjacency matrix` function. \n\nNot surprisingly, the main characters in the story have the largest vertex strengths, as they tend to co-appear with other characters several times in the film.\n\nThe vertex strength approach is intuitive but it has the drawback of giving the same score to low degree nodes with large weights and high degree nodes with small weights (e.g., a node with two contacts each with a weight of 3.0 gets the same score as node with six contacts each with a weight of 1.0).\n\n### Generalized Degree\n\nTo deal with this issue, @opsahl_etal10 propose that we instead compute:\n\n$$\nC^{WD}_i = \\left(\\sum_j w_{ij}\\right)^{\\alpha}\\left(\\sum_j a_{ij}\\right)^{(1-\\alpha)} \n$$ {#eq-wd}\n\nWith the parameter $\\alpha$ chosen by the researcher. Note that in the right-hand side of the equation, the factor on the left is just vertex strength as defined in @eq-vs raised to the power of $\\alpha$, and the factor on the right is just the usual binary degree centrality, counting the number of alters ego is connected to, raised to the power of $1-\\alpha$.\n\nThe $\\alpha$ parameter thus controls the importance we give the number of contacts versus the weight of the edges in computing the degree. When $\\alpha = 1$ then @eq-wd reduces to @eq-vs the vertex strength; when $\\alpha = 0$ then @eq-wd reduces to the regular unweighted degree. \n\n$\\alpha$ values between zero and one combine both quantities, with numbers closer to zero giving more weight to number of contacts, and numbers closer to one giving more importance to the weight of the edges.\n\nHere's function that computes the @opsahl_etal10 generalized degree:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   gen.deg <- function(x, alpha) {\n      s <- rowSums(as.matrix(as_adjacency_matrix(x, attr=\"weight\")))\n      d <- rowSums(as.matrix(as_adjacency_matrix(x)))\n      wd <- s^alpha * d^(1-alpha)\n      return(wd)\n      }\n```\n:::\n\n\nThe function takes the graph and a value for $\\alpha$ as inputs and returns the vector of generalized degrees as output. In lines 2 and 3 we compute the vertex strength and the regular degree from the row sums of the weighted adjacency matrix and the regular adjacency matrix. \n\nWe can see that when we set $\\alpha = 0$ we get values identical to the degree:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   dr <- gen.deg(g, alpha = 0)\n   sort(dr, decreasing = TRUE)[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Vincent       Butch       Jules         Mia   Marsellus Honey Bunny \n         25          17          16          11          10           8 \n    Pumpkin       Brett      Marvin       Roger \n          8           7           6           6 \n```\n:::\n:::\n\n\nAnd when we set $\\alpha = 1$ we get values identical to the vertex strength:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   dr <- gen.deg(g, alpha = 1)\n   sort(dr, decreasing = TRUE)[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Vincent       Jules       Butch         Mia   Marsellus    The Wolf \n         51          31          23          16          15          13 \nHoney Bunny      Jimmie       Lance     Pumpkin \n          9           9           9           9 \n```\n:::\n:::\n\n\nNote that the top 10 ranks differ; while Vincent is the top character by either measure, Buth is second and Just is third by degree, but their places switch when we rank them by vertex strength. Also, while the Wolf is not in the top 10 by degree, he is by vertex strength. \n\nThe interesting thing is what happens with other values. Let's set $\\alpha = 0.6$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   dr <- gen.deg(g, alpha = 0.6)\n   sort(round(dr, 1), decreasing = TRUE)[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Vincent       Jules       Butch         Mia   Marsellus Honey Bunny \n       38.3        23.8        20.4        13.8        12.8         8.6 \n    Pumpkin       Brett    The Wolf      Marvin \n        8.6         7.6         7.2         7.1 \n```\n:::\n:::\n\n\nWhich ends up being a compromise between the two top 10 lists, containing characters from both. \n\n## Degree Centrality in Directed Graphs\n\n### Indegree and Outdegree\n\nThe movie network is based on the relationship of co-appearance in a scene which by nature lacks any natural directionality (it's a symmetric relation) and can therefore be represented in an **undirected graph**. The concepts of in and outdegree, by contrast, are only applicable to directed ties, which are represented by a **directed graph**. So to illustrate them, we need to switch to a different source of data.\n\nWe pick an **advice network** which is a classical directed kind of (asymmetric) relation. I can give advice to you, but that doesn't necessarily mean you can give advice to me. The `networkdata` package contains one such data set collected in the late 80s early 1990s in a New England law firm [@lazega01] called `law_advice`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- law_advice\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 71/71 vertices, from d1a9da7:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n[51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71\n```\n:::\n\n```{.r .cell-code}\n   vertex_attr(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$status\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n[39] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n\n$gender\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 2 1 1 1 2\n[39] 2 1 1 1 2 2 1 2 1 2 1 1 2 1 1 1 1 1 2 1 2 2 2 1 1 2 1 1 2 1 2 1 2\n\n$office\n [1] 1 1 2 1 2 2 2 1 1 1 1 1 1 2 3 1 1 2 1 1 1 1 1 1 2 1 1 2 1 2 2 2 2 1 2 1 3 1\n[39] 1 1 1 1 1 3 1 2 3 1 1 2 2 1 1 1 1 1 1 2 2 1 1 1 2 1 1 1 1 1 1 1 1\n\n$seniority\n [1] 31 32 13 31 31 29 29 28 25 25 23 24 22  1 21 20 23 18 19 19 17  9 16 15 15\n[26] 15 13 11 10  7  8  8  8  8  8  5  5  7  6  6  5  4  5  5  3  3  3  1  4  3\n[51]  4  4 10  3  3  3  3  3  2  2  2  2  2  2  2  1  1  1  1  1  1\n\n$age\n [1] 64 62 67 59 59 55 63 53 53 53 50 52 57 56 48 46 50 45 46 49 43 49 45 44 43\n[26] 41 47 38 38 39 34 33 37 36 33 43 44 53 37 34 31 31 47 53 38 42 38 35 36 31\n[51] 29 29 38 29 34 38 33 33 30 31 34 32 29 45 28 43 35 26 38 31 26\n\n$practice\n [1] 1 2 1 2 1 1 2 1 2 2 1 2 1 2 2 2 2 1 2 1 1 1 1 1 2 1 1 2 2 1 1 1 1 2 2 1 2 1\n[39] 1 1 1 2 1 2 2 2 1 2 1 2 1 1 2 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 1\n\n$law_school\n [1] 1 1 1 3 2 1 3 3 1 3 1 2 2 1 3 1 1 2 1 1 2 3 2 2 2 3 1 2 3 3 2 3 3 2 3 3 3 2\n[39] 1 1 2 2 2 1 3 2 3 3 2 2 3 3 3 3 3 2 2 3 2 2 3 2 2 2 3 3 2 3 3 2 2\n```\n:::\n:::\n\n\nWe can see that the graph has 71 vertices, and that there are various **attributes** associated with each vertex, like gender, age, seniority, status in the law firm, etc. We can query those attributes using the `igraph` function `vertex_attr`, which takes the graph object as input. \n\nTo keep things manageable, we will restrict our analysis to partners. To do that we need to select the **subgraph** that only includes the vertices with value of 1 in the \"status\" vertex attribute. From the [data description](https://www.rdocumentation.org/packages/networkdata/versions/0.1.6/topics/law_advice), we know the first 36 nodes (with value of 1 in the status attribute) are the law firm's partners (the rest are associates). In `igraph` we can do this as using the `subgraph` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.g <- subgraph(d.g, 1:36)\n   V(d.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 36/36 vertices, from 1d3e55b:\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36\n```\n:::\n\n```{.r .cell-code}\n   V(d.g)$status\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n\nThe first line just tells `igraph` to generate the subgraph containing the first 36 nodes (the partners). The `subgraph` function thus takes two main inputs: The graph object, and then a vector of node ids (or node labels) telling the function which nodes to select to create the **node-induced subgraph**.\n\nOK, going back to the partners subgraph, we can now create our (asymmetric) adjacency matrix and compute the row and column sums:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.A <- as_adjacency_matrix(d.g)\n   d.A <- as.matrix(d.A)\n   rowSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   colSums(d.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that in contrast to the undirected case the row and column sums give you two different sets of numbers. The row sums provide the directed graph's **outdegree set** (number of *outgoing* links incident to each node), and the column sums provide the graph's **indegree set** (number of *incoming* links incident to each node). So if you are high in the first vector, you are an *advice giver* (perhaps indicating informal status or experience) and if you are high in the second you are advice taker.\n\nOf course `igraph` has a dedicated function for this, which is just our old friend `degree` with an extra option `mode`, indicating whether you want the in or outdegrees:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d.o <- degree(d.g, mode = \"out\")\n   d.i <- degree(d.g, mode = \"in\")\n   d.o\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  7  7 17  4  0  4  2  3  7  5 18 11 13 10 19 17  5 21 10  9 12  9 16  8\n[26] 22 18 22 13 15 16  9 15  6 15  7\n```\n:::\n\n```{.r .cell-code}\n   d.i\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 18 17  8 14 10 17  4  8 10  6 11 14 14 12 15 13 21  7  7 17 11 10  2 14  7\n[26] 20  2 14 12 11  8 13  2 16  8  2\n```\n:::\n:::\n\n\nNote that the graph attributes are just vectors of values, and can be accessed from the graph object using the $ operator attached to the `V()` function as we did above. \n\nSo if we wanted to figure out the correlation between some vertex attribute and in or out degree centrality, all we need to do is correlate the two vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   r <- cor(d.o, V(d.g)$age)\n   round(r, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.43\n```\n:::\n:::\n\n\nWhich tells us that at least in this case, younger partners are more sought after as sources of advice than older partners. \n\n\n\n\n\n\n",
    "supporting": [
      "degcent_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}