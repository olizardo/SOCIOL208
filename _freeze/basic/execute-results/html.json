{
  "hash": "d3f4ddffd7b3dad9590b6e884b2ee498",
  "result": {
    "markdown": "---\ntitle: \"Basic Network Statistics\"\nexecute: \n  eval: true\n  echo: true\n  output: true\n  warning: false\n  message: false\nformat: \n   html:\n      code-line-numbers: true\n---\n\n\n## Loading Data\n\nHere we will analyze a small network and compute some basic statistics of interest. The first thing we need to do is get some data! For this purpose, we will use the package `networkdata` (available [here](https://schochastics.github.io/networkdata/)). To install the package, use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   #install.packages(\"remotes\") \n   remotes::install_github(\"schochastics/networkdata\")\n```\n:::\n\n\nTo load the network datasets in the `networkdata` just type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   library(networkdata)\n```\n:::\n\n\nThe package contains a bunch of human and animal social networks to browse through them, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   data(package = \"networkdata\")\n```\n:::\n\n\nWe will pick one of the movies for this analysis, namely, *Pulp Fiction*. This is `movie_559`. In the movie network two characters are linked by an edge if they appear in a scene together. The `networkdata` data sets come in `igraph` format, so we need to load that package (or install it using `install.packages` if you haven't done that yet).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   #install.packages(\"igraph\") \n   #install.packages(\"stringr\") \n    library(igraph)\n    library(stringr) #using stringr to change names from all caps to title case\n    g <- movie_559 #assigning Pulp Fiction igraph network object\n    V(g)$name <- str_to_title(V(g)$name)\n    V(g)$name[which(V(g)$name == \"Esmarelda\")] <- \"Esmeralda\" #fixing misspelled name\n    E(g)$weight <- 1 #setting edge weights to 1.0   g <- movie_559\n```\n:::\n\n\n## Number of Nodes and Edges\n\nNow we are ready to compute some **basic network statistics**. As with any network, we want to know what the number of *nodes* and the number of *edges* (links) are. Since this is a relatively small network, we can begin by listing the actors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n   V(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 38/38 vertices, named, from 9e7cc7a:\n [1] Brett           Buddy           Butch           Capt Koons     \n [5] Ed Sullivan     English Dave    Esmeralda       Fabienne       \n [9] Fourth Man      Gawker #2       Honey Bunny     Jimmie         \n[13] Jody            Jules           Lance           Manager        \n[17] Marsellus       Marvin          Maynard         Mia            \n[21] Mother          Patron          Pedestrian      Preacher       \n[25] Pumpkin         Raquel          Roger           Sportscaster #1\n[29] Sportscaster #2 The Gimp        The Wolf        Vincent        \n[33] Waitress        Winston         Woman           Young Man      \n[37] Young Woman     Zed            \n```\n:::\n:::\n\n\nThe function `V` takes the `igraph` network object as input and returns an `igraph.vs` object as output (short for \"igraph vertex sequence\"), listing the names (if given as a graph attribute) of each node. The first line also tells us that there are 38 nodes in this network.  \n\nThe `igraph.vs` object operates much like an `R` character vector, so we can query its length to figure out the number of nodes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   length(V(g))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 38\n```\n:::\n:::\n\n\nThe analogue function for edges in `igraph` is `E` which also takes the network object as input and returns an object of class `igraph.es` (\"igraph edge sequence\") as output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   E(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 102/102 edges from 9e7cc7a (vertex names):\n [1] Brett      --Marsellus       Brett      --Marvin         \n [3] Brett      --Roger           Brett      --Vincent        \n [5] Buddy      --Mia             Buddy      --Vincent        \n [7] Brett      --Butch           Butch      --Capt Koons     \n [9] Butch      --Esmeralda       Butch      --Gawker #2      \n[11] Butch      --Jules           Butch      --Marsellus      \n[13] Butch      --Pedestrian      Butch      --Sportscaster #1\n[15] Butch      --English Dave    Brett      --Fabienne       \n[17] Butch      --Fabienne        Fabienne   --Jules          \n[19] Fourth Man --Jules           Fourth Man --Vincent        \n+ ... omitted several edges\n```\n:::\n:::\n\n\nThis tells us that there are 102 edges (connected dyads) in the network. Some of these include Brett and Marsellus and Fabienne and Jules, but not all can be listed for reasons of space. \n\n`igraph` also has two dedicated functions that return the number of nodes and edges in the graph in one fell swoop. They are called `vcount` and `ecount` and take the graph object as input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   vcount(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 38\n```\n:::\n\n```{.r .cell-code}\n   ecount(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102\n```\n:::\n:::\n\n\n## Graph Density\n\nOnce we have the number of edges and nodes, we can calculate the most basic derived statistic in a network, which is the **density** ($d(G)$). Since the movie network is an **undirected** graph, the density is given by:\n\n$$\n d(G) = \\frac{2m}{n(n-1)}\n$$ {#eq-dens}\n\nWhere $m$ is the number of edges and $n$ is the number of nodes, or in our case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    d <- (2 * 102) / (38 * (38 - 1))\n    round(d, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.145\n```\n:::\n:::\n\n\nOf course, igraph has a dedicated function called `edge_density` to compute the density too, which takes the igraph object as input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   round(edge_density(g), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.145\n```\n:::\n:::\n\n\n## Degree\n\nThe next set of graph metrics are based on the **degree** of the graph. We can list the graph's **degree set** using the `igraph` function `degree`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   degree(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Brett           Buddy           Butch      Capt Koons     Ed Sullivan \n              7               2              17               5               2 \n   English Dave       Esmeralda        Fabienne      Fourth Man       Gawker #2 \n              4               1               3               2               3 \n    Honey Bunny          Jimmie            Jody           Jules           Lance \n              8               3               4              16               4 \n        Manager       Marsellus          Marvin         Maynard             Mia \n              5              10               6               3              11 \n         Mother          Patron      Pedestrian        Preacher         Pumpkin \n              5               5               3               3               8 \n         Raquel           Roger Sportscaster #1 Sportscaster #2        The Gimp \n              3               6               2               1               2 \n       The Wolf         Vincent        Waitress         Winston           Woman \n              3              25               4               3               5 \n      Young Man     Young Woman             Zed \n              4               4               2 \n```\n:::\n:::\n\n\nThe `degree` function takes the igraph network object as input and returns a plain old `R` **named vector** ($\\mathbf{d}$) as output with the names being the `names` attribute of vertices in the network object. \n\nUsually we are interested in who are the \"top nodes\" in the network by degree (a kind of **centrality**). To figure that out, all we need to do is sort the degree set (to generate the graph's **degree sequence**) and list the top entries:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d <- degree(g)\n   d.sort <- sort(d, decreasing = TRUE)\n   d.sort\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Vincent           Butch           Jules             Mia       Marsellus \n             25              17              16              11              10 \n    Honey Bunny         Pumpkin           Brett          Marvin           Roger \n              8               8               7               6               6 \n     Capt Koons         Manager          Mother          Patron           Woman \n              5               5               5               5               5 \n   English Dave            Jody           Lance        Waitress       Young Man \n              4               4               4               4               4 \n    Young Woman        Fabienne       Gawker #2          Jimmie         Maynard \n              4               3               3               3               3 \n     Pedestrian        Preacher          Raquel        The Wolf         Winston \n              3               3               3               3               3 \n          Buddy     Ed Sullivan      Fourth Man Sportscaster #1        The Gimp \n              2               2               2               2               2 \n            Zed       Esmeralda Sportscaster #2 \n              2               1               1 \n```\n:::\n:::\n\n\nLine 1 stores the degrees in an object \"d\", line 2 creates a \"sorted\" version of the same object (from bigger to smaller) and line 3 shows the elements of the sorted degree sequence.\n\nWe can also compute the degrees directly from the graph's **adjacency matrix** ($\\mathbf{A}$). This is a matrix listing the nodes in the rows and columns and containing entries that equal one if the row node and the column node are adjacent in the graph and zero otherwise.\n\nIn `R` we can use the `igraph` we can obtain such a matrix from the graph object `g` by using the function `as_adjacency_matrix` (coerced to a regular matrix object in `R` using the `as.matrix` wraparound):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as.matrix(as_adjacency_matrix(g))\n```\n:::\n\n\nThe row *or* column sums (in the undirected graph case) give us the degree vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d <- rowSums(A)\n   names(d) <- V(g)$name #naming vector\n   d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Brett           Buddy           Butch      Capt Koons     Ed Sullivan \n              7               2              17               5               2 \n   English Dave       Esmeralda        Fabienne      Fourth Man       Gawker #2 \n              4               1               3               2               3 \n    Honey Bunny          Jimmie            Jody           Jules           Lance \n              8               3               4              16               4 \n        Manager       Marsellus          Marvin         Maynard             Mia \n              5              10               6               3              11 \n         Mother          Patron      Pedestrian        Preacher         Pumpkin \n              5               5               3               3               8 \n         Raquel           Roger Sportscaster #1 Sportscaster #2        The Gimp \n              3               6               2               1               2 \n       The Wolf         Vincent        Waitress         Winston           Woman \n              3              25               4               3               5 \n      Young Man     Young Woman             Zed \n              4               4               2 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n   d <- colSums(A)\n   names(d) <- V(g)$name #naming vector\n   d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Brett           Buddy           Butch      Capt Koons     Ed Sullivan \n              7               2              17               5               2 \n   English Dave       Esmeralda        Fabienne      Fourth Man       Gawker #2 \n              4               1               3               2               3 \n    Honey Bunny          Jimmie            Jody           Jules           Lance \n              8               3               4              16               4 \n        Manager       Marsellus          Marvin         Maynard             Mia \n              5              10               6               3              11 \n         Mother          Patron      Pedestrian        Preacher         Pumpkin \n              5               5               3               3               8 \n         Raquel           Roger Sportscaster #1 Sportscaster #2        The Gimp \n              3               6               2               1               2 \n       The Wolf         Vincent        Waitress         Winston           Woman \n              3              25               4               3               5 \n      Young Man     Young Woman             Zed \n              4               4               2 \n```\n:::\n:::\n\n\nThe degrees can also be expressed in \"matrix form\" as the (matrix) product of the adjacency matrix times the **all ones column vector** ($\\mathbf{e}$) of dimensions $N \\times 1$ ($N$ rows and one column) where $N$ is the number of nodes in the graph (the number of rows of $\\mathbf{A}$):\n\n$$\n\\mathbf{d} = \\mathbf{A}\\mathbf{e}\n$$ {#eq-degcol}\n\nIn `R` we use the operator `%*%` to indicate matrix multiplication (after all a column vector is just a matrix with one column):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   e <- matrix(1, nrow(A), 1) #defining the all ones column vector\n   d <- A %*% e\n   rownames(d) <- V(g)$name #naming vector\n   d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                [,1]\nBrett              7\nBuddy              2\nButch             17\nCapt Koons         5\nEd Sullivan        2\nEnglish Dave       4\nEsmeralda          1\nFabienne           3\nFourth Man         2\nGawker #2          3\nHoney Bunny        8\nJimmie             3\nJody               4\nJules             16\nLance              4\nManager            5\nMarsellus         10\nMarvin             6\nMaynard            3\nMia               11\nMother             5\nPatron             5\nPedestrian         3\nPreacher           3\nPumpkin            8\nRaquel             3\nRoger              6\nSportscaster #1    2\nSportscaster #2    1\nThe Gimp           2\nThe Wolf           3\nVincent           25\nWaitress           4\nWinston            3\nWoman              5\nYoung Man          4\nYoung Woman        4\nZed                2\n```\n:::\n:::\n\n\nNote that the matrix operation above returns $\\mathbf{d}$ as a column vector. If we wanted a **row vector**, we would instead compute:\n\n$$\n\\mathbf{d} = \\mathbf{e}^T\\mathbf{A}\n$$ {#eq-degrow}\n\nWhere $\\mathbf{e}^T$ is the **matrix tranpose** of the row vector $\\mathbf{e}$ (e.g., a row vector of dimensions $1 \\times N$).\n\nWhich in `R` can be obtained as follows, using the base function `t` for the matrix transpose:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   e <- matrix(1, nrow(A), 1) #defining the all ones column vector\n   d <- t(e) %*% A\n   colnames(d) <- V(g)$name #naming vector\n   d\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Brett Buddy Butch Capt Koons Ed Sullivan English Dave Esmeralda Fabienne\n[1,]     7     2    17          5           2            4         1        3\n     Fourth Man Gawker #2 Honey Bunny Jimmie Jody Jules Lance Manager Marsellus\n[1,]          2         3           8      3    4    16     4       5        10\n     Marvin Maynard Mia Mother Patron Pedestrian Preacher Pumpkin Raquel Roger\n[1,]      6       3  11      5      5          3        3       8      3     6\n     Sportscaster #1 Sportscaster #2 The Gimp The Wolf Vincent Waitress Winston\n[1,]               2               1        2        3      25        4       3\n     Woman Young Man Young Woman Zed\n[1,]     5         4           4   2\n```\n:::\n:::\n\n\n## Degree-Based Graph Statistics\n\nBecause the degree vector \"d\" is just a regular old vector we can use native `R` mathematical operations to figure out things like the **sum**, **maximum**, **minimum**, and **average degree** of the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 204\n```\n:::\n\n```{.r .cell-code}\n   max(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n\n```{.r .cell-code}\n   min(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n   mean(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.368421\n```\n:::\n:::\n\n\nSo the sum of degrees is 204, the maximum degree is 25 (belonging to Vincent), the minimum is one, and the average is about 5.4.\n\nNote that these numbers recreate some well-known equalities in graph theory:\n\n- The sum of degrees is twice the number of edges (the [first theorem of graph theory](https://www3.nd.edu/~dgalvin1/40210/40210_F12/CGT_early.pdf)): \n\n\n::: {.cell}\n\n```{.r .cell-code}\n   2 * ecount(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 204\n```\n:::\n:::\n\n- The average degree is just the sum of degrees divided by the number of nodes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum(d)/vcount(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.368421\n```\n:::\n:::\n\n\n- The density is just the average degree divided by the number of nodes minus one, as explained [here](https://olizardo.github.io/networks-textbook/lesson-graphs-degree-metrics.html#the-connection-between-density-and-average-degree):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   mean(d)/(vcount(g) - 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1450925\n```\n:::\n:::\n\n\nSome people also consider the **degree variance** of the graph as a measure of inequality of connectivity in the system. It is equal to the average sum of square deviations of each node's degree from the average:\n\n$$\n  \\mathcal{v}(G) = \\frac{\\sum_i (k_i - \\bar{k})^2}{n}\n$$ {#eq-degvar}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   sum((d - mean(d))^2)/vcount(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22.96953\n```\n:::\n:::\n\nThis tells us that there is a lot of inequality in the distribution of degrees in the graph (a graph with all nodes equal degree would have variance zero).\n\n## The Degree Distribution in Undirected Graphs\n\nAnother way of looking at inequalities of degrees in a graph is to examine its **degree distribution**. This gives us the probability of observing a node with a given degree *k* in the graph. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   deg.dist <- degree_distribution(g)\n   deg.dist <- round(deg.dist, 3)\n   deg.dist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.000 0.053 0.158 0.237 0.158 0.132 0.053 0.026 0.053 0.000 0.026 0.026\n[13] 0.000 0.000 0.000 0.000 0.026 0.026 0.000 0.000 0.000 0.000 0.000 0.000\n[25] 0.000 0.026\n```\n:::\n:::\n\n\nThe igraph function `degree_distribution` just returns a numeric vector of the same length as the **maximum degree** of the graph plus one.  In this case that's a vector of length 25 + 1 = 26. The first entry gives us the proportion of nodes with degree zero (isolates), the second the proportion of nodes of degree one, and so on up to the graph's **maximum degree**. \n\nSince there are no isolates in the network, we can ignore the first element of this vector, to get the proportion of nodes of each degree in the *Pulp Fiction* network. To that, we fist create a two-column `data.frame` with the degrees in the first column and the proportions in the second:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   degree <- c(1:max(d))\n   prop <- deg.dist\n   prop <- prop[-1]\n   deg.dist <- data.frame(degree, prop)\n   deg.dist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   degree  prop\n1       1 0.053\n2       2 0.158\n3       3 0.237\n4       4 0.158\n5       5 0.132\n6       6 0.053\n7       7 0.026\n8       8 0.053\n9       9 0.000\n10     10 0.026\n11     11 0.026\n12     12 0.000\n13     13 0.000\n14     14 0.000\n15     15 0.000\n16     16 0.026\n17     17 0.026\n18     18 0.000\n19     19 0.000\n20     20 0.000\n21     21 0.000\n22     22 0.000\n23     23 0.000\n24     24 0.000\n25     25 0.026\n```\n:::\n:::\n\n\nOf course, a better way to display the degree distribution of a graph is via some kind of data visualization, particularly for large networks where a long table of numbers is just not feasible. To do that, we can call on our good friend `ggplot`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   # install.packages(ggplot2)\n   library(ggplot2)\n   p <- ggplot(data = deg.dist, aes(x = degree, y = prop))\n   p <- p + geom_bar(stat = \"identity\", fill = \"red\", color = \"red\")\n   p <- p + theme_minimal()\n   p <- p + labs(x = \"\", y = \"Proportion\", \n                 title = \"Degree Distribution in Pulp Fiction Network\") \n   p <- p + geom_vline(xintercept = mean(d), \n                       linetype = 2, linewidth = 0.5, color = \"blue\")\n   p <- p + scale_x_continuous(breaks = c(1, 5, 10, 15, 20, 25))\n   p\n```\n\n::: {.cell-output-display}\n![](basic_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nThe plot clearly shows that the *Pulp Fiction* network degree distribution is *skewed* with a small number of characters having a large degree $k \\geq 15$ while most other characters in the movie have a small degree $k \\leq 5$ indicating inequality of connectivity in the system. \n\n## The Degree Correlation\n\nAnother overall network statistic we may want to know is the **degree correlation** [@newman02]. How do we compute it? Imagine taking each edge in the network and creating two degree vectors, one based on the degree of the node in one end and the degre of the node in another. Then the **degree assortativity coefficient** is just the Pearson product moment correlation between these two vectors.\n\nLet's see how this would work for the *Pulp Fiction* network. First we need to extract an *edge list* from the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   g.el <- as_edgelist(g) #transforming graph to edgelist\n   head(g.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]    [,2]       \n[1,] \"Brett\" \"Marsellus\"\n[2,] \"Brett\" \"Marvin\"   \n[3,] \"Brett\" \"Roger\"    \n[4,] \"Brett\" \"Vincent\"  \n[5,] \"Buddy\" \"Mia\"      \n[6,] \"Buddy\" \"Vincent\"  \n```\n:::\n:::\n\n\nWe can see that the `as_edgelist` function takes the `igraph` network object as input and returns an $E \\times 2$ matrix, with $E = 102$ being the number of rows. Each column of the matrix records the name of the node on each end of the edge. So the first row of the edge list with entries \"Brett\" and \"Marsellus\" tells us that there is an edge linking Brett and Marsellus, and so forth for each row. \n\nTo compute the correlation between the degrees of each node, all we need to do is attach the corresponding degrees to each name for each of the columns of the edge list, which can be done via data wrangling magic from the `dplyr` package (part of the `tidyverse`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   # install.packages(dplyr)\n   library(dplyr)\n   d <- degree(g)\n   deg.dat <- data.frame(name1 = names(d), name2 = names(d), d)\n   el.temp <- data.frame(name2 = g.el[, 2]) %>% \n      left_join(deg.dat, by = \"name2\") %>% \n      dplyr::select(c(\"name2\", \"d\")) %>% \n      rename(d2 = d) \n   d.el <- data.frame(name1 = g.el[, 1]) %>% \n      left_join(deg.dat, by = \"name1\") %>% \n      dplyr::select(c(\"name1\", \"d\")) %>% \n      rename(d1 = d) %>% \n      cbind(el.temp)\nhead(d.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  name1 d1     name2 d2\n1 Brett  7 Marsellus 10\n2 Brett  7    Marvin  6\n3 Brett  7     Roger  6\n4 Brett  7   Vincent 25\n5 Buddy  2       Mia 11\n6 Buddy  2   Vincent 25\n```\n:::\n:::\n\n\nLine 3 creates a two-column data frame called \"deg.dat\" with as many rows as there are nodes in the network. The first two columns contain the names of each node (identically listed with different names) and the third columns contains the corresponding node's degree. \n\nLines 4-7 use `dplyr` functions to create a new object \"el.temp\" joining the degree information to each of the node names listed in the second position in the original edge list \"g.el,\" and rename the imported column of degrees \"d2.\" \n\nLines 8-12 do the same for the nodes listed in the first position in the original edge list, renames the imported columns of degrees \"d1,\" and the binds the columns of the \"el.temp\" object to the new object \"d.el.\" The resulting object has four columns: Two for the names of the nodes incident to each edge on the edge list (columns 1 and 3), and two other ones corresponding to the degrees of the corresponding nodes (columns 2 and 4). \n\nWe can see from the output of the first few rows of the \"d.el\" object that indeed \"Brett\" is assigned a degree of 7 in each row of the edge list, \"BUDDY\" a degree of 2, \"Marsellus\" a degree of 10, \"Vincent\" a degree of 25 and so forth. \n\nNow to compute the degree correlation in the network all we need to do is call the native `R` function `cor` on the two columns from \"d.el\" that containing the degree information. **Note that because each degree appears twice at the end of each edge in an undirected graph (as both \"sender\" and \"receiver\"), we need to double each column by appending the other degree column at the end**. So the first degree column is the vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d1 <- c(d.el$d1, d.el$d2)\n```\n:::\n\n\nAnd the second degree column is the vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   d2 <- c(d.el$d2, d.el$d1)\n```\n:::\n\n\nAnd the graph's degree correlation [@newman03] is just the Pearson correlation between these two degree vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   cor(d1, d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.2896427\n```\n:::\n:::\n\n\nThe result $r_{deg} = -0.29$ tells us that there is *anti-correlation* by degree in the *Pulp Fiction* network. That is high-degree characters tend to appear with low degree characters, or conversely, high-degree characters (like Marsellus and Jules) don't appear together very often.\n\nIf you hate `dplyr` (and some people do with a passion) here's a relatively quick way to do the same thing without it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   A <- as.matrix(as_adjacency_matrix(g)) \n   dat <- data.frame(e = as.vector(A), #vectorized version of adjacency matrix\n                     rd = rep(rowSums(A), ncol(A)), \n                     cd = rep(colSums(A), each = nrow(A)),\n                     rn = rep(rownames(A), ncol(A)),\n                     cn = rep(colnames(A), each = nrow(A))\n                     )\n   cor(dat[dat$e == 1, ]$rd, dat[dat$e == 1, ]$cd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.2896427\n```\n:::\n:::\n\n\nOf course, `igraph` has a function called `assortativity_degree` that does all the work for us:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   assortativity_degree(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.2896427\n```\n:::\n:::\n\n\n## The Average Shortest Path Length\n\nThe final statistic people use to characterize networks is the **average shortest path length**. In a network, even non-adjacent nodes, could be **indirectly connected** to other nodes via a **path** of some **length** ($l > 1$) So it is useful to know what the average of this quantity is across all dyads in the network. \n\nTo do that, we first need to compute the length of the shortest path $l$ for each pair of nodes in the network (also known as the **geodesic distance**). Adjacent nodes get an automatic score of $l = 1$. In `igraph` this is done as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   S <- distances(g)\n   S[1:7, 1:7]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Brett Buddy Butch Capt Koons Ed Sullivan English Dave Esmeralda\nBrett            0     2     1          2           2            2         2\nBuddy            2     0     2          2           2            2         3\nButch            1     2     0          1           2            1         1\nCapt Koons       2     2     1          0           2            2         2\nEd Sullivan      2     2     2          2           0            2         3\nEnglish Dave     2     2     1          2           2            0         2\nEsmeralda        2     3     1          2           3            2         0\n```\n:::\n:::\n\n\nThe `igraph` function `distances` takes the network object as input and returns the desired shortest path matrix. So for instance, Brett is directly connected to Butch (they appear in a scene together) but indirectly connected to Buddy via a path of length two (they both appear in scenes with common neighbors even if they don't appear together). \n\nThe maximum distance between two nodes in the graph (the longest shortest path to put it confusingly) is called the **graph diameter**. We can find this out simply by using the native `R` function for the maximum on the shortest paths matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   max(S)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nThis means that in the *Pulp Fiction* network the maximum degree of separation between two characters is a path of length 8. \n\nOf course, we can also call the `igraph` function `diameter`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   diameter(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nOnce we have the geodesic distance matrix, it is easy to calculate the average path length of the graph: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n   rs.S <- rowSums(S)\n   rm.S <- rs.S/(vcount(g) - 1)\n   mean(rm.S)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.325747\n```\n:::\n:::\n\n\n- First (line 1) we sum all the rows (or columns) of the geodesic distance matrix. This vector (of the same length as the number of nodes) gives us the sum of the geodesic distance of each node to each of the nodes (we will use this to compute [**closeness centrality**](closcent.qmd) later). \n\n- Then (line 2) we divide this vector by the number of nodes minus one (to exclude the focal node) to create a vector of the *average* distance of each node to each of the other nodes. \n\n- Finally (line 3) we take the average across all nodes of this average distance vector to get the *graph*'s average shortest path length, which in this case equals L =  2.33.  \n\nThis means that, on average, each character in *Pulp Fiction* is separated by little less than three contacts in the co-appearance network (a fairly small world).\n\nOf course this can also be done in just one step on `igraph`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   mean_distance(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.325747\n```\n:::\n:::\n\n\n## Putting it all Together\n\nNow we can put together all the basic network statistics that we have computed into some sort of summary table, like the ones [here](https://networkrepository.com/soc.php). We first create a vector with the names of each statistic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Stat <- c(\"Nodes\", \"Edges\", \"Min. Degree\", \"Max. Degree\", \"Avg. Degree\", \"Degree Corr.\", \"Diameter\", \"Avg. Shortest Path Length\")\n```\n:::\n\n\nThen we create a vector with the values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   Value <- c(vcount(g), ecount(g), min(d), max(d), round(mean(d), 2), round(assortativity_degree(g), 2), max(S), round(mean_distance(g), 2))\n```\n:::\n\n\nWe can then put these two vector together into a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   net.stats <- data.frame(Stat, Value)\n```\n:::\n\nWe can then use the package `kableExtra` (a nice table maker) to create a nice html table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n   # intall.packages(kableExtra)\n   library(kableExtra)\n   kbl(net.stats, format = \"pipe\", align = c(\"l\", \"c\"),\n       caption = \"Key Statistics for Pulp Fiction Network.\") %>% \n   kable_styling(bootstrap_options = c(\"hover\", \"condensed\", \"responsive\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-hover table-condensed table-responsive\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Key Statistics for Pulp Fiction Network.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Stat </th>\n   <th style=\"text-align:center;\"> Value </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Nodes </td>\n   <td style=\"text-align:center;\"> 38.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Edges </td>\n   <td style=\"text-align:center;\"> 102.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Min. Degree </td>\n   <td style=\"text-align:center;\"> 1.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Max. Degree </td>\n   <td style=\"text-align:center;\"> 25.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Avg. Degree </td>\n   <td style=\"text-align:center;\"> 5.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Degree Corr. </td>\n   <td style=\"text-align:center;\"> -0.29 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Diameter </td>\n   <td style=\"text-align:center;\"> 5.00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Avg. Shortest Path Length </td>\n   <td style=\"text-align:center;\"> 2.33 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n",
    "supporting": [
      "basic_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}